# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hanami` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Hanami
  class << self
    def app; end
    def app?(app); end
    def boot; end
    def code_reloading?; end
    def configuration; end
    def configure(&blk); end
    def env; end
    def env?(*names); end
    def environment; end
    def logger; end
    def plugin(&blk); end
    def plugins; end
    def public_directory; end
    def root; end
  end
end

module Hanami::Action
  include ::Hanami::Action::Head
  include ::Hanami::Action::Mime
  include ::Hanami::Action::Redirect
  include ::Hanami::Action::Exposable::Guard
  include ::Hanami::Action::Exposable
  include ::Hanami::Action::Throwable
  include ::Hanami::Utils::ClassAttribute
  include ::Hanami::Action::Callbacks
  include ::Hanami::Action::Validatable
  include ::Hanami::Action::Glue
  include ::Hanami::Action::Configurable
  include ::Hanami::Action::Rack

  private

  def finish; end
  def flash; end
  def session; end

  class << self
    def included(base); end
  end
end

module Hanami::Action::CSRFProtection
  private

  def generate_csrf_token; end
  def handle_invalid_csrf_token; end
  def invalid_csrf_token?; end
  def missing_csrf_token?; end
  def set_csrf_token; end
  def verify_csrf_token; end
  def verify_csrf_token?; end

  class << self
    def included(action); end
  end
end

Hanami::Action::CSRFProtection::CSRF_TOKEN = T.let(T.unsafe(nil), Symbol)
Hanami::Action::CSRFProtection::IDEMPOTENT_HTTP_METHODS = T.let(T.unsafe(nil), Hash)
class Hanami::Action::InvalidCSRFTokenError < ::StandardError; end

class Hanami::App
  def initialize(configuration, environment); end

  def call(env); end

  private

  def app; end
  def builder; end
  def middleware(configuration, environment); end
  def mount(configuration); end
  def routes; end
end

class Hanami::Application
  def initialize; end

  def call(env); end

  private

  def configuration; end
  def middleware; end
  def renderer; end

  class << self
    def inherited(base); end
  end
end

module Hanami::Application::ClassMethods
  def app_name; end
  def configuration=(configuration); end
  def configure(environment = T.unsafe(nil), &blk); end

  class << self
    def extended(base); end
  end
end

class Hanami::ApplicationConfiguration
  def initialize(namespace, configurations, path_prefix, env: T.unsafe(nil)); end

  def adapter(*options); end
  def app_name; end
  def assets(&blk); end
  def body_parsers(*parsers); end
  def controller; end
  def controller_pattern(value = T.unsafe(nil)); end
  def cookies(options = T.unsafe(nil)); end
  def default_request_format(format = T.unsafe(nil)); end
  def default_response_format(format = T.unsafe(nil)); end
  def force_ssl(value = T.unsafe(nil)); end
  def handle_exceptions(value = T.unsafe(nil)); end
  def host(value = T.unsafe(nil)); end
  def layout(value = T.unsafe(nil)); end
  def load_paths; end
  def middleware; end
  def model; end
  def namespace; end
  def path_prefix; end
  def port(value = T.unsafe(nil)); end
  def root(value = T.unsafe(nil)); end
  def routes(path = T.unsafe(nil), &blk); end
  def scheme(value = T.unsafe(nil)); end
  def security; end
  def sessions(adapter = T.unsafe(nil), options = T.unsafe(nil)); end
  def ssl?; end
  def templates(value = T.unsafe(nil)); end
  def view; end
  def view_pattern(value = T.unsafe(nil)); end

  private

  def configurations; end
  def evaluate_configurations!; end
end

Hanami::ApplicationConfiguration::DEFAULT_SSL_PORT = T.let(T.unsafe(nil), Integer)
Hanami::ApplicationConfiguration::SSL_SCHEME = T.let(T.unsafe(nil), String)

class Hanami::ApplicationName
  def initialize(name); end

  def to_env_s; end
  def to_s; end
  def to_str; end

  private

  def ensure_validity!; end
  def sanitize(name); end

  class << self
    def invalid?(name); end
  end
end

Hanami::ApplicationName::RESERVED_WORDS = T.let(T.unsafe(nil), Array)

class Hanami::ApplicationNamespace
  class << self
    def resolve(name); end
  end
end

class Hanami::CommonLogger < ::Rack::CommonLogger
  private

  def extract_params(env); end
  def log(env, status, header, began_at); end
end

class Hanami::CommonLogger::ElapsedTime
  class << self
    def call; end
  end
end

Hanami::CommonLogger::FORM_HASH = T.let(T.unsafe(nil), String)
Hanami::CommonLogger::HTTP_VERSION = T.let(T.unsafe(nil), String)
Hanami::CommonLogger::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)
Hanami::CommonLogger::PATH_INFO = T.let(T.unsafe(nil), String)
Hanami::CommonLogger::QUERY_HASH = T.let(T.unsafe(nil), String)
Hanami::CommonLogger::RACK_ERRORS = T.let(T.unsafe(nil), String)
Hanami::CommonLogger::REMOTE_ADDR = T.let(T.unsafe(nil), String)
Hanami::CommonLogger::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Hanami::CommonLogger::ROUTER_PARAMS = T.let(T.unsafe(nil), String)
Hanami::CommonLogger::SCRIPT_NAME = T.let(T.unsafe(nil), String)

module Hanami::Components
  class << self
    def [](name); end
    def component(name); end
    def register(name, &blk); end
    def release; end
    def resolve(*names); end
    def resolved(name, value = T.unsafe(nil), &blk); end
  end
end

class Hanami::Components::Component
  def initialize(name, &blk); end

  def call(configuration); end

  private

  def _prepare; end
  def _prepare=(_arg0); end
  def _resolve; end
  def _resolve=(_arg0); end
  def _run; end
  def _run=(_arg0); end
  def component(name); end
  def logger_interface?(instance); end
  def name; end
  def prepare(&blk); end
  def requirements; end
  def requirements=(names); end
  def requires(*components); end
  def resolve(&blk); end
  def resolve_requirements; end
  def resolved(name, value = T.unsafe(nil), &blk); end
  def run(&blk); end
end

Hanami::Components::Component::LOGGER_METHODS = T.let(T.unsafe(nil), Array)
module Hanami::Config; end

class Hanami::Config::Cookies
  def initialize(configuration, options = T.unsafe(nil)); end

  def default_options; end
  def enabled?; end
end

class Hanami::Config::FrameworkConfiguration < ::BasicObject
  def initialize(&blk); end

  def __add(&blk); end
  def __apply(configuration); end
  def method_missing(m, *args, &blk); end
end

class Hanami::Config::LoadPaths < ::Hanami::Utils::LoadPaths
  def initialize(root); end

  def load!; end

  protected

  def realpath(path); end
end

class Hanami::Config::Mapper
  def initialize(root, path, &blk); end

  def to_proc; end

  private

  def error_message; end
  def realpath; end
end

Hanami::Config::Mapper::EXTNAME = T.let(T.unsafe(nil), String)

class Hanami::Config::Routes < ::Hanami::Config::Mapper
  private

  def error_message; end
end

class Hanami::Config::Security
  def content_security_policy(value = T.unsafe(nil)); end
  def x_content_type_options(value = T.unsafe(nil)); end
  def x_frame_options(value = T.unsafe(nil)); end
  def x_xss_protection(value = T.unsafe(nil)); end
end

Hanami::Config::Security::CONTENT_SECURITY_POLICY_HEADER = T.let(T.unsafe(nil), String)
Hanami::Config::Security::SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Config::Security::SPACED_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Config::Security::X_CONTENT_TYPE_OPTIONS_HEADER = T.let(T.unsafe(nil), String)
Hanami::Config::Security::X_FRAME_OPTIONS_HEADER = T.let(T.unsafe(nil), String)
Hanami::Config::Security::X_XSS_PROTECTION_HEADER = T.let(T.unsafe(nil), String)

class Hanami::Config::Sessions
  def initialize(adapter = T.unsafe(nil), options = T.unsafe(nil), configuration = T.unsafe(nil)); end

  def enabled?; end
  def middleware; end

  private

  def default_options; end
  def domain; end
  def ip_address?(string); end
  def options; end
end

Hanami::Config::Sessions::BLACKLISTED_DOMAINS = T.let(T.unsafe(nil), Array)
Hanami::Config::Sessions::RACK_NAMESPACE = T.let(T.unsafe(nil), String)

class Hanami::Configuration
  def initialize(&blk); end

  def apps; end
  def early_hints(value = T.unsafe(nil)); end
  def environment(name); end
  def logger(*options); end
  def mailer(&blk); end
  def mailer_settings; end
  def middleware; end
  def model(&blk); end
  def mount(app, options); end
  def mounted; end

  private

  def settings; end
end

class Hanami::Configuration::App < ::SimpleDelegator
  def initialize(app, options = T.unsafe(nil)); end

  def host; end
  def path_prefix; end
end

class Hanami::Configuration::Middleware
  def initialize; end

  def each(&blk); end
  def use(middleware, *args, &blk); end
end

Hanami::DEFAULT_PUBLIC_DIRECTORY = T.let(T.unsafe(nil), String)

class Hanami::Env
  def initialize(env: T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def load!(path); end
end

class Hanami::Environment
  def initialize(options = T.unsafe(nil)); end

  def apps_path; end
  def bundler_groups; end
  def code_reloading?; end
  def config; end
  def default_port?; end
  def env_config; end
  def environment; end
  def environment?(*names); end
  def host; end
  def port; end
  def project_environment_configuration; end
  def project_name; end
  def rackup; end
  def require_application_environment; end
  def require_project_environment; end
  def root; end
  def serve_static_assets?; end
  def static_assets_middleware; end
  def to_options; end

  private

  def default_host; end
  def dotenv_applicable?(file); end
  def env; end
  def rack_env; end
  def set_application_env_vars!; end
  def set_env_vars!; end
  def set_hanami_env_vars!; end
end

Hanami::Environment::APPS_PATH = T.let(T.unsafe(nil), String)
Hanami::Environment::CODE_RELOADING = T.let(T.unsafe(nil), Hash)
Hanami::Environment::DEFAULT_CONFIG = T.let(T.unsafe(nil), String)
Hanami::Environment::DEFAULT_ENV = T.let(T.unsafe(nil), String)
Hanami::Environment::DEFAULT_ENVIRONMENT_CONFIG = T.let(T.unsafe(nil), String)
Hanami::Environment::DEFAULT_HOST = T.let(T.unsafe(nil), String)
Hanami::Environment::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Hanami::Environment::DEFAULT_RACKUP = T.let(T.unsafe(nil), String)
Hanami::Environment::DOTENV_FILES = T.let(T.unsafe(nil), Array)
Hanami::Environment::DOTENV_LOCAL_FILE = T.let(T.unsafe(nil), String)
Hanami::Environment::HANAMI_ENV = T.let(T.unsafe(nil), String)
Hanami::Environment::HANAMI_HOST = T.let(T.unsafe(nil), String)
Hanami::Environment::HANAMI_PORT = T.let(T.unsafe(nil), String)
Hanami::Environment::LISTEN_ALL_HOST = T.let(T.unsafe(nil), String)
Hanami::Environment::LOCK = T.let(T.unsafe(nil), Thread::Mutex)
Hanami::Environment::PRODUCTION_ENV = T.let(T.unsafe(nil), String)
Hanami::Environment::RACK_ENV = T.let(T.unsafe(nil), String)
Hanami::Environment::RACK_ENV_DEPLOYMENT = T.let(T.unsafe(nil), String)
Hanami::Environment::SERVE_STATIC_ASSETS = T.let(T.unsafe(nil), String)
Hanami::Environment::SERVE_STATIC_ASSETS_ENABLED = T.let(T.unsafe(nil), String)
Hanami::Environment::TEST_ENV = T.let(T.unsafe(nil), String)

class Hanami::EnvironmentApplicationConfigurations
  def initialize; end

  def add(environment, &blk); end
  def each(environment, &blk); end

  private

  def configurations; end
  def matching_env?(environment, env); end
end

Hanami::EnvironmentApplicationConfigurations::ALL = T.let(T.unsafe(nil), Symbol)

class Hanami::Hanamirc
  def initialize(root); end

  def default_options; end
  def exists?; end
  def options; end

  private

  def file_options; end
  def parse_file(path); end
  def path_file; end
  def project_name; end
  def symbolize(hash); end
end

Hanami::Hanamirc::DEFAULT_TEMPLATE = T.let(T.unsafe(nil), String)
Hanami::Hanamirc::DEFAULT_TEST_SUITE = T.let(T.unsafe(nil), String)
Hanami::Hanamirc::FILE_NAME = T.let(T.unsafe(nil), String)
Hanami::Hanamirc::PROJECT_NAME = T.let(T.unsafe(nil), String)
Hanami::Hanamirc::SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Hanamirc::TEMPLATE_KEY = T.let(T.unsafe(nil), String)
Hanami::Hanamirc::TEST_KEY = T.let(T.unsafe(nil), String)

module Hanami::Mailer
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Utils::ClassAttribute::ClassMethods
  include ::Hanami::Utils::ClassAttribute

  mixes_in_class_methods ::Hanami::Mailer::ClassMethods

  def initialize(locals = T.unsafe(nil)); end

  def deliver; end
  def render(format); end

  protected

  def charset; end
  def mail; end
  def method_missing(method_name); end
  def prepare; end

  private

  def __dsl(method_name); end
  def __part(format); end
  def __part?(format); end
  def build; end
  def respond_to_missing?(method_name, _include_all); end

  class << self
    def configuration; end
    def configuration=(_arg0); end
    def configure(&blk); end
    def deliveries; end
    def included(base); end
    def load!; end
  end
end

Hanami::Mailer::CONTENT_TYPES = T.let(T.unsafe(nil), Hash)

module Hanami::Mailer::Glue
  class << self
    def included(configuration); end
  end
end

Hanami::Mailer::VERSION = T.let(T.unsafe(nil), String)

class Hanami::MiddlewareStack
  def initialize(configuration); end

  def call(env); end
  def load!; end
  def prepend(middleware, *args, &blk); end
  def use(middleware, *args, &blk); end

  private

  def _load_default_welcome_page; end
  def _load_session_middleware; end
  def builder; end
  def configuration; end
  def load_default_stack; end
  def load_middleware(middleware); end
  def routes; end
  def stack; end
end

class Hanami::RenderingPolicy
  def initialize(configuration); end

  def render(env, response); end

  private

  def _render(env, response); end
  def _render_action(action, env, response); end
  def _render_status_page(action, response); end
  def render_status_page?(action, response); end
  def renderable?(env); end
  def view_for(action, response); end
end

Hanami::RenderingPolicy::BODY = T.let(T.unsafe(nil), Integer)
Hanami::RenderingPolicy::ERROR_STATUS = T.let(T.unsafe(nil), Integer)
Hanami::RenderingPolicy::HANAMI_ACTION = T.let(T.unsafe(nil), String)
Hanami::RenderingPolicy::HEADERS = T.let(T.unsafe(nil), Integer)
Hanami::RenderingPolicy::RACK_EXCEPTION = T.let(T.unsafe(nil), String)
Hanami::RenderingPolicy::RENDERABLE_FORMATS = T.let(T.unsafe(nil), Array)
Hanami::RenderingPolicy::STATUS = T.let(T.unsafe(nil), Integer)
Hanami::RenderingPolicy::SUCCESSFUL_STATUSES = T.let(T.unsafe(nil), Range)
Hanami::VERSION = T.let(T.unsafe(nil), String)

module Hanami::Version
  class << self
    def gem_requirement; end
    def major_minor; end
    def prerelease?; end
    def version; end
  end
end

Hanami::Version::VERSION = T.let(T.unsafe(nil), String)
module Hanami::Views; end

class Hanami::Views::Default
  extend ::Hanami::Utils::ClassAttribute::ClassMethods
  include ::Hanami::View
  include ::Hanami::View::Rendering::InstanceMethods
  include ::Hanami::View::Escape::InstanceMethods
  extend ::Hanami::View::Inheritable
  extend ::Hanami::View::Dsl
  extend ::Hanami::View::Rendering
  extend ::Hanami::View::Escape
  include ::Hanami::Utils::ClassAttribute

  class << self
    def autoescape_methods; end
    def autoescape_methods=(_arg0); end
    def configuration; end
    def configuration=(_arg0); end
    def render(root, template_name, context); end
  end
end

class Hanami::Views::DefaultTemplateFinder < ::Hanami::View::Rendering::TemplateFinder
  def initialize(view, root, template_name, format); end

  private

  def root; end
end

class Hanami::Views::NullView
  def render(_context); end
end

module Mailers; end

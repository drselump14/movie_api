# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `anyway_config` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Anyway
  class << self
    def env; end
    def loaders; end
  end
end

module Anyway::AutoCast
  class << self
    def call(val); end
  end
end

Anyway::AutoCast::ARRAY_RXP = T.let(T.unsafe(nil), Regexp)

class Anyway::Config
  include ::Anyway::OptparseConfig
  include ::Anyway::DynamicConfig
  extend ::Anyway::OptparseConfig::ClassMethods
  extend ::Anyway::DynamicConfig::ClassMethods

  def initialize(overrides = T.unsafe(nil)); end

  def clear; end
  def config_name; end
  def deconstruct_keys(keys); end
  def dig(*keys); end
  def dup; end
  def env_prefix; end
  def inspect; end
  def load(overrides = T.unsafe(nil)); end
  def load_from_sources(base_config, **options); end
  def pretty_print(q); end
  def reload(overrides = T.unsafe(nil)); end
  def resolve_config_path(name, env_prefix); end
  def to_h; end
  def to_source_trace; end

  private

  def __trace__; end
  def raise_validation_error(msg); end
  def validate_required_attributes!; end
  def values; end
  def write_config_attr(key, val); end

  class << self
    def attr_config(*args, **hargs); end
    def config_attributes; end
    def config_name(val = T.unsafe(nil)); end
    def defaults; end
    def env_prefix(val = T.unsafe(nil)); end
    def explicit_config_name; end
    def explicit_config_name?; end
    def load_callbacks; end
    def new_empty_config; end
    def on_load(*names, &block); end
    def required(*names); end
    def required_attributes; end

    private

    def accessors_module; end
    def build_config_name; end
    def define_config_accessor(*names); end
    def validate_param_names!(names); end
  end
end

class Anyway::Config::BlockCallback
  def initialize(block); end

  def apply_to(config); end
  def block; end
end

class Anyway::Config::Error < ::StandardError; end

class Anyway::Config::NamedCallback
  def initialize(name); end

  def apply_to(config); end
  def name; end
end

Anyway::Config::PARAM_NAME = T.let(T.unsafe(nil), Regexp)
Anyway::Config::RESERVED_NAMES = T.let(T.unsafe(nil), Array)
class Anyway::Config::ValidationError < ::Anyway::Config::Error; end

module Anyway::DynamicConfig
  mixes_in_class_methods ::Anyway::DynamicConfig::ClassMethods

  class << self
    def included(base); end
  end
end

module Anyway::DynamicConfig::ClassMethods
  def for(name, **options); end
end

class Anyway::Env
  include ::Anyway::Tracing

  def initialize(type_cast: T.unsafe(nil)); end

  def clear; end
  def data; end
  def fetch(prefix); end
  def fetch_with_trace(prefix); end
  def traces; end
  def type_cast; end

  private

  def parse_env(prefix); end
end

module Anyway::Ext; end
module Anyway::Ext::DeepDup; end
module Anyway::Ext::DeepFreeze; end
module Anyway::Ext::Hash; end
module Anyway::Loaders; end

class Anyway::Loaders::Base
  include ::Anyway::Tracing

  def initialize(local:); end

  def use_local?; end

  class << self
    def call(local: T.unsafe(nil), **opts); end
  end
end

class Anyway::Loaders::Env < ::Anyway::Loaders::Base
  def call(env_prefix:, **_options); end
end

class Anyway::Loaders::Registry
  def initialize; end

  def append(id, handler = T.unsafe(nil), &block); end
  def delete(id); end
  def each(&block); end
  def freeze; end
  def insert_after(another_id, id, handler = T.unsafe(nil), &block); end
  def insert_before(another_id, id, handler = T.unsafe(nil), &block); end
  def override(id, handler); end
  def prepend(id, handler = T.unsafe(nil), &block); end
  def registry; end

  private

  def find(id); end
  def insert_at(index, id, handler); end
end

class Anyway::Loaders::YAML < ::Anyway::Loaders::Base
  def call(config_path:, **_options); end

  private

  def load_base_yml(path); end
  def load_local_yml(path); end
  def local_config_path(path); end
  def parse_yml(path); end
  def relative_config_path(path); end
end

class Anyway::OptionParserBuilder
  class << self
    def call(options); end

    private

    def option_parser_on_args(key, flag: T.unsafe(nil), desc: T.unsafe(nil), type: T.unsafe(nil)); end
  end
end

module Anyway::OptparseConfig
  mixes_in_class_methods ::Anyway::OptparseConfig::ClassMethods

  def option_parser; end
  def parse_options!(options); end

  class << self
    def included(base); end
  end
end

module Anyway::OptparseConfig::ClassMethods
  def describe_options(**hargs); end
  def extend_options(&block); end
  def flag_options(*args); end
  def ignore_options(*args); end
  def option_parser_descriptors; end
  def option_parser_extensions; end
  def option_parser_options; end
end

class Anyway::Settings
  class << self
    def default_config_path; end
    def default_config_path=(val); end
    def future; end
    def tracing_enabled; end
    def tracing_enabled=(_arg0); end
    def use_local_files; end
    def use_local_files=(_arg0); end
  end
end

class Anyway::Settings::Future
  def initialize; end

  def use(*names); end

  private

  def store; end

  class << self
    def setting(name, default_value); end
    def settings; end
  end
end

module Anyway::Tracing
  private

  def trace!(type, *path, **opts); end

  class << self
    def capture; end
    def current_trace; end
    def current_trace_source; end
    def source_stack; end
    def trace!(type, *path, **opts); end
    def trace_stack; end
    def tracing?; end
    def with_trace_source(src); end

    private

    def accessor_source(location); end
  end
end

class Anyway::Tracing::Trace
  def initialize(type = T.unsafe(nil), value = T.unsafe(nil), **source); end

  def clear; end
  def dig(*_arg0, &_arg1); end
  def dup; end
  def keep_if(*_arg0, &_arg1); end
  def merge!(another_trace); end
  def merge_values(hash, **opts); end
  def pretty_print(q); end
  def record_value(val, *path, **opts); end
  def source; end
  def to_h; end
  def trace?; end
  def type; end
  def value; end
end

Anyway::Tracing::Trace::UNDEF = T.let(T.unsafe(nil), Object)

module Anyway::Utils
  class << self
    def deep_merge!(source, other); end
  end
end

Anyway::VERSION = T.let(T.unsafe(nil), String)

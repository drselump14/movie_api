# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sequel` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

class Numeric
  include ::Comparable
end

module Sequel
  include ::Sequel::SQL::Constants
  extend ::Sequel::SQL::Builders
  extend ::Sequel::SQL::OperatorBuilders
  extend ::Sequel::Timezones

  class << self
    def Model(source); end
    def [](arg = T.unsafe(nil), &block); end
    def ado(*args, &block); end
    def amalgalite(*args, &block); end
    def cache_anonymous_models; end
    def cache_anonymous_models=(v); end
    def condition_specifier?(obj); end
    def connect(*args, &block); end
    def convert_exception_class(exception, klass); end
    def convert_two_digit_years; end
    def convert_two_digit_years=(_arg0); end
    def core_extensions?; end
    def cubrid(*args, &block); end
    def datetime_class; end
    def datetime_class=(_arg0); end
    def do(*args, &block); end
    def extension(*extensions); end
    def ibmdb(*args, &block); end
    def identifier_input_method=(value); end
    def identifier_output_method=(value); end
    def inflections; end
    def jdbc(*args, &block); end
    def json_parser_error_class; end
    def migration(&block); end
    def mock(*args, &block); end
    def mysql(*args, &block); end
    def mysql2(*args, &block); end
    def object_to_json(obj, *args, &block); end
    def odbc(*args, &block); end
    def oracle(*args, &block); end
    def parse_json(json); end
    def postgres(*args, &block); end
    def quote_identifiers=(value); end
    def recursive_map(array, converter); end
    def require(files, subdir = T.unsafe(nil)); end
    def single_threaded; end
    def single_threaded=(_arg0); end
    def split_symbol(sym); end
    def split_symbols=(v); end
    def split_symbols?; end
    def sqlanywhere(*args, &block); end
    def sqlite(*args, &block); end
    def string_to_date(string); end
    def string_to_datetime(string); end
    def string_to_time(string); end
    def swift(*args, &block); end
    def synchronize(&block); end
    def tinytds(*args, &block); end
    def transaction(dbs, opts = T.unsafe(nil), &block); end
    def version; end
    def virtual_row(&block); end

    private

    def adapter_method(adapter, *args, &block); end
    def def_adapter_method(*adapters); end
  end
end

Sequel::ADAPTER_MAP = T.let(T.unsafe(nil), Hash)

class Sequel::ASTTransformer
  def transform(obj); end

  private

  def v(o); end
end

class Sequel::AdapterNotFound < ::Sequel::Error; end

class Sequel::BasicObject < ::BasicObject
  class << self
    def const_missing(name); end
    def remove_methods!; end
  end
end

Sequel::BeforeHookFailed = Sequel::HookFailed
Sequel::COLUMN_REF_RE1 = T.let(T.unsafe(nil), Regexp)
Sequel::COLUMN_REF_RE2 = T.let(T.unsafe(nil), Regexp)
Sequel::COLUMN_REF_RE3 = T.let(T.unsafe(nil), Regexp)
class Sequel::CheckConstraintViolation < ::Sequel::ConstraintViolation; end

class Sequel::ConnectionPool
  extend ::Sequel::ConnectionPool::ClassMethods

  def initialize(db, opts = T.unsafe(nil)); end

  def after_connect; end
  def after_connect=(_arg0); end
  def created_count(*args); end
  def db; end
  def db=(_arg0); end
  def servers; end

  private

  def disconnect_connection(conn); end
  def disconnect_error?(exception); end
  def make_new(server); end
end

Sequel::ConnectionPool::CONNECTION_POOL_MAP = T.let(T.unsafe(nil), Hash)
Sequel::ConnectionPool::CONNECTION_POOL__MAP = T.let(T.unsafe(nil), Hash)

module Sequel::ConnectionPool::ClassMethods
  def get_pool(db, opts = T.unsafe(nil)); end

  private

  def connection_pool_class(opts); end
end

Sequel::ConnectionPool::DEFAULT_SERVER = T.let(T.unsafe(nil), Symbol)
Sequel::ConnectionPool::OPTS = T.let(T.unsafe(nil), Hash)
class Sequel::ConstraintViolation < ::Sequel::DatabaseError; end
Sequel::DATABASES = T.let(T.unsafe(nil), Array)
Sequel::DEFAULT_INFLECTIONS_PROC = T.let(T.unsafe(nil), Proc)

class Sequel::Database
  def initialize(opts = T.unsafe(nil)); end

  def <<(sql); end
  def [](*args); end
  def adapter_scheme; end
  def add_column(table, *args); end
  def add_index(table, columns, options = T.unsafe(nil)); end
  def add_servers(servers); end
  def after_commit(opts = T.unsafe(nil), &block); end
  def after_rollback(opts = T.unsafe(nil), &block); end
  def alter_table(name, generator = T.unsafe(nil), &block); end
  def alter_table_generator(&block); end
  def cache_schema; end
  def cache_schema=(_arg0); end
  def call(ps_name, hash = T.unsafe(nil), &block); end
  def cast_type_literal(type); end
  def create_join_table(hash, options = T.unsafe(nil)); end
  def create_join_table!(hash, options = T.unsafe(nil)); end
  def create_join_table?(hash, options = T.unsafe(nil)); end
  def create_or_replace_view(name, source, options = T.unsafe(nil)); end
  def create_table(name, options = T.unsafe(nil), &block); end
  def create_table!(name, options = T.unsafe(nil), &block); end
  def create_table?(name, options = T.unsafe(nil), &block); end
  def create_table_generator(&block); end
  def create_view(name, source, options = T.unsafe(nil)); end
  def database_type; end
  def dataset; end
  def dataset_class; end
  def dataset_class=(c); end
  def default_string_column_size; end
  def default_string_column_size=(_arg0); end
  def disconnect(opts = T.unsafe(nil)); end
  def disconnect_connection(conn); end
  def drop_column(table, *args); end
  def drop_index(table, columns, options = T.unsafe(nil)); end
  def drop_join_table(hash, options = T.unsafe(nil)); end
  def drop_table(*names); end
  def drop_table?(*names); end
  def drop_view(*names); end
  def each_server(&block); end
  def execute_ddl(sql, opts = T.unsafe(nil), &block); end
  def execute_dui(sql, opts = T.unsafe(nil), &block); end
  def execute_insert(sql, opts = T.unsafe(nil), &block); end
  def extend_datasets(mod = T.unsafe(nil), &block); end
  def extension(*exts); end
  def fetch(sql, *args, &block); end
  def freeze; end
  def from(*args, &block); end
  def from_application_timestamp(v); end
  def get(*args, &block); end
  def global_index_namespace?; end
  def in_transaction?(opts = T.unsafe(nil)); end
  def inspect; end
  def literal(v); end
  def literal_symbol(sym); end
  def literal_symbol_set(sym, lit); end
  def log_connection_info; end
  def log_connection_info=(_arg0); end
  def log_connection_yield(sql, conn, args = T.unsafe(nil)); end
  def log_exception(exception, message); end
  def log_info(message, args = T.unsafe(nil)); end
  def log_warn_duration; end
  def log_warn_duration=(_arg0); end
  def log_yield(sql, args = T.unsafe(nil), &block); end
  def logger=(logger); end
  def loggers; end
  def loggers=(_arg0); end
  def opts; end
  def pool; end
  def prepared_statement(name); end
  def prepared_statements; end
  def quote_identifier(v); end
  def remove_servers(*servers); end
  def rename_column(table, *args); end
  def rename_table(name, new_name); end
  def rollback_checker(opts = T.unsafe(nil)); end
  def run(sql, opts = T.unsafe(nil)); end
  def schema(table, opts = T.unsafe(nil)); end
  def schema_type_class(type); end
  def select(*args, &block); end
  def serial_primary_key_options; end
  def servers; end
  def set_column_default(table, *args); end
  def set_column_type(table, *args); end
  def set_prepared_statement(name, ps); end
  def sharded?; end
  def single_threaded?; end
  def sql_log_level; end
  def sql_log_level=(_arg0); end
  def supports_create_table_if_not_exists?; end
  def supports_deferrable_constraints?; end
  def supports_deferrable_foreign_key_constraints?; end
  def supports_drop_table_if_exists?; end
  def supports_foreign_key_parsing?; end
  def supports_index_parsing?; end
  def supports_partial_indexes?; end
  def supports_prepared_transactions?; end
  def supports_savepoints?; end
  def supports_savepoints_in_prepared_transactions?; end
  def supports_schema_parsing?; end
  def supports_table_listing?; end
  def supports_transaction_isolation_levels?; end
  def supports_transactional_ddl?; end
  def supports_view_listing?; end
  def supports_views_with_check_option?; end
  def supports_views_with_local_check_option?; end
  def synchronize(server = T.unsafe(nil)); end
  def table_exists?(name); end
  def test_connection(server = T.unsafe(nil)); end
  def timezone; end
  def timezone=(_arg0); end
  def to_application_timestamp(v); end
  def transaction(opts = T.unsafe(nil), &block); end
  def transaction_isolation_level; end
  def transaction_isolation_level=(_arg0); end
  def typecast_value(column_type, value); end
  def uri; end
  def url; end
  def valid_connection?(conn); end

  private

  def _metadata_dataset; end
  def _table_exists?(ds); end
  def _trans(conn); end
  def _transaction(conn, opts = T.unsafe(nil)); end
  def _typecast_value_string_to_decimal(value); end
  def adapter_initialize; end
  def add_transaction(conn, opts); end
  def add_transaction_hook(conn, type, block); end
  def already_in_transaction?(conn, opts); end
  def alter_table_add_column_sql(table, op); end
  def alter_table_add_constraint_sql(table, op); end
  def alter_table_drop_column_sql(table, op); end
  def alter_table_drop_constraint_sql(table, op); end
  def alter_table_generator_class; end
  def alter_table_op_sql(table, op); end
  def alter_table_rename_column_sql(table, op); end
  def alter_table_set_column_default_sql(table, op); end
  def alter_table_set_column_null_sql(table, op); end
  def alter_table_set_column_type_sql(table, op); end
  def alter_table_sql(table, op); end
  def alter_table_sql_list(table, operations); end
  def apply_alter_table(name, ops); end
  def apply_alter_table_generator(name, generator); end
  def auto_increment_sql; end
  def begin_new_transaction(conn, opts); end
  def begin_savepoint(conn, opts); end
  def begin_savepoint_sql(depth); end
  def begin_transaction(conn, opts = T.unsafe(nil)); end
  def begin_transaction_sql; end
  def blank_object?(obj); end
  def can_add_primary_key_constraint_on_nullable_columns?; end
  def column_definition_auto_increment_sql(sql, column); end
  def column_definition_collate_sql(sql, column); end
  def column_definition_default_sql(sql, column); end
  def column_definition_null_sql(sql, column); end
  def column_definition_order; end
  def column_definition_primary_key_sql(sql, column); end
  def column_definition_references_sql(sql, column); end
  def column_definition_sql(column); end
  def column_definition_unique_sql(sql, column); end
  def column_list_sql(generator); end
  def column_references_column_constraint_sql(column); end
  def column_references_sql(column); end
  def column_references_table_constraint_sql(constraint); end
  def column_schema_default_string_type?(type); end
  def column_schema_default_to_ruby_value(default, type); end
  def column_schema_max_length(db_type); end
  def column_schema_normalize_default(default, type); end
  def column_schema_to_ruby_default(default, type); end
  def combinable_alter_table_op?(op); end
  def commit_or_rollback_transaction(exception, conn, opts); end
  def commit_savepoint_sql(depth); end
  def commit_transaction(conn, opts = T.unsafe(nil)); end
  def commit_transaction_sql; end
  def connection_execute_method; end
  def connection_info(conn); end
  def connection_pool_default_options; end
  def constraint_deferrable_sql_append(sql, defer); end
  def constraint_definition_sql(constraint); end
  def create_table_as(name, sql, options); end
  def create_table_as_sql(name, sql, options); end
  def create_table_from_generator(name, generator, options); end
  def create_table_generator_class; end
  def create_table_indexes_from_generator(name, generator, options); end
  def create_table_prefix_sql(name, options); end
  def create_table_sql(name, generator, options); end
  def create_view_prefix_sql(name, options); end
  def create_view_sql(name, source, options); end
  def create_view_sql_append_columns(sql, columns); end
  def database_error_class(exception, opts); end
  def database_error_classes; end
  def database_error_regexps; end
  def database_exception_sqlstate(exception, opts); end
  def database_specific_error_class(exception, opts); end
  def database_specific_error_class_from_sqlstate(sqlstate); end
  def dataset_class_default; end
  def default_index_name(table_name, columns); end
  def disconnect_error?(exception, opts); end
  def drop_index_sql(table, op); end
  def drop_table_sql(name, options); end
  def drop_view_sql(name, options); end
  def filter_expr(*args, &block); end
  def folds_unquoted_identifiers_to_uppercase?; end
  def foreign_key_name(table_name, columns); end
  def index_definition_sql(table_name, index); end
  def index_sql_list(table_name, indexes); end
  def initialize_copy(_); end
  def input_identifier_meth(ds = T.unsafe(nil)); end
  def join_table_name(hash, options); end
  def join_table_name_extract(entry); end
  def log_connection_execute(conn, sql); end
  def log_duration(duration, message); end
  def log_each(level, message); end
  def metadata_dataset; end
  def on_delete_clause(action); end
  def on_update_clause(action); end
  def output_identifier_meth(ds = T.unsafe(nil)); end
  def quote_identifiers_default; end
  def quote_schema_table(table); end
  def raise_error(exception, opts = T.unsafe(nil)); end
  def remove_cached_schema(table); end
  def remove_transaction(conn, committed); end
  def rename_table_sql(name, new_name); end
  def reset_default_dataset; end
  def rollback_savepoint_sql(depth); end
  def rollback_transaction(conn, opts = T.unsafe(nil)); end
  def rollback_transaction_sql; end
  def savepoint_level(conn); end
  def schema_and_table(table_name); end
  def schema_autoincrementing_primary_key?(schema); end
  def schema_column_type(db_type); end
  def schema_utility_dataset; end
  def server_opts(server); end
  def set_transaction_isolation(conn, opts); end
  def set_transaction_isolation_sql(level); end
  def split_qualifiers(table_name); end
  def supports_combining_alter_table_ops?; end
  def supports_create_or_replace_view?; end
  def supports_named_column_constraints?; end
  def temporary_table_sql; end
  def transaction_error(e, opts = T.unsafe(nil)); end
  def transaction_finished?(conn); end
  def transaction_hooks(conn, committed); end
  def transaction_options(conn, opts); end
  def type_literal(column); end
  def type_literal_generic(column); end
  def type_literal_generic_bigdecimal(column); end
  def type_literal_generic_bignum_symbol(column); end
  def type_literal_generic_date(column); end
  def type_literal_generic_datetime(column); end
  def type_literal_generic_falseclass(column); end
  def type_literal_generic_file(column); end
  def type_literal_generic_fixnum(column); end
  def type_literal_generic_float(column); end
  def type_literal_generic_integer(column); end
  def type_literal_generic_numeric(column); end
  def type_literal_generic_string(column); end
  def type_literal_generic_time(column); end
  def type_literal_generic_trueclass(column); end
  def type_literal_specific(column); end
  def typecast_value_blob(value); end
  def typecast_value_boolean(value); end
  def typecast_value_date(value); end
  def typecast_value_datetime(value); end
  def typecast_value_decimal(value); end
  def typecast_value_float(value); end
  def typecast_value_integer(value); end
  def typecast_value_string(value); end
  def typecast_value_time(value); end
  def uses_clob_for_text?; end
  def valid_connection_sql; end
  def view_with_check_option_support; end

  class << self
    def adapter_class(scheme); end
    def adapter_scheme; end
    def after_initialize(&block); end
    def connect(conn_string, opts = T.unsafe(nil)); end
    def extension(*extensions); end
    def identifier_input_method; end
    def identifier_input_method=(v); end
    def identifier_output_method; end
    def identifier_output_method=(v); end
    def load_adapter(scheme, opts = T.unsafe(nil)); end
    def quote_identifiers; end
    def quote_identifiers=(v); end
    def register_extension(ext, mod = T.unsafe(nil), &block); end
    def run_after_initialize(instance); end
    def set_shared_adapter_scheme(scheme, mod); end
    def single_threaded; end
    def single_threaded=(v); end

    private

    def set_adapter_scheme(scheme); end
    def uri_to_options(uri); end
  end
end

Sequel::Database::ADAPTERS = T.let(T.unsafe(nil), Array)
Sequel::Database::AUTOINCREMENT = T.let(T.unsafe(nil), String)
Sequel::Database::CHECK_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)
Sequel::Database::COLUMN_DEFINITION_ORDER = T.let(T.unsafe(nil), Array)
Sequel::Database::COLUMN_SCHEMA_DATETIME_TYPES = T.let(T.unsafe(nil), Array)
Sequel::Database::COLUMN_SCHEMA_STRING_TYPES = T.let(T.unsafe(nil), Array)
Sequel::Database::COMBINABLE_ALTER_TABLE_OPS = T.let(T.unsafe(nil), Array)
Sequel::Database::COMMA_SEPARATOR = T.let(T.unsafe(nil), String)
Sequel::Database::CURRENT_TIMESTAMP_RE = T.let(T.unsafe(nil), Regexp)
Sequel::Database::DEFAULT_DATABASE_ERROR_REGEXPS = T.let(T.unsafe(nil), Hash)
Sequel::Database::DEFAULT_JOIN_TABLE_COLUMN_OPTIONS = T.let(T.unsafe(nil), Hash)
Sequel::Database::DEFAULT_STRING_COLUMN_SIZE = T.let(T.unsafe(nil), Integer)
Sequel::Database::DatasetClass = Sequel::Dataset
Sequel::Database::EXTENSIONS = T.let(T.unsafe(nil), Hash)
Sequel::Database::FOREIGN_KEY_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)
Sequel::Database::LEADING_ZERO_RE = T.let(T.unsafe(nil), Regexp)
Sequel::Database::NOT_NULL = T.let(T.unsafe(nil), String)
Sequel::Database::NOT_NULL_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)
Sequel::Database::NULL = T.let(T.unsafe(nil), String)
Sequel::Database::OPTS = T.let(T.unsafe(nil), Hash)
Sequel::Database::PRIMARY_KEY = T.let(T.unsafe(nil), String)

module Sequel::Database::ResetIdentifierMangling
  class << self
    def extended(obj); end
  end
end

Sequel::Database::SCHEMA_TYPE_CLASSES = T.let(T.unsafe(nil), Hash)
Sequel::Database::SERIALIZATION_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)
Sequel::Database::SQL_BEGIN = T.let(T.unsafe(nil), String)
Sequel::Database::SQL_COMMIT = T.let(T.unsafe(nil), String)
Sequel::Database::SQL_RELEASE_SAVEPOINT = T.let(T.unsafe(nil), String)
Sequel::Database::SQL_ROLLBACK = T.let(T.unsafe(nil), String)
Sequel::Database::SQL_ROLLBACK_TO_SAVEPOINT = T.let(T.unsafe(nil), String)
Sequel::Database::SQL_SAVEPOINT = T.let(T.unsafe(nil), String)
Sequel::Database::STRING_DEFAULT_RE = T.let(T.unsafe(nil), Regexp)
Sequel::Database::TEMPORARY = T.let(T.unsafe(nil), String)
Sequel::Database::TRANSACTION_BEGIN = T.let(T.unsafe(nil), String)
Sequel::Database::TRANSACTION_COMMIT = T.let(T.unsafe(nil), String)
Sequel::Database::TRANSACTION_ISOLATION_LEVELS = T.let(T.unsafe(nil), Hash)
Sequel::Database::TRANSACTION_ROLLBACK = T.let(T.unsafe(nil), String)
Sequel::Database::UNDERSCORE = T.let(T.unsafe(nil), String)
Sequel::Database::UNIQUE = T.let(T.unsafe(nil), String)
Sequel::Database::UNIQUE_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)
Sequel::Database::UNSIGNED = T.let(T.unsafe(nil), String)
class Sequel::DatabaseConnectionError < ::Sequel::DatabaseError; end
class Sequel::DatabaseDisconnectError < ::Sequel::DatabaseError; end
class Sequel::DatabaseError < ::Sequel::Error; end

class Sequel::Dataset
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::BooleanMethods
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::ComplexExpressionMethods
  include ::Sequel::SQL::InequalityMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::OrderMethods
  include ::Enumerable

  def initialize(db); end

  def <<(arg); end
  def ==(o); end
  def [](*conditions); end
  def add_graph_aliases(graph_aliases); end
  def add_graph_aliases!(*args, &block); end
  def aliased_expression_sql_append(sql, ae); end
  def all(&block); end
  def and(*cond, &block); end
  def and!(*args, &block); end
  def array_sql_append(sql, a); end
  def as_hash(key_column, value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def avg(arg = T.unsafe(nil)); end
  def bind(bind_vars = T.unsafe(nil)); end
  def boolean_constant_sql_append(sql, constant); end
  def call(type, bind_variables = T.unsafe(nil), *values, &block); end
  def case_expression_sql_append(sql, ce); end
  def cast_sql_append(sql, expr, type); end
  def clone(opts = T.unsafe(nil)); end
  def column_all_sql_append(sql, ca); end
  def columns; end
  def columns!; end
  def complex_expression_sql_append(sql, op, args); end
  def constant_sql_append(sql, constant); end
  def count(arg = T.unsafe(nil), &block); end
  def cross_join(table, opts = T.unsafe(nil)); end
  def cross_join!(*args, &block); end
  def current_datetime; end
  def db; end
  def delayed_evaluation_sql_append(sql, delay); end
  def delete(&block); end
  def delete_sql; end
  def distinct(*args, &block); end
  def distinct!(*args, &block); end
  def dup; end
  def each; end
  def each_server; end
  def empty?; end
  def eql?(o); end
  def escape_like(string); end
  def except(dataset, opts = T.unsafe(nil)); end
  def except!(*args, &block); end
  def exclude(*cond, &block); end
  def exclude!(*args, &block); end
  def exclude_having(*cond, &block); end
  def exclude_having!(*args, &block); end
  def exclude_where(*cond, &block); end
  def exclude_where!(*args, &block); end
  def exists; end
  def extension(*a); end
  def extension!(*exts); end
  def filter(*cond, &block); end
  def filter!(*args, &block); end
  def first(*args, &block); end
  def first!(*args, &block); end
  def first_source; end
  def first_source_alias; end
  def first_source_table; end
  def for_update; end
  def for_update!(*args, &block); end
  def freeze; end
  def from(*source, &block); end
  def from!(*args, &block); end
  def from_self(opts = T.unsafe(nil)); end
  def from_self!(*args, &block); end
  def full_join(*args, &block); end
  def full_join!(*args, &block); end
  def full_outer_join(*args, &block); end
  def full_outer_join!(*args, &block); end
  def function_sql_append(sql, f); end
  def get(column = T.unsafe(nil), &block); end
  def graph(dataset, join_conditions = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def graph!(*args, &block); end
  def grep(columns, patterns, opts = T.unsafe(nil)); end
  def grep!(*args, &block); end
  def group(*columns, &block); end
  def group!(*args, &block); end
  def group_and_count(*columns, &block); end
  def group_and_count!(*args, &block); end
  def group_append(*columns, &block); end
  def group_append!(*args, &block); end
  def group_by(*columns, &block); end
  def group_by!(*args, &block); end
  def group_cube; end
  def group_rollup; end
  def grouping_sets; end
  def hash; end
  def having(*cond, &block); end
  def having!(*args, &block); end
  def import(columns, values, opts = T.unsafe(nil)); end
  def inner_join(*args, &block); end
  def inner_join!(*args, &block); end
  def insert(*values, &block); end
  def insert_sql(*values); end
  def inspect; end
  def intersect(dataset, opts = T.unsafe(nil)); end
  def intersect!(*args, &block); end
  def interval(column = T.unsafe(nil)); end
  def invert; end
  def invert!(*args, &block); end
  def join(*args, &block); end
  def join!(*args, &block); end
  def join_clause_sql_append(sql, jc); end
  def join_on_clause_sql_append(sql, jc); end
  def join_table(type, table, expr = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def join_table!(*args, &block); end
  def join_using_clause_sql_append(sql, jc); end
  def joined_dataset?; end
  def last(*args, &block); end
  def lateral; end
  def left_join(*args, &block); end
  def left_join!(*args, &block); end
  def left_outer_join(*args, &block); end
  def left_outer_join!(*args, &block); end
  def limit(l, o = T.unsafe(nil)); end
  def limit!(*args, &block); end
  def literal(*args, &block); end
  def literal_append(sql, v); end
  def lock_style(style); end
  def lock_style!(*args, &block); end
  def map(column = T.unsafe(nil), &block); end
  def max(arg = T.unsafe(nil)); end
  def min(arg = T.unsafe(nil)); end
  def multi_insert(hashes, opts = T.unsafe(nil)); end
  def multi_insert_sql(columns, values); end
  def naked; end
  def naked!; end
  def natural_full_join(table, opts = T.unsafe(nil)); end
  def natural_full_join!(*args, &block); end
  def natural_join(table, opts = T.unsafe(nil)); end
  def natural_join!(*args, &block); end
  def natural_left_join(table, opts = T.unsafe(nil)); end
  def natural_left_join!(*args, &block); end
  def natural_right_join(table, opts = T.unsafe(nil)); end
  def natural_right_join!(*args, &block); end
  def negative_boolean_constant_sql_append(sql, constant); end
  def offset(o); end
  def offset!(*args, &block); end
  def opts; end
  def or(*cond, &block); end
  def or!(*args, &block); end
  def order(*columns, &block); end
  def order!(*args, &block); end
  def order_append(*columns, &block); end
  def order_append!(*args, &block); end
  def order_by(*columns, &block); end
  def order_by!(*args, &block); end
  def order_more(*columns, &block); end
  def order_more!(*args, &block); end
  def order_prepend(*columns, &block); end
  def order_prepend!(*args, &block); end
  def ordered_expression_sql_append(sql, oe); end
  def paged_each(opts = T.unsafe(nil)); end
  def placeholder_literal_string_sql_append(sql, pls); end
  def prepare(type, name = T.unsafe(nil), *values); end
  def provides_accurate_rows_matched?; end
  def qualified_identifier_sql_append(sql, table, column = T.unsafe(nil)); end
  def qualify(table = T.unsafe(nil)); end
  def qualify!(*args, &block); end
  def quote_identifier(*args, &block); end
  def quote_identifier_append(sql, name); end
  def quote_identifiers=(v); end
  def quote_identifiers?; end
  def quote_schema_table(*args, &block); end
  def quote_schema_table_append(sql, table); end
  def quoted_identifier_append(sql, name); end
  def range(column = T.unsafe(nil)); end
  def recursive_cte_requires_column_aliases?; end
  def requires_placeholder_type_specifiers?; end
  def requires_sql_standard_datetimes?; end
  def returning(*values); end
  def reverse(*order, &block); end
  def reverse!(*args, &block); end
  def reverse_order(*order, &block); end
  def reverse_order!(*args, &block); end
  def right_join(*args, &block); end
  def right_join!(*args, &block); end
  def right_outer_join(*args, &block); end
  def right_outer_join!(*args, &block); end
  def row_number_column; end
  def row_proc; end
  def row_proc=(v); end
  def schema_and_table(table_name, sch = T.unsafe(nil)); end
  def select(*columns, &block); end
  def select!(*args, &block); end
  def select_all(*tables); end
  def select_all!(*args, &block); end
  def select_append(*columns, &block); end
  def select_append!(*args, &block); end
  def select_group(*columns, &block); end
  def select_group!(*args, &block); end
  def select_hash(key_column, value_column, opts = T.unsafe(nil)); end
  def select_hash_groups(key_column, value_column, opts = T.unsafe(nil)); end
  def select_map(column = T.unsafe(nil), &block); end
  def select_more(*columns, &block); end
  def select_more!(*args, &block); end
  def select_order_map(column = T.unsafe(nil), &block); end
  def select_sql; end
  def server(servr); end
  def server!(*args, &block); end
  def server?(server); end
  def set_graph_aliases(graph_aliases); end
  def set_graph_aliases!(*args, &block); end
  def single_record; end
  def single_record!; end
  def single_value; end
  def single_value!; end
  def skip_limit_check; end
  def skip_locked; end
  def split_alias(c); end
  def split_qualifiers(table_name, *args); end
  def sql; end
  def subscript_sql_append(sql, s); end
  def sum(arg = T.unsafe(nil)); end
  def supports_cte?(type = T.unsafe(nil)); end
  def supports_cte_in_subqueries?; end
  def supports_derived_column_lists?; end
  def supports_distinct_on?; end
  def supports_group_cube?; end
  def supports_group_rollup?; end
  def supports_grouping_sets?; end
  def supports_insert_select?; end
  def supports_intersect_except?; end
  def supports_intersect_except_all?; end
  def supports_is_true?; end
  def supports_join_using?; end
  def supports_lateral_subqueries?; end
  def supports_limits_in_correlated_subqueries?; end
  def supports_modifying_joins?; end
  def supports_multiple_column_in?; end
  def supports_offsets_in_correlated_subqueries?; end
  def supports_ordered_distinct_on?; end
  def supports_regexp?; end
  def supports_replace?; end
  def supports_returning?(type); end
  def supports_select_all_and_column?; end
  def supports_skip_locked?; end
  def supports_timestamp_timezones?; end
  def supports_timestamp_usecs?; end
  def supports_where_true?; end
  def supports_window_functions?; end
  def to_hash(*a); end
  def to_hash_groups(key_column, value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def truncate; end
  def truncate_sql; end
  def unbind; end
  def unfiltered; end
  def unfiltered!(*args, &block); end
  def ungraphed; end
  def ungraphed!(*args, &block); end
  def ungrouped; end
  def ungrouped!(*args, &block); end
  def union(dataset, opts = T.unsafe(nil)); end
  def union!(*args, &block); end
  def unlimited; end
  def unlimited!(*args, &block); end
  def unordered; end
  def unordered!(*args, &block); end
  def unqualified_column_for(v); end
  def unused_table_alias(table_alias, used_aliases = T.unsafe(nil)); end
  def update(values = T.unsafe(nil), &block); end
  def update_sql(values = T.unsafe(nil)); end
  def where(*cond, &block); end
  def where!(*args, &block); end
  def where_all(cond, &block); end
  def where_each(cond, &block); end
  def where_single_value(cond); end
  def window_sql_append(sql, opts); end
  def with(name, dataset, opts = T.unsafe(nil)); end
  def with!(*args, &block); end
  def with_extend(*mods, &block); end
  def with_quote_identifiers(v); end
  def with_recursive(name, nonrecursive, recursive, opts = T.unsafe(nil)); end
  def with_recursive!(*args, &block); end
  def with_row_proc(callable); end
  def with_sql(sql, *args); end
  def with_sql!(*args, &block); end
  def with_sql_all(sql, &block); end
  def with_sql_delete(sql); end
  def with_sql_each(sql); end
  def with_sql_first(sql); end
  def with_sql_insert(sql); end
  def with_sql_single_value(sql); end
  def with_sql_update(sql); end

  protected

  def _columns; end
  def _import(columns, values, opts); end
  def _select_map_multiple(ret_cols); end
  def _select_map_single; end
  def cache; end
  def cache_get(k); end
  def cache_set(k, v); end
  def clear_columns_cache; end
  def compound_clone(type, dataset, opts); end
  def compound_from_self; end
  def options_overlap(opts); end
  def simple_select_all?; end
  def single_value_ds; end
  def to_prepared_statement(type, values = T.unsafe(nil), opts = T.unsafe(nil)); end

  private

  def _aggregate(function, arg); end
  def _all(block); end
  def _clone(*_arg0); end
  def _extension!(exts); end
  def _filter(clause, *cond, &block); end
  def _filter_or_exclude(invert, clause, *cond, &block); end
  def _hash_key_symbol(s, recursing = T.unsafe(nil)); end
  def _insert_sql; end
  def _select_hash(meth, key_column, value_column, opts = T.unsafe(nil)); end
  def _select_map(column, order, &block); end
  def _single_record_ds; end
  def _truncate_sql(table); end
  def _unqualified_column_for(v); end
  def _update_sql; end
  def _where_loader; end
  def add_filter(clause, cond, invert = T.unsafe(nil), combine = T.unsafe(nil), &block); end
  def aggregate_dataset; end
  def alias_alias_symbol(s); end
  def alias_symbol(sym); end
  def allow_preparing_prepared_statements?; end
  def as_sql_append(sql, aliaz, column_aliases = T.unsafe(nil)); end
  def auto_alias_expression(v); end
  def bound_variable_modules; end
  def cache_sql?; end
  def cached_dataset(key); end
  def cached_placeholder_literalizer(key); end
  def check_modification_allowed!; end
  def check_not_limited!(type); end
  def check_truncation_allowed!; end
  def column_list_append(sql, columns); end
  def columns=(v); end
  def complex_expression_arg_pairs(args); end
  def complex_expression_arg_pairs_append(sql, args, &block); end
  def complex_expression_emulate_append(sql, op, args); end
  def compound_dataset_sql_append(sql, ds); end
  def dataset_alias(number); end
  def default_import_slice; end
  def default_join_table_qualification; end
  def default_server; end
  def default_server_opts(opts); end
  def default_timestamp_format; end
  def delete_delete_sql(sql); end
  def delete_from_sql(sql); end
  def delete_order_sql(sql); end
  def delete_returning_sql(sql); end
  def delete_where_sql(sql); end
  def delete_with_sql(sql); end
  def disable_sql_caching!; end
  def empty_array_value(op, cols); end
  def empty_from_sql; end
  def emulate_function?(name); end
  def execute(sql, opts = T.unsafe(nil), &block); end
  def execute_ddl(sql, opts = T.unsafe(nil), &block); end
  def execute_dui(sql, opts = T.unsafe(nil), &block); end
  def execute_insert(sql, opts = T.unsafe(nil), &block); end
  def expression_list_append(sql, columns); end
  def filter_expr(expr = T.unsafe(nil), &block); end
  def format_timestamp(v); end
  def format_timestamp_offset(hour, minute); end
  def format_timestamp_usec(usec, ts = T.unsafe(nil)); end
  def graph_alias_columns(graph_aliases); end
  def grouping_element_list_append(sql, columns); end
  def hash_key_symbol(s); end
  def hash_key_symbols(s); end
  def hoist_cte(ds); end
  def hoist_cte?(ds); end
  def identifier_append(sql, v); end
  def identifier_list_append(sql, args); end
  def ignore_values_preceding(row); end
  def initialize_clone(c); end
  def initialize_copy(c); end
  def input_identifier(v); end
  def insert_columns_sql(sql); end
  def insert_empty_columns_values; end
  def insert_insert_sql(sql); end
  def insert_into_sql(sql); end
  def insert_returning_sql(sql); end
  def insert_supports_empty_values?; end
  def insert_values_sql(sql); end
  def insert_with_sql(sql); end
  def invert_order(order); end
  def join_type_sql(join_type); end
  def literal_array_append(sql, v); end
  def literal_big_decimal(v); end
  def literal_blob_append(sql, v); end
  def literal_dataset_append(sql, v); end
  def literal_date(v); end
  def literal_datetime(v); end
  def literal_datetime_append(sql, v); end
  def literal_expression_append(sql, v); end
  def literal_false; end
  def literal_float(v); end
  def literal_hash_append(sql, v); end
  def literal_integer(v); end
  def literal_nil; end
  def literal_other_append(sql, v); end
  def literal_sqltime(v); end
  def literal_sqltime_append(sql, v); end
  def literal_string_append(sql, v); end
  def literal_symbol_append(sql, v); end
  def literal_time(v); end
  def literal_time_append(sql, v); end
  def literal_true; end
  def multi_insert_sql_strategy; end
  def mutation_method(meth, *args, &block); end
  def native_function_name(emulated_function); end
  def non_sql_option?(key); end
  def non_sql_options; end
  def output_identifier(v); end
  def post_load(all_records); end
  def prepared_arg_placeholder; end
  def prepared_statement_modules; end
  def qualified_column_name(column, table); end
  def qualified_expression(e, table); end
  def qualifier_from_alias_symbol(aliaz, identifier); end
  def raise_if_frozen!(meth = T.unsafe(nil)); end
  def returning_fetch_rows(sql, &block); end
  def select_columns_sql(sql); end
  def select_compounds_sql(sql); end
  def select_distinct_sql(sql); end
  def select_from_sql(sql); end
  def select_group_sql(sql); end
  def select_having_sql(sql); end
  def select_join_sql(sql); end
  def select_limit_sql(sql); end
  def select_lock_sql(sql); end
  def select_only_offset_sql(sql); end
  def select_order_sql(sql); end
  def select_select_sql(sql); end
  def select_where_sql(sql); end
  def select_with_sql(sql); end
  def select_with_sql_base; end
  def skip_symbol_cache!; end
  def skip_symbol_cache?; end
  def source_list_append(sql, sources); end
  def split_symbol(sym); end
  def sql_string_origin; end
  def sqltime_precision; end
  def static_sql(sql); end
  def subselect_sql_append(sql, ds); end
  def supports_quoted_function_names?; end
  def timestamp_precision; end
  def unaliased_identifier(c); end
  def update_order_sql(sql); end
  def update_returning_sql(sql); end
  def update_set_sql(sql); end
  def update_sql_values_hash(sql, values); end
  def update_table_sql(sql); end
  def update_update_sql(sql); end
  def update_where_sql(sql); end
  def update_with_sql(sql); end
  def uses_returning?(type); end
  def uses_with_rollup?; end
  def virtual_row_columns(columns, block); end
  def visible_class_name; end

  class << self
    def clause_methods(type, clauses); end
    def def_deprecated_opts_setter(mod, *meths); end
    def def_mutation_method(*meths); end
    def def_sql_method(mod, type, clauses); end
    def register_extension(ext, mod = T.unsafe(nil), &block); end

    private

    def prepared_statements_module(code, mods, meths = T.unsafe(nil), &block); end
  end
end

Sequel::Dataset::ACTION_METHODS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::ALL = T.let(T.unsafe(nil), String)
Sequel::Dataset::AND_SEPARATOR = T.let(T.unsafe(nil), String)
Sequel::Dataset::APOS = T.let(T.unsafe(nil), String)
Sequel::Dataset::APOS_RE = T.let(T.unsafe(nil), Regexp)
Sequel::Dataset::ARG_BLOCK_ERROR_MSG = T.let(T.unsafe(nil), String)
Sequel::Dataset::ARRAY_ACCESS_ERROR_MSG = T.let(T.unsafe(nil), String)
Sequel::Dataset::ARRAY_EMPTY = T.let(T.unsafe(nil), String)
Sequel::Dataset::AS = T.let(T.unsafe(nil), String)
Sequel::Dataset::ASC = T.let(T.unsafe(nil), String)

module Sequel::Dataset::ArgumentMapper
  def bind_arguments; end
  def bind_arguments=(v); end
  def call(bind_vars = T.unsafe(nil), &block); end
  def prepared_sql; end
  def prepared_statement_name; end
  def prepared_statement_name=(v); end
end

Sequel::Dataset::BACKSLASH = T.let(T.unsafe(nil), String)
Sequel::Dataset::BITCOMP_CLOSE = T.let(T.unsafe(nil), String)
Sequel::Dataset::BITCOMP_OPEN = T.let(T.unsafe(nil), String)
Sequel::Dataset::BITWISE_METHOD_MAP = T.let(T.unsafe(nil), Hash)
Sequel::Dataset::BOOL_FALSE = T.let(T.unsafe(nil), String)
Sequel::Dataset::BOOL_TRUE = T.let(T.unsafe(nil), String)
Sequel::Dataset::BRACKET_CLOSE = T.let(T.unsafe(nil), String)
Sequel::Dataset::BRACKET_OPEN = T.let(T.unsafe(nil), String)
Sequel::Dataset::CASE_ELSE = T.let(T.unsafe(nil), String)
Sequel::Dataset::CASE_END = T.let(T.unsafe(nil), String)
Sequel::Dataset::CASE_OPEN = T.let(T.unsafe(nil), String)
Sequel::Dataset::CASE_THEN = T.let(T.unsafe(nil), String)
Sequel::Dataset::CASE_WHEN = T.let(T.unsafe(nil), String)
Sequel::Dataset::CAST_OPEN = T.let(T.unsafe(nil), String)
Sequel::Dataset::COLON = T.let(T.unsafe(nil), String)
Sequel::Dataset::COLUMNS_CLONE_OPTIONS = T.let(T.unsafe(nil), Hash)
Sequel::Dataset::COLUMN_CHANGE_OPTS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::COLUMN_REF_RE1 = T.let(T.unsafe(nil), Regexp)
Sequel::Dataset::COLUMN_REF_RE2 = T.let(T.unsafe(nil), Regexp)
Sequel::Dataset::COLUMN_REF_RE3 = T.let(T.unsafe(nil), Regexp)
Sequel::Dataset::COMMA = T.let(T.unsafe(nil), String)
Sequel::Dataset::COMMA_SEPARATOR = T.let(T.unsafe(nil), String)
Sequel::Dataset::CONDITIONED_JOIN_TYPES = T.let(T.unsafe(nil), Array)
Sequel::Dataset::CONDITION_FALSE = T.let(T.unsafe(nil), String)
Sequel::Dataset::CONDITION_TRUE = T.let(T.unsafe(nil), String)
Sequel::Dataset::COUNT_FROM_SELF_OPTS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::COUNT_OF_ALL_AS_COUNT = T.let(T.unsafe(nil), Sequel::SQL::AliasedExpression)
Sequel::Dataset::DATASET_ALIAS_BASE_NAME = T.let(T.unsafe(nil), String)
Sequel::Dataset::DATETIME_SECFRACTION_ARG = T.let(T.unsafe(nil), Integer)
Sequel::Dataset::DEFAULT = T.let(T.unsafe(nil), Sequel::LiteralString)
Sequel::Dataset::DEFAULT_PREPARED_STATEMENT_MODULE_METHODS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::DEFAULT_VALUES = T.let(T.unsafe(nil), String)
Sequel::Dataset::DELETE = T.let(T.unsafe(nil), String)
Sequel::Dataset::DESC = T.let(T.unsafe(nil), String)
Sequel::Dataset::DISTINCT = T.let(T.unsafe(nil), String)
Sequel::Dataset::DOT = T.let(T.unsafe(nil), String)
Sequel::Dataset::DOUBLE_APOS = T.let(T.unsafe(nil), String)
Sequel::Dataset::DOUBLE_QUOTE = T.let(T.unsafe(nil), String)

class Sequel::Dataset::DatasetModule < ::Module
  def distinct(name, *args, &block); end
  def exclude(name, *args, &block); end
  def exclude_having(name, *args, &block); end
  def grep(name, *args, &block); end
  def group(name, *args, &block); end
  def group_and_count(name, *args, &block); end
  def group_append(name, *args, &block); end
  def having(name, *args, &block); end
  def limit(name, *args, &block); end
  def offset(name, *args, &block); end
  def order(name, *args, &block); end
  def order_append(name, *args, &block); end
  def order_prepend(name, *args, &block); end
  def select(name, *args, &block); end
  def select_all(name, *args, &block); end
  def select_append(name, *args, &block); end
  def select_group(name, *args, &block); end
  def server(name, *args, &block); end
  def where(name, *args, &block); end

  class << self
    def def_dataset_caching_method(mod, meth); end
  end
end

Sequel::Dataset::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Sequel::Dataset::EMPTY_PARENS = T.let(T.unsafe(nil), String)
Sequel::Dataset::EMULATED_FUNCTION_MAP = T.let(T.unsafe(nil), Hash)
Sequel::Dataset::EQUAL = T.let(T.unsafe(nil), String)
Sequel::Dataset::ESCAPE = T.let(T.unsafe(nil), String)
Sequel::Dataset::EXISTS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::EXTENSIONS = T.let(T.unsafe(nil), Hash)
Sequel::Dataset::EXTRACT = T.let(T.unsafe(nil), String)
Sequel::Dataset::FILTER = T.let(T.unsafe(nil), String)
Sequel::Dataset::FORMAT_DATE = T.let(T.unsafe(nil), String)
Sequel::Dataset::FORMAT_DATE_STANDARD = T.let(T.unsafe(nil), String)
Sequel::Dataset::FORMAT_OFFSET = T.let(T.unsafe(nil), String)
Sequel::Dataset::FORMAT_TIMESTAMP_RE = T.let(T.unsafe(nil), Regexp)
Sequel::Dataset::FORMAT_USEC = T.let(T.unsafe(nil), String)
Sequel::Dataset::FOR_UPDATE = T.let(T.unsafe(nil), String)
Sequel::Dataset::FRAME_ALL = T.let(T.unsafe(nil), String)
Sequel::Dataset::FRAME_ROWS = T.let(T.unsafe(nil), String)
Sequel::Dataset::FROM = T.let(T.unsafe(nil), String)
Sequel::Dataset::FUNCTION_DISTINCT = T.let(T.unsafe(nil), String)
Sequel::Dataset::GROUP_BY = T.let(T.unsafe(nil), String)
Sequel::Dataset::HAVING = T.let(T.unsafe(nil), String)
Sequel::Dataset::IMPORT_ERROR_MSG = T.let(T.unsafe(nil), String)
Sequel::Dataset::INSERT = T.let(T.unsafe(nil), String)
Sequel::Dataset::INTO = T.let(T.unsafe(nil), String)
Sequel::Dataset::IS_LITERALS = T.let(T.unsafe(nil), Hash)
Sequel::Dataset::IS_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::JOIN_METHODS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::LATERAL = T.let(T.unsafe(nil), String)
Sequel::Dataset::LIKE_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::LIMIT = T.let(T.unsafe(nil), String)
Sequel::Dataset::MUTATION_METHODS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::NON_SQL_OPTIONS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::NOTIMPL_MSG = T.let(T.unsafe(nil), String)
Sequel::Dataset::NOT_SPACE = T.let(T.unsafe(nil), String)
Sequel::Dataset::NULL = T.let(T.unsafe(nil), String)
Sequel::Dataset::NULLS_FIRST = T.let(T.unsafe(nil), String)
Sequel::Dataset::NULLS_LAST = T.let(T.unsafe(nil), String)
Sequel::Dataset::N_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::OFFSET = T.let(T.unsafe(nil), String)
Sequel::Dataset::ON = T.let(T.unsafe(nil), String)
Sequel::Dataset::ON_PAREN = T.let(T.unsafe(nil), String)
Sequel::Dataset::OPTS = T.let(T.unsafe(nil), Hash)
Sequel::Dataset::ORDER_BY = T.let(T.unsafe(nil), String)
Sequel::Dataset::ORDER_BY_NS = T.let(T.unsafe(nil), String)
Sequel::Dataset::OVER = T.let(T.unsafe(nil), String)
Sequel::Dataset::PAREN_CLOSE = T.let(T.unsafe(nil), String)
Sequel::Dataset::PAREN_OPEN = T.let(T.unsafe(nil), String)
Sequel::Dataset::PAREN_SPACE_OPEN = T.let(T.unsafe(nil), String)
Sequel::Dataset::PARTITION_BY = T.let(T.unsafe(nil), String)
Sequel::Dataset::PREPARED_ARG_PLACEHOLDER = T.let(T.unsafe(nil), Sequel::LiteralString)
Sequel::Dataset::PREPARED_STATEMENT_MODULE_CODE = T.let(T.unsafe(nil), Hash)

class Sequel::Dataset::PlaceholderLiteralizer
  def initialize(dataset, fragments, final_sql, arity); end

  def all(*args, &block); end
  def each(*args, &block); end
  def first(*args); end
  def freeze; end
  def get(*args); end
  def sql(*args); end
  def with_dataset; end

  class << self
    def loader(dataset, &block); end
  end
end

class Sequel::Dataset::PlaceholderLiteralizer::Argument
  def initialize(recorder, pos, transformer = T.unsafe(nil)); end

  def sql_literal_append(ds, sql); end
  def transform(&block); end
end

class Sequel::Dataset::PlaceholderLiteralizer::Recorder
  def arg(v = T.unsafe(nil)); end
  def loader(dataset); end
  def use(sql, arg, transformer); end
end

module Sequel::Dataset::PreparedStatementMethods
  def call(bind_vars = T.unsafe(nil), &block); end
  def columns; end
  def inspect; end
  def literal_symbol_append(sql, v); end
  def log_sql; end
  def log_sql=(v); end
  def orig_dataset; end
  def orig_dataset=(v); end
  def prepare(*_arg0); end
  def prepared_args; end
  def prepared_args=(v); end
  def prepared_modify_values; end
  def prepared_modify_values=(v); end
  def prepared_sql; end
  def prepared_type; end
  def prepared_type=(v); end

  protected

  def run(&block); end

  private

  def prepared_arg(k); end
  def prepared_arg?(k); end
  def skip_symbol_cache?; end
  def subselect_sql_append(sql, ds); end
end

Sequel::Dataset::PreparedStatementMethods::PLACEHOLDER_RE = T.let(T.unsafe(nil), Regexp)
Sequel::Dataset::QUALIFY_KEYS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::QUERY_METHODS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::QUESTION_MARK = T.let(T.unsafe(nil), String)
Sequel::Dataset::QUESTION_MARK_RE = T.let(T.unsafe(nil), Regexp)
Sequel::Dataset::QUOTE = T.let(T.unsafe(nil), String)
Sequel::Dataset::QUOTE_RE = T.let(T.unsafe(nil), Regexp)
Sequel::Dataset::REGEXP_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::RETURNING = T.let(T.unsafe(nil), String)
Sequel::Dataset::SELECT = T.let(T.unsafe(nil), String)
Sequel::Dataset::SET = T.let(T.unsafe(nil), String)
Sequel::Dataset::SIMPLE_SELECT_ALL_ALLOWED_FROM = T.let(T.unsafe(nil), Array)
Sequel::Dataset::SPACE = T.let(T.unsafe(nil), String)
Sequel::Dataset::SPACE_WITH = T.let(T.unsafe(nil), String)
Sequel::Dataset::SQL_WITH = T.let(T.unsafe(nil), String)
Sequel::Dataset::STANDARD_TIMESTAMP_FORMAT = T.let(T.unsafe(nil), String)
Sequel::Dataset::TILDE = T.let(T.unsafe(nil), String)
Sequel::Dataset::TIMESTAMP_FORMAT = T.let(T.unsafe(nil), String)
Sequel::Dataset::TRUE_FREEZE = T.let(T.unsafe(nil), TrueClass)
Sequel::Dataset::TWO_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::Dataset::UNCONDITIONED_JOIN_TYPES = T.let(T.unsafe(nil), Array)
Sequel::Dataset::UNDERSCORE = T.let(T.unsafe(nil), String)
Sequel::Dataset::UNION_ALL_SELECT = T.let(T.unsafe(nil), String)
Sequel::Dataset::UPDATE = T.let(T.unsafe(nil), String)
Sequel::Dataset::USING = T.let(T.unsafe(nil), String)

module Sequel::Dataset::UnnumberedArgumentMapper
  include ::Sequel::Dataset::ArgumentMapper

  protected

  def map_to_prepared_args(bind_vars); end

  private

  def prepared_arg(k); end
  def prepared_arg?(k); end
end

Sequel::Dataset::VALUES = T.let(T.unsafe(nil), String)
Sequel::Dataset::WHERE = T.let(T.unsafe(nil), String)
Sequel::Dataset::WILDCARD = T.let(T.unsafe(nil), Sequel::LiteralString)
Sequel::Dataset::WITHIN_GROUP = T.let(T.unsafe(nil), String)
Sequel::Dataset::WITH_ORDINALITY = T.let(T.unsafe(nil), String)

module Sequel::Deprecation
  class << self
    def backtrace_filter; end
    def backtrace_filter=(_arg0); end
    def deprecate(method, instead = T.unsafe(nil)); end
    def deprecate_constant(mod, constant); end
    def output; end
    def output=(_arg0); end
    def prefix; end
    def prefix=(_arg0); end
  end
end

class Sequel::Error < ::StandardError
  def cause; end
  def wrapped_exception; end
  def wrapped_exception=(_arg0); end
end

Sequel::Error::AdapterNotFound = Sequel::AdapterNotFound
Sequel::Error::InvalidOperation = Sequel::InvalidOperation
Sequel::Error::InvalidValue = Sequel::InvalidValue
Sequel::Error::PoolTimeoutError = Sequel::PoolTimeout
Sequel::Error::Rollback = Sequel::Rollback
class Sequel::ForeignKeyConstraintViolation < ::Sequel::ConstraintViolation; end

class Sequel::HookFailed < ::Sequel::Error
  def initialize(message = T.unsafe(nil), model = T.unsafe(nil)); end

  def model; end
end

module Sequel::Inflections
  private

  def camelize(s); end
  def constantize(s); end
  def demodulize(s); end
  def pluralize(s); end
  def singularize(s); end
  def underscore(s); end

  class << self
    def clear(scope = T.unsafe(nil)); end
    def irregular(singular, plural); end
    def plural(rule, replacement); end
    def plurals; end
    def singular(rule, replacement); end
    def singulars; end
    def uncountable(*words); end
    def uncountables; end
  end
end

Sequel::Inflections::CAMELIZE_CONVERT_REGEXP = T.let(T.unsafe(nil), Regexp)
Sequel::Inflections::CAMELIZE_MODULE_REGEXP = T.let(T.unsafe(nil), Regexp)
Sequel::Inflections::DASH = T.let(T.unsafe(nil), String)
Sequel::Inflections::DEMODULIZE_CONVERT_REGEXP = T.let(T.unsafe(nil), Regexp)
Sequel::Inflections::EMPTY_STRING = T.let(T.unsafe(nil), String)
Sequel::Inflections::SLASH = T.let(T.unsafe(nil), String)
Sequel::Inflections::UNDERSCORE = T.let(T.unsafe(nil), String)
Sequel::Inflections::UNDERSCORE_CONVERT_REGEXP1 = T.let(T.unsafe(nil), Regexp)
Sequel::Inflections::UNDERSCORE_CONVERT_REGEXP2 = T.let(T.unsafe(nil), Regexp)
Sequel::Inflections::UNDERSCORE_CONVERT_REPLACE = T.let(T.unsafe(nil), String)
Sequel::Inflections::UNDERSCORE_MODULE_REGEXP = T.let(T.unsafe(nil), Regexp)
Sequel::Inflections::VALID_CONSTANT_NAME_REGEXP = T.let(T.unsafe(nil), Regexp)

class Sequel::IntegerMigrator < ::Sequel::Migrator
  def initialize(db, directory, opts = T.unsafe(nil)); end

  def current; end
  def direction; end
  def is_current?; end
  def migrations; end
  def run; end

  private

  def current_migration_version; end
  def default_schema_column; end
  def default_schema_table; end
  def get_migration_files; end
  def get_migrations; end
  def latest_migration_version; end
  def schema_dataset; end
  def set_migration_version(version); end
  def up?; end
  def version_numbers; end
end

Sequel::IntegerMigrator::DEFAULT_SCHEMA_COLUMN = T.let(T.unsafe(nil), Symbol)
Sequel::IntegerMigrator::DEFAULT_SCHEMA_TABLE = T.let(T.unsafe(nil), Symbol)
Sequel::IntegerMigrator::Error = Sequel::Migrator::Error
class Sequel::InvalidOperation < ::Sequel::Error; end
class Sequel::InvalidValue < ::Sequel::Error; end

class Sequel::LiteralString < ::String
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::ComplexExpressionMethods
  include ::Sequel::SQL::BooleanMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::InequalityMethods
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::OrderMethods

  def inspect; end
  def lit(*args); end
  def to_sequel_blob; end
end

Sequel::MAJOR = T.let(T.unsafe(nil), Integer)
Sequel::MINOR = T.let(T.unsafe(nil), Integer)
class Sequel::MassAssignmentRestriction < ::Sequel::Error; end

class Sequel::Migration
  def initialize(db); end

  def down; end
  def method_missing(method_sym, *args, &block); end
  def up; end

  private

  def respond_to_missing?(meth, include_private); end

  class << self
    def apply(db, direction); end
    def descendants; end
    def inherited(base); end
    def use_transactions; end
  end
end

class Sequel::MigrationAlterTableReverser < ::Sequel::BasicObject
  def initialize; end

  def reverse(&block); end

  private

  def add_column(*args); end
  def add_constraint(*args); end
  def add_foreign_key(key, table, *args); end
  def add_full_text_index(*args); end
  def add_index(*args); end
  def add_primary_key(*args); end
  def add_spatial_index(*args); end
  def rename_column(name, new_name); end
end

class Sequel::MigrationDSL < ::Sequel::BasicObject
  def initialize(&block); end

  def change(&block); end
  def down(&block); end
  def migration; end
  def no_transaction; end
  def transaction; end
  def up(&block); end

  class << self
    def create(&block); end
  end
end

class Sequel::MigrationReverser < ::Sequel::BasicObject
  def initialize; end

  def reverse(&block); end

  private

  def add_column(*args); end
  def add_index(*args); end
  def alter_table(table, &block); end
  def create_join_table(*args); end
  def create_table(name, opts = T.unsafe(nil)); end
  def create_view(name, _, opts = T.unsafe(nil)); end
  def rename_column(table, name, new_name); end
  def rename_table(table, new_name); end
end

class Sequel::Migrator
  def initialize(db, directory, opts = T.unsafe(nil)); end

  def column; end
  def db; end
  def directory; end
  def ds; end
  def files; end
  def table; end
  def target; end

  private

  def checked_transaction(migration, &block); end
  def load_migration_file(file); end
  def migration_version_from_file(filename); end
  def remove_migration_classes; end

  class << self
    def apply(db, directory, target = T.unsafe(nil), current = T.unsafe(nil)); end
    def check_current(*args); end
    def is_current?(db, directory, opts = T.unsafe(nil)); end
    def migrator_class(directory); end
    def run(db, directory, opts = T.unsafe(nil)); end
  end
end

class Sequel::Migrator::Error < ::Sequel::Error; end
Sequel::Migrator::MIGRATION_FILE_PATTERN = T.let(T.unsafe(nil), Regexp)
Sequel::Migrator::MIGRATION_SPLITTER = T.let(T.unsafe(nil), String)
Sequel::Migrator::MINIMUM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
class Sequel::Migrator::NotCurrentError < ::Sequel::Migrator::Error; end

class Sequel::Model
  include ::Sequel::Model::InstanceMethods
  include ::Sequel::Model::Associations::InstanceMethods
  extend ::Enumerable
  extend ::Sequel::Inflections
  extend ::Sequel::Model::ClassMethods
  extend ::Sequel::Model::Associations::ClassMethods
end

Sequel::Model::AFTER_HOOKS = T.let(T.unsafe(nil), Array)
Sequel::Model::ANONYMOUS_MODEL_CLASSES = T.let(T.unsafe(nil), Hash)
Sequel::Model::ANONYMOUS_MODEL_CLASSES_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
Sequel::Model::AROUND_HOOKS = T.let(T.unsafe(nil), Array)

module Sequel::Model::Associations
  class << self
    def apply(model); end
  end
end

Sequel::Model::Associations::ASSOCIATION_TYPES = T.let(T.unsafe(nil), Hash)

module Sequel::Model::Associations::AssociationDatasetMethods
  def association_reflection; end
  def association_reflection=(v); end
  def model_object; end
  def model_object=(v); end

  private

  def non_sql_option?(key); end
end

class Sequel::Model::Associations::AssociationReflection < ::Hash
  include ::Sequel::Inflections

  def _add_method; end
  def _remove_all_method; end
  def _remove_method; end
  def _setter_method; end
  def add_method; end
  def apply_dataset_changes(ds); end
  def apply_distinct_on_eager_limit_strategy(ds); end
  def apply_eager_dataset_changes(ds); end
  def apply_eager_graph_limit_strategy(strategy, ds); end
  def apply_eager_limit_strategy(ds, strategy = T.unsafe(nil), limit_and_offset = T.unsafe(nil)); end
  def apply_ruby_eager_limit_strategy(rows, limit_and_offset = T.unsafe(nil)); end
  def apply_window_function_eager_limit_strategy(ds, limit_and_offset = T.unsafe(nil)); end
  def assign_singular?; end
  def associated_class; end
  def associated_dataset; end
  def association_dataset_for(object); end
  def association_dataset_proc; end
  def association_method; end
  def can_have_associated_objects?(obj); end
  def cloneable?(ref); end
  def dataset_method; end
  def dataset_need_primary_key?; end
  def delete_row_number_column(ds = T.unsafe(nil)); end
  def eager_graph_lazy_dataset?; end
  def eager_graph_limit_strategy(strategy); end
  def eager_limit_strategy; end
  def eager_load_results(eo, &block); end
  def eager_loader_key; end
  def eager_loading_predicate_key; end
  def eager_loading_use_associated_key?; end
  def filter_by_associations_add_conditions?; end
  def filter_by_associations_conditions_expression(obj); end
  def finalize; end
  def finalize_settings; end
  def handle_silent_modification_failure?; end
  def initialize_association_cache(objects); end
  def inspect; end
  def limit_and_offset; end
  def need_associated_primary_key?; end
  def placeholder_loader; end
  def predicate_key_values(object); end
  def predicate_keys; end
  def qualify(table, col); end
  def qualify_assoc(col); end
  def qualify_cur(col); end
  def reciprocal; end
  def reciprocal_array?; end
  def remove_all_method; end
  def remove_before_destroy?; end
  def remove_method; end
  def remove_should_check_existing?; end
  def returns_array?; end
  def select; end
  def set_reciprocal_to_self?; end
  def setter_method; end
  def slice_range(limit_and_offset = T.unsafe(nil)); end

  private

  def _associated_dataset; end
  def ambiguous_reciprocal_type?; end
  def apply_filter_by_associations_distinct_on_limit_strategy(ds); end
  def apply_filter_by_associations_limit_strategy(ds); end
  def apply_filter_by_associations_window_function_limit_strategy(ds); end
  def associated_eager_dataset; end
  def cached_fetch(key); end
  def cached_set(key, value); end
  def default_eager_limit_strategy; end
  def eager_loading_dataset(eo = T.unsafe(nil)); end
  def eager_loading_predicate_condition(keys); end
  def filter_by_associations_add_conditions_dataset_filter(ds); end
  def filter_by_associations_conditions_dataset; end
  def filter_by_associations_conditions_subquery_conditions(obj); end
  def filter_by_associations_limit_strategy; end
  def limit_to_single_row?; end
  def offset; end
  def placeholder_eager_loader; end
  def possible_reciprocal_types; end
  def reciprocal_association?(assoc_reflect); end
  def subqueries_per_union; end
  def transform(s); end
  def true_eager_graph_limit_strategy; end
  def true_eager_limit_strategy; end
  def union_eager_loader; end
  def use_placeholder_loader?; end
end

Sequel::Model::Associations::AssociationReflection::ASSOCIATION_DATASET_PROC = T.let(T.unsafe(nil), Proc)
Sequel::Model::Associations::AssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

module Sequel::Model::Associations::ClassMethods
  def all_association_reflections; end
  def associate(type, name, opts = T.unsafe(nil), &block); end
  def association_full_join(*args, &block); end
  def association_inner_join(*args, &block); end
  def association_join(*args, &block); end
  def association_left_join(*args, &block); end
  def association_reflection(name); end
  def association_reflections; end
  def association_right_join(*args, &block); end
  def associations; end
  def autoreloading_associations; end
  def cache_associations; end
  def cache_associations=(_arg0); end
  def default_association_options; end
  def default_association_options=(_arg0); end
  def default_association_type_options; end
  def default_association_type_options=(_arg0); end
  def default_eager_limit_strategy; end
  def default_eager_limit_strategy=(_arg0); end
  def eager(*args, &block); end
  def eager_graph(*args, &block); end
  def eager_graph_with_options(*args, &block); end
  def eager_load_results(opts, eo, &block); end
  def finalize_associations; end
  def freeze; end
  def inherited_instance_variables; end
  def many_to_many(name, opts = T.unsafe(nil), &block); end
  def many_to_one(name, opts = T.unsafe(nil), &block); end
  def one_through_one(name, opts = T.unsafe(nil), &block); end
  def one_to_many(name, opts = T.unsafe(nil), &block); end
  def one_to_one(name, opts = T.unsafe(nil), &block); end

  private

  def association_module(opts = T.unsafe(nil)); end
  def association_module_def(name, opts = T.unsafe(nil), &block); end
  def association_module_private_def(name, opts = T.unsafe(nil), &block); end
  def def_association_instance_methods(opts); end
  def def_association_method(opts); end
  def def_many_to_many(opts); end
  def def_many_to_one(opts); end
  def def_one_through_one(opts); end
  def def_one_to_many(opts); end
  def def_one_to_one(opts); end
  def eager_graph_dataset(opts, eager_options); end
  def reload_db_schema?; end
end

module Sequel::Model::Associations::DatasetMethods
  def as_hash(key_column = T.unsafe(nil), value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def association_full_join(*associations); end
  def association_inner_join(*associations); end
  def association_join(*associations); end
  def association_left_join(*associations); end
  def association_right_join(*associations); end
  def complex_expression_sql_append(sql, op, args); end
  def eager(*associations); end
  def eager!(*args, &block); end
  def eager_graph(*associations); end
  def eager_graph!(*args, &block); end
  def eager_graph_with_options(associations, opts = T.unsafe(nil)); end
  def to_hash_groups(key_column, value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def ungraphed; end

  protected

  def eager_graph_association(ds, model, ta, requirements, r, *associations); end
  def eager_graph_associations(ds, model, ta, requirements, *associations); end
  def eager_graph_build_associations(hashes); end

  private

  def _association_join(type, associations); end
  def add_association_filter_conditions(ref, obj, expr); end
  def association_filter_expression(op, ref, obj); end
  def association_filter_handle_inversion(op, exp, cols); end
  def association_filter_key_expression(keys, meths, obj); end
  def check_association(model, association); end
  def eager_graph_check_association(model, association); end
  def eager_load(a, eager_assoc = T.unsafe(nil)); end
  def eager_options_for_associations(associations); end
  def many_to_many_association_filter_expression(op, ref, obj); end
  def many_to_one_association_filter_expression(op, ref, obj); end
  def non_sql_option?(key); end
  def one_through_one_association_filter_expression(op, ref, obj); end
  def one_to_many_association_filter_expression(op, ref, obj); end
  def one_to_one_association_filter_expression(op, ref, obj); end
  def post_load(all_records); end
end

class Sequel::Model::Associations::DatasetModule < ::Sequel::Model::DatasetModule
  def eager(name, *args, &block); end
end

class Sequel::Model::Associations::EagerGraphLoader
  def initialize(dataset); end

  def after_load_map; end
  def alias_map; end
  def column_maps; end
  def dependency_map; end
  def limit_map; end
  def load(hashes); end
  def master; end
  def primary_keys; end
  def reciprocal_map; end
  def records_map; end
  def reflection_map; end
  def row_procs; end
  def type_map; end

  private

  def _load(dependency_map, current, h); end
  def hfor(ta, h); end
  def hkey(h); end
  def master_hfor(h); end
  def master_pk(h); end
  def pk(ta, h); end
  def post_process(records, dependency_map); end
end

module Sequel::Model::Associations::InstanceMethods
  def associations; end
  def freeze; end

  private

  def _apply_association_options(opts, ds); end
  def _associated_dataset(opts, dynamic_opts); end
  def _associated_object_loader(opts, dynamic_opts); end
  def _dataset(opts); end
  def _join_table_dataset(opts); end
  def _load_associated_object(opts, dynamic_opts); end
  def _load_associated_object_array(opts, dynamic_opts); end
  def _load_associated_object_via_primary_key(opts); end
  def _load_associated_objects(opts, dynamic_opts = T.unsafe(nil)); end
  def _refresh_set_values(hash); end
  def _set_associated_object(opts, o); end
  def add_associated_object(opts, o, *args); end
  def add_reciprocal_object(opts, o); end
  def array_uniq!(a); end
  def change_column_value(column, value); end
  def ensure_associated_primary_key(opts, o, *args); end
  def initialize_copy(other); end
  def load_associated_objects(opts, dynamic_opts = T.unsafe(nil), &block); end
  def load_association_objects_options(dynamic_opts, &block); end
  def load_with_primary_key_lookup?(opts, dynamic_opts); end
  def make_add_associated_object(opts, o); end
  def remove_all_associated_objects(opts, *args); end
  def remove_associated_object(opts, o, *args); end
  def remove_check_existing_object_from_pk(opts, o, *args); end
  def remove_reciprocal_object(opts, o); end
  def run_association_callbacks(reflection, callback_type, object); end
  def set_associated_object(opts, o); end
  def set_associated_object_if_same?; end
  def set_one_through_one_associated_object(opts, o); end
  def set_one_to_one_associated_object(opts, o); end
end

class Sequel::Model::Associations::ManyToManyAssociationReflection < ::Sequel::Model::Associations::AssociationReflection
  def associated_key_alias; end
  def associated_key_array; end
  def associated_key_column; end
  def associated_key_table; end
  def associated_object_keys; end
  def can_have_associated_objects?(obj); end
  def cloneable?(ref); end
  def default_associated_key_alias; end
  def default_eager_loader(eo); end
  def default_join_table; end
  def default_left_key; end
  def default_right_key; end
  def eager_loading_use_associated_key?; end
  def finalize_settings; end
  def join_table_alias; end
  def join_table_source; end
  def need_associated_primary_key?; end
  def predicate_key; end
  def qualified_left_key; end
  def qualified_right_key; end
  def qualified_right_primary_key; end
  def right_primary_key; end
  def right_primary_key_method; end
  def right_primary_key_methods; end
  def right_primary_keys; end
  def select; end

  private

  def _associated_dataset; end
  def default_select; end
  def filter_by_associations_conditions_associated_keys; end
  def filter_by_associations_conditions_key; end
  def filter_by_associations_limit_alias_key; end
  def filter_by_associations_limit_aliases; end
  def filter_by_associations_limit_key; end
  def predicate_key_methods; end
  def reciprocal_association?(assoc_reflect); end
  def reciprocal_type; end
  def selection_is_qualified?(c); end
  def split_join_table_alias; end
end

Sequel::Model::Associations::ManyToManyAssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

class Sequel::Model::Associations::ManyToOneAssociationReflection < ::Sequel::Model::Associations::AssociationReflection
  def associated_object_keys; end
  def can_have_associated_objects?(obj); end
  def dataset_need_primary_key?; end
  def default_key; end
  def eager_graph_lazy_dataset?; end
  def eager_graph_limit_strategy(_); end
  def eager_limit_strategy; end
  def filter_by_associations_limit_strategy; end
  def finalize_settings; end
  def predicate_key; end
  def primary_key; end
  def primary_key_method; end
  def primary_key_methods; end
  def primary_keys; end
  def qualified_primary_key; end
  def reciprocal_array?; end
  def returns_array?; end
  def set_reciprocal_to_self?; end

  private

  def ambiguous_reciprocal_type?; end
  def filter_by_associations_conditions_associated_keys; end
  def filter_by_associations_conditions_key; end
  def limit_to_single_row?; end
  def possible_reciprocal_types; end
  def predicate_key_methods; end
  def reciprocal_association?(assoc_reflect); end
  def reciprocal_type; end
end

Sequel::Model::Associations::ManyToOneAssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

class Sequel::Model::Associations::OneThroughOneAssociationReflection < ::Sequel::Model::Associations::ManyToManyAssociationReflection
  include ::Sequel::Model::Associations::SingularAssociationReflection

  def default_right_key; end
  def reciprocal; end
end

class Sequel::Model::Associations::OneToManyAssociationReflection < ::Sequel::Model::Associations::AssociationReflection
  def apply_eager_graph_limit_strategy(strategy, ds); end
  def associated_object_keys; end
  def can_have_associated_objects?(obj); end
  def cloneable?(ref); end
  def default_key; end
  def finalize_settings; end
  def handle_silent_modification_failure?; end
  def predicate_key; end
  def primary_key; end
  def qualified_key; end
  def qualified_primary_key; end
  def reciprocal_array?; end
  def remove_before_destroy?; end
  def remove_should_check_existing?; end
  def set_reciprocal_to_self?; end

  private

  def apply_correlated_subquery_limit_strategy(ds); end
  def apply_filter_by_associations_limit_strategy(ds); end
  def filter_by_associations_conditions_associated_keys; end
  def filter_by_associations_conditions_key; end
  def filter_by_associations_limit_alias_key; end
  def filter_by_associations_limit_aliases; end
  def filter_by_associations_limit_key; end
  def predicate_key_methods; end
  def reciprocal_association?(assoc_reflect); end
  def reciprocal_type; end
  def true_eager_graph_limit_strategy; end
end

Sequel::Model::Associations::OneToManyAssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

class Sequel::Model::Associations::OneToOneAssociationReflection < ::Sequel::Model::Associations::OneToManyAssociationReflection
  include ::Sequel::Model::Associations::SingularAssociationReflection
end

module Sequel::Model::Associations::SingularAssociationReflection
  def assign_singular?; end
  def filter_by_associations_add_conditions?; end
  def limit_and_offset; end
  def returns_array?; end

  private

  def default_eager_limit_strategy; end
  def filter_by_associations_limit_strategy; end
  def true_eager_graph_limit_strategy; end
end

Sequel::Model::BEFORE_HOOKS = T.let(T.unsafe(nil), Array)
Sequel::Model::BOOLEAN_SETTINGS = T.let(T.unsafe(nil), Array)

module Sequel::Model::ClassMethods
  def <<(arg); end
  def Model(source); end
  def [](*args); end
  def all(*args, &block); end
  def allowed_columns; end
  def as_hash(*args, &block); end
  def avg(*args, &block); end
  def cache_anonymous_models; end
  def cache_anonymous_models=(_arg0); end
  def call(values); end
  def clear_setter_methods_cache; end
  def columns; end
  def count(*args, &block); end
  def create(values = T.unsafe(nil), &block); end
  def cross_join(*args, &block); end
  def dataset; end
  def dataset=(ds); end
  def dataset_method_modules; end
  def dataset_module(mod = T.unsafe(nil)); end
  def dataset_module_class; end
  def db; end
  def db=(db); end
  def db_schema; end
  def def_Model(mod); end
  def def_column_alias(meth, column); end
  def def_dataset_method(*args, &block); end
  def default_set_fields_options; end
  def default_set_fields_options=(_arg0); end
  def distinct(*args, &block); end
  def dup; end
  def each(*args, &block); end
  def each_server(*args, &block); end
  def empty?(*args, &block); end
  def except(*args, &block); end
  def exclude(*args, &block); end
  def exclude_having(*args, &block); end
  def exclude_where(*args, &block); end
  def fast_instance_delete_sql; end
  def fast_pk_lookup_sql; end
  def fetch(*args, &block); end
  def fetch_rows(*args, &block); end
  def filter(*args, &block); end
  def find(*args, &block); end
  def find_or_create(cond, &block); end
  def finder(meth = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def first(*args, &block); end
  def first!(*args, &block); end
  def first_where(cond); end
  def for_update(*args, &block); end
  def freeze; end
  def from(*args, &block); end
  def from_self(*args, &block); end
  def full_join(*args, &block); end
  def full_outer_join(*args, &block); end
  def get(*args, &block); end
  def graph(*args, &block); end
  def grep(*args, &block); end
  def group(*args, &block); end
  def group_and_count(*args, &block); end
  def group_append(*args, &block); end
  def group_by(*args, &block); end
  def having(*args, &block); end
  def implicit_table_name; end
  def import(*args, &block); end
  def include(*mods); end
  def inherited(subclass); end
  def inner_join(*args, &block); end
  def insert(*args, &block); end
  def instance_dataset; end
  def intersect(*args, &block); end
  def interval(*args, &block); end
  def invert(*args, &block); end
  def join(*args, &block); end
  def join_table(*args, &block); end
  def last(*args, &block); end
  def left_join(*args, &block); end
  def left_outer_join(*args, &block); end
  def limit(*args, &block); end
  def load(values); end
  def lock_style(*args, &block); end
  def map(*args, &block); end
  def max(*args, &block); end
  def method_added(meth); end
  def min(*args, &block); end
  def multi_insert(*args, &block); end
  def naked(*args, &block); end
  def natural_full_join(*args, &block); end
  def natural_join(*args, &block); end
  def natural_left_join(*args, &block); end
  def natural_right_join(*args, &block); end
  def no_primary_key; end
  def offset(*args, &block); end
  def order(*args, &block); end
  def order_append(*args, &block); end
  def order_by(*args, &block); end
  def order_more(*args, &block); end
  def order_prepend(*args, &block); end
  def paged_each(*args, &block); end
  def plugin(plugin, *args, &block); end
  def plugins; end
  def prepared_finder(meth = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def primary_key; end
  def primary_key_hash(value); end
  def qualified_primary_key_hash(value, qualifier = T.unsafe(nil)); end
  def qualify(*args, &block); end
  def raise_on_save_failure; end
  def raise_on_save_failure=(_arg0); end
  def raise_on_typecast_failure; end
  def raise_on_typecast_failure=(_arg0); end
  def range(*args, &block); end
  def require_modification; end
  def require_modification=(_arg0); end
  def require_valid_table; end
  def require_valid_table=(_arg0); end
  def restrict_primary_key; end
  def restrict_primary_key?; end
  def reverse(*args, &block); end
  def reverse_order(*args, &block); end
  def right_join(*args, &block); end
  def right_outer_join(*args, &block); end
  def select(*args, &block); end
  def select_all(*args, &block); end
  def select_append(*args, &block); end
  def select_group(*args, &block); end
  def select_hash(*args, &block); end
  def select_hash_groups(*args, &block); end
  def select_map(*args, &block); end
  def select_more(*args, &block); end
  def select_order_map(*args, &block); end
  def server(*args, &block); end
  def set_allowed_columns(*cols); end
  def set_dataset(ds, opts = T.unsafe(nil)); end
  def set_graph_aliases(*args, &block); end
  def set_primary_key(key); end
  def setter_methods; end
  def simple_pk; end
  def simple_table; end
  def single_record(*args, &block); end
  def single_record!(*args, &block); end
  def single_value(*args, &block); end
  def single_value!(*args, &block); end
  def strict_param_setting; end
  def strict_param_setting=(_arg0); end
  def subset(*args, &block); end
  def sum(*args, &block); end
  def table_name; end
  def to_hash(*args, &block); end
  def to_hash_groups(*args, &block); end
  def truncate(*args, &block); end
  def typecast_empty_string_to_nil; end
  def typecast_empty_string_to_nil=(_arg0); end
  def typecast_on_assignment; end
  def typecast_on_assignment=(_arg0); end
  def unfiltered(*args, &block); end
  def ungraphed(*args, &block); end
  def ungrouped(*args, &block); end
  def union(*args, &block); end
  def unlimited(*args, &block); end
  def unordered(*args, &block); end
  def unrestrict_primary_key; end
  def use_after_commit_rollback; end
  def use_after_commit_rollback=(_arg0); end
  def use_transactions; end
  def use_transactions=(_arg0); end
  def where(*args, &block); end
  def where_all(*args, &block); end
  def where_each(*args, &block); end
  def where_single_value(*args, &block); end
  def with(*args, &block); end
  def with_pk(pk); end
  def with_pk!(pk); end
  def with_recursive(*args, &block); end
  def with_sql(*args, &block); end

  private

  def check_non_connection_error(do_raise = T.unsafe(nil)); end
  def convert_input_dataset(ds); end
  def dataset_extend(mod, opts = T.unsafe(nil)); end
  def def_bad_column_accessor(column); end
  def def_column_accessor(*columns); end
  def def_finder_method(mod, meth, type); end
  def def_model_dataset_method(meth); end
  def def_prepare_method(mod, meth); end
  def finder_for(meth); end
  def get_db_schema(reload = T.unsafe(nil)); end
  def get_setter_methods; end
  def inherited_instance_variables; end
  def initialize_copy(_); end
  def late_binding_class_option(opts, default); end
  def overridable_methods_module; end
  def plugin_module(plugin); end
  def plugin_module_defined?(plugin, submod); end
  def prepare_method_arg_hash(args); end
  def prepare_method_args(base, n); end
  def primary_key_lookup(pk); end
  def reload_db_schema?; end
  def reset_fast_pk_lookup_sql; end
  def reset_instance_dataset; end
  def set_columns(new_columns); end
  def set_dataset_row_proc(ds); end
  def simple_pk=(pk); end
  def simple_table=(t); end
end

Sequel::Model::ClassMethods::FINDER_TYPES = T.let(T.unsafe(nil), Array)
Sequel::Model::DATASET_METHODS = T.let(T.unsafe(nil), Array)

module Sequel::Model::DatasetMethods
  def [](*args); end
  def as_hash(key_column = T.unsafe(nil), value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def destroy; end
  def graph(table, *args, &block); end
  def insert_sql(*values); end
  def join_table(type, table, *args, &block); end
  def last(*a, &block); end
  def model; end
  def model=(v); end
  def paged_each(*a, &block); end
  def to_hash(*a); end
  def with_pk(pk); end
  def with_pk!(pk); end

  private

  def _model_where_loader; end
  def _primary_key_order; end
  def _with_pk_loader; end
  def non_sql_option?(key); end
end

class Sequel::Model::DatasetModule < ::Sequel::Dataset::DatasetModule
  def initialize(model); end

  def subset(name, *args, &block); end

  private

  def method_added(meth); end
end

class Sequel::Model::DeprecatedColumnsUpdated
  def initialize(columns_updated); end

  def method_missing(*args, &block); end
end

class Sequel::Model::Errors < ::Hash
  def add(att, msg); end
  def count; end
  def empty?; end
  def full_messages; end
  def on(att); end
end

Sequel::Model::Errors::ATTRIBUTE_JOINER = T.let(T.unsafe(nil), String)
Sequel::Model::HOOKS = T.let(T.unsafe(nil), Array)
Sequel::Model::INHERITED_INSTANCE_VARIABLES = T.let(T.unsafe(nil), Hash)

module Sequel::Model::InstanceMethods
  def initialize(values = T.unsafe(nil)); end

  def ==(obj); end
  def ===(obj); end
  def [](column); end
  def []=(column, value); end
  def _insert_values; end
  def after_commit; end
  def after_create; end
  def after_destroy; end
  def after_destroy_commit; end
  def after_destroy_rollback; end
  def after_rollback; end
  def after_save; end
  def after_update; end
  def after_validation; end
  def around_create; end
  def around_destroy; end
  def around_save; end
  def around_update; end
  def around_validation; end
  def autoincrementing_primary_key; end
  def before_create; end
  def before_destroy; end
  def before_save; end
  def before_update; end
  def before_validation; end
  def cancel_action(msg = T.unsafe(nil)); end
  def changed_columns; end
  def columns; end
  def db; end
  def db_schema; end
  def delete; end
  def destroy(opts = T.unsafe(nil)); end
  def each(&block); end
  def eql?(obj); end
  def errors; end
  def exists?; end
  def extend(mod); end
  def freeze; end
  def get_column_value(*_arg0); end
  def hash; end
  def id; end
  def inspect; end
  def keys; end
  def lock!(style = T.unsafe(nil)); end
  def marshallable!; end
  def model; end
  def modified!(column = T.unsafe(nil)); end
  def modified?(column = T.unsafe(nil)); end
  def new?; end
  def pk; end
  def pk_hash; end
  def primary_key; end
  def qualified_pk_hash(qualifier = T.unsafe(nil)); end
  def raise_on_save_failure; end
  def raise_on_save_failure=(_arg0); end
  def raise_on_typecast_failure; end
  def raise_on_typecast_failure=(_arg0); end
  def refresh; end
  def reload; end
  def require_modification; end
  def require_modification=(_arg0); end
  def save(opts = T.unsafe(nil)); end
  def save_changes(opts = T.unsafe(nil)); end
  def set(hash); end
  def set_all(hash); end
  def set_column_value(*_arg0); end
  def set_fields(hash, fields, opts = T.unsafe(nil)); end
  def set_only(hash, *only); end
  def set_server(s); end
  def singleton_method_added(meth); end
  def strict_param_setting; end
  def strict_param_setting=(_arg0); end
  def this; end
  def to_hash; end
  def typecast_empty_string_to_nil; end
  def typecast_empty_string_to_nil=(_arg0); end
  def typecast_on_assignment; end
  def typecast_on_assignment=(_arg0); end
  def update(hash); end
  def update_all(hash); end
  def update_fields(hash, fields, opts = T.unsafe(nil)); end
  def update_only(hash, *only); end
  def use_after_commit_rollback; end
  def use_after_commit_rollback=(_arg0); end
  def use_transactions; end
  def use_transactions=(_arg0); end
  def valid?(opts = T.unsafe(nil)); end
  def validate; end
  def values; end

  private

  def _after_create(pk); end
  def _after_save(pk); end
  def _after_update; end
  def _before_validation; end
  def _delete; end
  def _delete_dataset; end
  def _delete_without_checking; end
  def _destroy(opts); end
  def _destroy_delete; end
  def _insert; end
  def _insert_dataset; end
  def _insert_raw(ds); end
  def _insert_select_raw(ds); end
  def _refresh(dataset); end
  def _refresh_get(dataset); end
  def _refresh_set_values(h); end
  def _save(opts); end
  def _save_refresh; end
  def _save_set_values(h); end
  def _save_update_all_columns_hash; end
  def _update(columns); end
  def _update_columns(columns); end
  def _update_dataset; end
  def _update_without_checking(columns); end
  def _use_insert_select?(ds); end
  def _valid?(opts); end
  def change_column_value(column, value); end
  def checked_save_failure(opts); end
  def checked_transaction(opts = T.unsafe(nil)); end
  def errors_class; end
  def initialize_clone(other); end
  def initialize_copy(other); end
  def initialize_set(h); end
  def inspect_values; end
  def raise_hook_failure(type = T.unsafe(nil)); end
  def raise_on_failure?(opts); end
  def schema_type_class(column); end
  def set_restricted(hash, type); end
  def setter_methods(type); end
  def this_server; end
  def typecast_value(column, value); end
  def update_restricted(hash, type); end
  def use_server(ds); end
  def use_transaction?(opts = T.unsafe(nil)); end
end

Sequel::Model::NORMAL_METHOD_NAME_REGEXP = T.let(T.unsafe(nil), Regexp)
Sequel::Model::OPTS = T.let(T.unsafe(nil), Hash)
Sequel::Model::RESTRICTED_SETTER_METHODS = T.let(T.unsafe(nil), Array)
Sequel::Model::SETTER_METHOD_REGEXP = T.let(T.unsafe(nil), Regexp)
class Sequel::NoExistingObject < ::Sequel::Error; end

class Sequel::NoMatchingRow < ::Sequel::Error
  def initialize(msg = T.unsafe(nil)); end

  def dataset; end
  def dataset=(_arg0); end
end

class Sequel::NotNullConstraintViolation < ::Sequel::ConstraintViolation; end
Sequel::OPTS = T.let(T.unsafe(nil), Hash)

module Sequel::Plugins
  class << self
    def after_set_dataset(mod, meth); end
    def def_dataset_methods(mod, meths); end
    def inherited_instance_variables(mod, hash); end
  end
end

class Sequel::PoolTimeout < ::Sequel::Error; end

class Sequel::Qualifier < ::Sequel::ASTTransformer
  def initialize(table, unused = T.unsafe(nil)); end

  private

  def v(o); end
end

class Sequel::Rollback < ::Sequel::Error; end
Sequel::SHARED_ADAPTER_MAP = T.let(T.unsafe(nil), Hash)
Sequel::SPLIT_SYMBOL_CACHE = T.let(T.unsafe(nil), Hash)
module Sequel::SQL; end

module Sequel::SQL::AliasMethods
  def as(aliaz, columns = T.unsafe(nil)); end
end

class Sequel::SQL::AliasedExpression < ::Sequel::SQL::Expression
  def initialize(expression, aliaz, columns = T.unsafe(nil)); end

  def alias; end
  def aliaz; end
  def columns; end
  def expression; end
  def to_s_append(ds, sql); end
end

module Sequel::SQL::BitwiseMethods
  def %(o); end
  def &(o); end
  def <<(o); end
  def >>(o); end
  def ^(o); end
  def |(o); end
  def ~; end
end

class Sequel::SQL::Blob < ::String
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::CastMethods

  def inspect; end
  def lit(*args); end
  def to_sequel_blob; end
end

class Sequel::SQL::BooleanConstant < ::Sequel::SQL::Constant
  def to_s_append(ds, sql); end
end

class Sequel::SQL::BooleanExpression < ::Sequel::SQL::ComplexExpression
  include ::Sequel::SQL::BooleanMethods

  def &(ce); end
  def sql_boolean; end
  def |(ce); end

  class << self
    def from_value_pairs(pairs, op = T.unsafe(nil), negate = T.unsafe(nil)); end
    def invert(ce); end

    private

    def from_value_pair(l, r); end
  end
end

module Sequel::SQL::BooleanMethods
  def &(o); end
  def |(o); end
  def ~; end
end

module Sequel::SQL::Builders
  def as(exp, aliaz, columns = T.unsafe(nil)); end
  def asc(arg, opts = T.unsafe(nil)); end
  def blob(s); end
  def case(*args); end
  def cast(arg, sql_type); end
  def cast_numeric(arg, sql_type = T.unsafe(nil)); end
  def cast_string(arg, sql_type = T.unsafe(nil)); end
  def char_length(arg); end
  def deep_qualify(qualifier, expr); end
  def delay(&block); end
  def desc(arg, opts = T.unsafe(nil)); end
  def expr(arg = T.unsafe(nil), &block); end
  def extract(datetime_part, exp); end
  def function(name, *args); end
  def identifier(name); end
  def ilike(*args); end
  def join(args, joiner = T.unsafe(nil)); end
  def like(*args); end
  def lit(s, *args); end
  def negate(arg); end
  def or(arg); end
  def qualify(qualifier, identifier); end
  def subscript(exp, *subs); end
  def trim(arg); end
  def value_list(arg); end
end

class Sequel::SQL::CaseExpression < ::Sequel::SQL::GenericExpression
  def initialize(conditions, default, expression = T.unsafe(nil)); end

  def conditions; end
  def default; end
  def expression; end
  def expression?; end
  def to_s_append(ds, sql); end
  def with_merged_expression; end
end

class Sequel::SQL::Cast < ::Sequel::SQL::GenericExpression
  def initialize(expr, type); end

  def expr; end
  def to_s_append(ds, sql); end
  def type; end
end

module Sequel::SQL::CastMethods
  def cast(sql_type); end
  def cast_numeric(sql_type = T.unsafe(nil)); end
  def cast_string(sql_type = T.unsafe(nil)); end
end

class Sequel::SQL::ColumnAll < ::Sequel::SQL::Expression
  def initialize(table); end

  def table; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::ComplexExpression < ::Sequel::SQL::Expression
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::PatternMatchMethods
  include ::Sequel::SQL::SubscriptMethods

  def initialize(op, *args); end

  def args; end
  def op; end
  def sql_boolean; end
  def sql_number; end
  def sql_string; end
  def to_s_append(ds, sql); end
end

Sequel::SQL::ComplexExpression::ASSOCIATIVE_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::BITWISE_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::BOOLEAN_OPERATOR_METHODS = T.let(T.unsafe(nil), Hash)
Sequel::SQL::ComplexExpression::CONSTANT_INVERSIONS = T.let(T.unsafe(nil), Hash)
Sequel::SQL::ComplexExpression::CUSTOM_EXPRESSIONS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::EQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::INEQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::IN_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::IS_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::LIKE_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::MATHEMATICAL_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::N_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::ONE_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::OPERTATOR_INVERSIONS = T.let(T.unsafe(nil), Hash)
Sequel::SQL::ComplexExpression::REGEXP_OPERATORS = T.let(T.unsafe(nil), Array)
Sequel::SQL::ComplexExpression::TWO_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

module Sequel::SQL::ComplexExpressionMethods
  def extract(datetime_part); end
  def sql_boolean; end
  def sql_number; end
  def sql_string; end
end

class Sequel::SQL::Constant < ::Sequel::SQL::GenericExpression
  def initialize(constant); end

  def constant; end
  def to_s_append(ds, sql); end
end

module Sequel::SQL::Constants; end
Sequel::SQL::Constants::CURRENT_DATE = T.let(T.unsafe(nil), Sequel::SQL::Constant)
Sequel::SQL::Constants::CURRENT_TIME = T.let(T.unsafe(nil), Sequel::SQL::Constant)
Sequel::SQL::Constants::CURRENT_TIMESTAMP = T.let(T.unsafe(nil), Sequel::SQL::Constant)
Sequel::SQL::Constants::FALSE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)
Sequel::SQL::Constants::NOTNULL = T.let(T.unsafe(nil), Sequel::SQL::NegativeBooleanConstant)
Sequel::SQL::Constants::NULL = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)
Sequel::SQL::Constants::SQLFALSE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)
Sequel::SQL::Constants::SQLTRUE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)
Sequel::SQL::Constants::TRUE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

class Sequel::SQL::DelayedEvaluation < ::Sequel::SQL::GenericExpression
  def initialize(callable); end

  def call(ds); end
  def callable; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::Expression
  def ==(other); end
  def eql?(other); end
  def hash; end
  def inspect; end
  def lit; end
  def sql_literal(ds); end

  class << self
    def attr_reader(*args); end
    def comparison_attrs; end
    def inherited(subclass); end

    private

    def to_s_method(meth, args = T.unsafe(nil)); end
  end
end

class Sequel::SQL::Function < ::Sequel::SQL::GenericExpression
  def initialize(name, *args); end

  def *(ce = T.unsafe(nil)); end
  def args; end
  def distinct; end
  def f; end
  def filter(*args, &block); end
  def lateral; end
  def name; end
  def opts; end
  def order(*args); end
  def over(window = T.unsafe(nil)); end
  def quoted; end
  def to_s_append(ds, sql); end
  def unquoted; end
  def with_ordinality; end
  def within_group(*expressions); end

  private

  def _initialize(name, args, opts); end
  def with_opts(opts); end

  class << self
    def new!(name, args, opts); end
  end
end

Sequel::SQL::Function::COMMA_ARRAY = T.let(T.unsafe(nil), Array)
Sequel::SQL::Function::DISTINCT = T.let(T.unsafe(nil), Array)
Sequel::SQL::Function::WILDCARD = T.let(T.unsafe(nil), Sequel::LiteralString)

class Sequel::SQL::GenericExpression < ::Sequel::SQL::Expression
  include ::Sequel::SQL::SubscriptMethods
  include ::Sequel::SQL::BooleanMethods
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::ComplexExpressionMethods
  include ::Sequel::SQL::InequalityMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::PatternMatchMethods
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::AliasMethods
end

class Sequel::SQL::Identifier < ::Sequel::SQL::GenericExpression
  include ::Sequel::SQL::QualifyingMethods

  def initialize(value); end

  def function(*args); end
  def to_s_append(ds, sql); end
  def value; end
end

module Sequel::SQL::InequalityMethods
  def <(o); end
  def <=(o); end
  def >(o); end
  def >=(o); end
end

class Sequel::SQL::JoinClause < ::Sequel::SQL::Expression
  def initialize(join_type, table_expr); end

  def column_aliases; end
  def join_type; end
  def table; end
  def table_alias; end
  def table_expr; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::JoinOnClause < ::Sequel::SQL::JoinClause
  def initialize(on, *args); end

  def on; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::JoinUsingClause < ::Sequel::SQL::JoinClause
  def initialize(cols, *args); end

  def to_s_append(ds, sql); end
  def using; end
end

class Sequel::SQL::NegativeBooleanConstant < ::Sequel::SQL::Constant
  def to_s_append(ds, sql); end
end

class Sequel::SQL::NumericExpression < ::Sequel::SQL::ComplexExpression
  include ::Sequel::SQL::BitwiseMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::InequalityMethods

  def +(ce); end
  def sql_number; end
end

module Sequel::SQL::NumericMethods
  def *(o); end
  def **(o); end
  def +(ce); end
  def -(o); end
  def /(o); end
  def coerce(other); end
end

module Sequel::SQL::OperatorBuilders
  def &(*args); end
  def *(*args); end
  def **(a, b); end
  def +(*args); end
  def -(*args); end
  def /(*args); end
  def |(*args); end
  def ~(arg); end
end

module Sequel::SQL::OrderMethods
  def asc(opts = T.unsafe(nil)); end
  def desc(opts = T.unsafe(nil)); end
end

class Sequel::SQL::OrderedExpression < ::Sequel::SQL::Expression
  def initialize(expression, descending = T.unsafe(nil), opts = T.unsafe(nil)); end

  def asc; end
  def desc; end
  def descending; end
  def expression; end
  def invert; end
  def nulls; end
  def to_s_append(ds, sql); end
end

Sequel::SQL::OrderedExpression::INVERT_NULLS = T.let(T.unsafe(nil), Hash)

module Sequel::SQL::PatternMatchMethods
  def !~(other); end
  def =~(other); end
end

class Sequel::SQL::PlaceholderLiteralString < ::Sequel::SQL::GenericExpression
  def initialize(str, args, parens = T.unsafe(nil)); end

  def args; end
  def parens; end
  def str; end
  def to_s_append(ds, sql); end
  def with_parens; end
end

class Sequel::SQL::QualifiedIdentifier < ::Sequel::SQL::GenericExpression
  include ::Sequel::SQL::QualifyingMethods

  def initialize(table, column); end

  def column; end
  def function(*args); end
  def table; end
  def to_s_append(ds, sql); end

  private

  def convert_identifier(identifier); end
end

module Sequel::SQL::QualifyingMethods
  def *(ce = T.unsafe(nil)); end
  def [](identifier); end
  def qualify(qualifier); end
end

module Sequel::SQL::StringConcatenationMethods
  def +(ce); end
end

class Sequel::SQL::StringExpression < ::Sequel::SQL::ComplexExpression
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::StringConcatenationMethods
  include ::Sequel::SQL::InequalityMethods

  def sql_string; end

  class << self
    def like(l, *ces); end

    private

    def like_element(re); end
  end
end

Sequel::SQL::StringExpression::LIKE_MAP = T.let(T.unsafe(nil), Hash)

module Sequel::SQL::StringMethods
  def ilike(*ces); end
  def like(*ces); end
end

class Sequel::SQL::Subscript < ::Sequel::SQL::GenericExpression
  def initialize(f, sub); end

  def [](sub); end
  def f; end
  def sub; end
  def to_s_append(ds, sql); end
  def |(sub); end
end

module Sequel::SQL::SubscriptMethods
  def sql_subscript(*sub); end
end

class Sequel::SQL::ValueList < ::Array
  def inspect; end
end

class Sequel::SQL::VirtualRow < ::Sequel::BasicObject
  include ::Sequel::SQL::OperatorBuilders

  def initialize; end

  def <(*args); end
  def <=(*args); end
  def >(*args); end
  def >=(*args); end
  def `(s); end
end

Sequel::SQL::VirtualRow::DOUBLE_UNDERSCORE = T.let(T.unsafe(nil), String)
Sequel::SQL::VirtualRow::QUESTION_MARK = T.let(T.unsafe(nil), Sequel::LiteralString)
Sequel::SQL::VirtualRow::Sequel = Sequel

class Sequel::SQL::Window < ::Sequel::SQL::Expression
  def initialize(opts = T.unsafe(nil)); end

  def opts; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::Wrapper < ::Sequel::SQL::GenericExpression
  def initialize(value); end

  def to_s_append(ds, sql); end
  def value; end
end

class Sequel::SQLTime < ::Time
  def inspect; end
  def to_s(*args); end

  class << self
    def create(hour, minute, second, usec = T.unsafe(nil)); end
    def date; end
    def date=(_arg0); end
  end
end

module Sequel::Schema; end

class Sequel::Schema::AlterTableGenerator
  def initialize(db, &block); end

  def add_column(name, type, opts = T.unsafe(nil)); end
  def add_constraint(name, *args, &block); end
  def add_foreign_key(name, table, opts = T.unsafe(nil)); end
  def add_full_text_index(columns, opts = T.unsafe(nil)); end
  def add_index(columns, opts = T.unsafe(nil)); end
  def add_primary_key(name, opts = T.unsafe(nil)); end
  def add_spatial_index(columns, opts = T.unsafe(nil)); end
  def add_unique_constraint(columns, opts = T.unsafe(nil)); end
  def drop_column(name, opts = T.unsafe(nil)); end
  def drop_constraint(name, opts = T.unsafe(nil)); end
  def drop_foreign_key(name, opts = T.unsafe(nil)); end
  def drop_index(columns, options = T.unsafe(nil)); end
  def operations; end
  def rename_column(name, new_name, opts = T.unsafe(nil)); end
  def set_column_allow_null(name, allow_null = T.unsafe(nil)); end
  def set_column_default(name, default); end
  def set_column_not_null(name); end
  def set_column_type(name, type, opts = T.unsafe(nil)); end

  private

  def add_composite_foreign_key(columns, table, opts); end
  def add_composite_primary_key(columns, opts); end
  def drop_composite_foreign_key(columns, opts); end
end

class Sequel::Schema::CreateTableGenerator
  def initialize(db, &block); end

  def BigDecimal(name, opts = T.unsafe(nil)); end
  def Bignum(name, opts = T.unsafe(nil)); end
  def Date(name, opts = T.unsafe(nil)); end
  def DateTime(name, opts = T.unsafe(nil)); end
  def FalseClass(name, opts = T.unsafe(nil)); end
  def File(name, opts = T.unsafe(nil)); end
  def Fixnum(name, opts = T.unsafe(nil)); end
  def Float(name, opts = T.unsafe(nil)); end
  def Integer(name, opts = T.unsafe(nil)); end
  def Numeric(name, opts = T.unsafe(nil)); end
  def String(name, opts = T.unsafe(nil)); end
  def Time(name, opts = T.unsafe(nil)); end
  def TrueClass(name, opts = T.unsafe(nil)); end
  def check(*args, &block); end
  def column(name, type, opts = T.unsafe(nil)); end
  def columns; end
  def constraint(name, *args, &block); end
  def constraints; end
  def foreign_key(name, table = T.unsafe(nil), opts = T.unsafe(nil)); end
  def full_text_index(columns, opts = T.unsafe(nil)); end
  def has_column?(name); end
  def index(columns, opts = T.unsafe(nil)); end
  def indexes; end
  def method_missing(type, name = T.unsafe(nil), opts = T.unsafe(nil)); end
  def primary_key(name, *args); end
  def primary_key_name; end
  def spatial_index(columns, opts = T.unsafe(nil)); end
  def unique(columns, opts = T.unsafe(nil)); end

  private

  def composite_foreign_key(columns, opts); end
  def composite_primary_key(columns, *args); end
  def respond_to_missing?(meth, include_private); end

  class << self
    def add_type_method(*types); end
  end
end

Sequel::Schema::CreateTableGenerator::GENERIC_TYPES = T.let(T.unsafe(nil), Array)
Sequel::Schema::Generator = Sequel::Schema::CreateTableGenerator
class Sequel::SerializationFailure < ::Sequel::DatabaseError; end

class Sequel::SimpleMigration
  def initialize; end

  def apply(db, direction); end
  def down; end
  def down=(_arg0); end
  def up; end
  def up=(_arg0); end
  def use_transactions; end
  def use_transactions=(_arg0); end
end

Sequel::TINY = T.let(T.unsafe(nil), Integer)

class Sequel::TimestampMigrator < ::Sequel::Migrator
  def initialize(db, directory, opts = T.unsafe(nil)); end

  def applied_migrations; end
  def is_current?; end
  def migration_tuples; end
  def run; end

  private

  def convert_from_schema_info; end
  def default_schema_column; end
  def default_schema_table; end
  def get_applied_migrations; end
  def get_migration_files; end
  def get_migration_tuples; end
  def schema_dataset; end
end

Sequel::TimestampMigrator::DEFAULT_SCHEMA_COLUMN = T.let(T.unsafe(nil), Symbol)
Sequel::TimestampMigrator::DEFAULT_SCHEMA_TABLE = T.let(T.unsafe(nil), Symbol)
Sequel::TimestampMigrator::Error = Sequel::Migrator::Error

module Sequel::Timezones
  def application_timezone; end
  def application_timezone=(tz); end
  def application_to_database_timestamp(v); end
  def convert_output_timestamp(v, output_timezone); end
  def convert_timestamp(v, input_timezone); end
  def database_timezone; end
  def database_timezone=(tz); end
  def database_to_application_timestamp(v); end
  def default_timezone=(tz); end
  def typecast_timezone; end
  def typecast_timezone=(tz); end
  def typecast_to_application_timestamp(v); end

  private

  def convert_input_datetime_no_offset(v, input_timezone); end
  def convert_input_datetime_other(v, input_timezone); end
  def convert_input_timestamp(v, input_timezone); end
  def convert_output_datetime_other(v, output_timezone); end
  def convert_timezone_setter_arg(tz); end
  def local_offset_for_datetime(dt); end
  def time_offset_to_datetime_offset(offset_secs); end
end

class Sequel::UnbindDuplicate < ::Sequel::Error; end

class Sequel::Unbinder < ::Sequel::ASTTransformer
  def initialize; end

  def binds; end

  private

  def bind_key(obj); end
  def v(o); end
end

Sequel::Unbinder::UNBIND_KEY_CLASSES = T.let(T.unsafe(nil), Array)
Sequel::Unbinder::UNBIND_OPS = T.let(T.unsafe(nil), Array)
Sequel::Unbinder::UNBIND_VALUE_CLASSES = T.let(T.unsafe(nil), Array)
class Sequel::UndefinedAssociation < ::Sequel::Error; end
class Sequel::UniqueConstraintViolation < ::Sequel::ConstraintViolation; end
Sequel::VERSION = T.let(T.unsafe(nil), String)
Sequel::VIRTUAL_ROW = T.let(T.unsafe(nil), Sequel::SQL::VirtualRow)

class Sequel::ValidationFailed < ::Sequel::Error
  def initialize(errors = T.unsafe(nil)); end

  def errors; end
  def model; end
end

class Symbol
  include ::Comparable
end

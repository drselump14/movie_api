# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rom-sql` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module ROM
  include ::Dry::Core::Constants
  extend ::ROM::Global

  class << self
    def container(*args, &block); end
  end
end

class ROM::AdapterLoadError < ::StandardError; end
class ROM::CommandError < ::StandardError; end
class ROM::DuplicateConfigurationError < ::StandardError; end
class ROM::DuplicateContainerError < ::StandardError; end
ROM::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ROM::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
ROM::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
ROM::EMPTY_SET = T.let(T.unsafe(nil), Set)
ROM::EMPTY_STRING = T.let(T.unsafe(nil), String)
class ROM::EnvAlreadyFinalizedError < ::StandardError; end
ROM::IDENTITY = T.let(T.unsafe(nil), Proc)
class ROM::InvalidOptionKeyError < ::StandardError; end
class ROM::InvalidOptionValueError < ::StandardError; end
class ROM::KeyMissing < ::ROM::CommandError; end
class ROM::MapperMisconfiguredError < ::StandardError; end
class ROM::MapperMissingError < ::StandardError; end
class ROM::MissingAdapterIdentifierError < ::StandardError; end
class ROM::NoRelationError < ::StandardError; end
module ROM::Plugins; end
module ROM::Plugins::Relation; end
ROM::Plugins::Relation::EMPTY_REGISTRY = T.let(T.unsafe(nil), ROM::RelationRegistry)
module ROM::Plugins::Relation::SQL; end

module ROM::Plugins::Relation::SQL::AutoCombine
  include ::ROM::Plugins::Relation::SQL::AutoCombine::InstanceInterface

  mixes_in_class_methods ::ROM::Plugins::Relation::SQL::AutoCombine::ClassInterface

  class << self
    def included(klass); end
  end
end

module ROM::Plugins::Relation::SQL::AutoCombine::ClassInterface
  def inherited(klass); end
end

module ROM::Plugins::Relation::SQL::AutoCombine::InstanceInterface
  def for_combine(spec); end
  def preload(spec, source); end
end

module ROM::Plugins::Relation::SQL::AutoRestrictions
  class << self
    def included(klass); end
    def restriction_methods(schema); end
  end
end

class ROM::Plugins::Relation::SQL::AutoRestrictions::EmptySchemaError < ::ArgumentError
  def initialize(klass); end
end

module ROM::Plugins::Relation::SQL::AutoWrap
  include ::ROM::Plugins::Relation::SQL::AutoWrap::InstanceInterface

  mixes_in_class_methods ::ROM::Plugins::Relation::SQL::AutoWrap::ClassInterface

  class << self
    def included(klass); end
  end
end

module ROM::Plugins::Relation::SQL::AutoWrap::ClassInterface
  def inherited(klass); end
end

module ROM::Plugins::Relation::SQL::AutoWrap::InstanceInterface
  def for_wrap(keys, name); end
end

module ROM::Plugins::Relation::SQL::Instrumentation
  include ::ROM::Plugins::Relation::Instrumentation

  class << self
    def included(klass); end
  end
end

class ROM::RelationAlreadyDefinedError < ::StandardError; end

module ROM::SQL
  extend ::Dry::Core::Extensions

  class << self
    def current_gateway; end
    def current_gateway=(_arg0); end
    def migration(*args, &block); end
    def with_gateway(gateway); end
  end
end

class ROM::SQL::Association
  extend ::Dry::Core::ClassAttributes
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Initializer::InstanceDSL
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::Dry::Core::Constants
  include ::Dry::Core::Constants

  def apply_view(schema, relation); end
  def join(relations, type, source = T.unsafe(nil), target = T.unsafe(nil)); end
  def join_key_map(relations); end
  def name; end
  def qualify(name, attribute); end
  def self_ref?; end

  class << self
    def new(source, target, options = T.unsafe(nil)); end
  end
end

ROM::SQL::Association::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ROM::SQL::Association::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
ROM::SQL::Association::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
ROM::SQL::Association::EMPTY_SET = T.let(T.unsafe(nil), Set)
ROM::SQL::Association::EMPTY_STRING = T.let(T.unsafe(nil), String)
ROM::SQL::Association::IDENTITY = T.let(T.unsafe(nil), Proc)

class ROM::SQL::Association::ManyToMany < ::ROM::SQL::Association
  def initialize(*_arg0); end

  def associate(relations, children, parent); end
  def call(relations, target_rel = T.unsafe(nil)); end
  def combine_keys(relations); end
  def join(relations, type, source = T.unsafe(nil), target = T.unsafe(nil)); end
  def join_keys(relations); end
  def join_relation(relations); end
  def parent_combine_keys(relations); end
  def persist(relations, children, parents); end

  protected

  def join_key_map(relations); end
  def with_keys(relations, &block); end
end

class ROM::SQL::Association::ManyToOne < ::ROM::SQL::Association
  def associate(relations, child, parent); end
  def call(relations, left = T.unsafe(nil)); end
  def combine_keys(relations); end
  def join_keys(relations); end

  protected

  def source_alias; end
  def source_table; end
  def with_keys(relations, &block); end
end

class ROM::SQL::Association::Name
  include ::Dry::Equalizer::Methods
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  def initialize(relation_name, aliaz); end

  def aliased?; end
  def as(aliaz); end
  def dataset; end
  def inspect; end
  def key; end
  def relation; end
  def relation_name; end
  def sql_literal(ds); end
  def to_s; end
  def to_sym; end

  class << self
    def [](*args); end
  end
end

class ROM::SQL::Association::OneToMany < ::ROM::SQL::Association
  def associate(relations, child, parent); end
  def call(relations, right = T.unsafe(nil)); end
  def combine_keys(relations); end
  def join_keys(relations); end

  protected

  def source_alias; end
  def source_table; end
  def with_keys(relations, &block); end
end

class ROM::SQL::Association::OneToOne < ::ROM::SQL::Association::OneToMany; end
class ROM::SQL::Association::OneToOneThrough < ::ROM::SQL::Association::ManyToMany; end
ROM::SQL::Association::Self = T.let(T.unsafe(nil), Proc)
ROM::SQL::Association::Undefined = T.let(T.unsafe(nil), Object)

class ROM::SQL::Attribute < ::ROM::Schema::Attribute
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  def !; end
  def =~(other); end
  def aliased(name); end
  def as(name); end
  def canonical; end
  def concat(other, sep = T.unsafe(nil)); end
  def foreign_key; end
  def func(&block); end
  def in(*args); end
  def is(other); end
  def joined; end
  def joined?; end
  def not(other); end
  def qualified; end
  def qualified?; end
  def sql_literal(ds); end
  def to_sql_name; end
  def to_sym; end

  private

  def __cmp__(op, other); end
  def binary_operation_arg(value); end
  def method_missing(meth, *args, &block); end
  def sql_expr; end

  class << self
    def [](*args); end
  end
end

ROM::SQL::Attribute::NONSTANDARD_EQUALITY_VALUES = T.let(T.unsafe(nil), Array)
ROM::SQL::Attribute::OPERATORS = T.let(T.unsafe(nil), Array)
class ROM::SQL::Attribute::QualifyError < ::StandardError; end

module ROM::SQL::Attribute::TypeExtensions
  class << self
    def [](wrapped); end
    def register(type, &block); end
  end
end

class ROM::SQL::CheckConstraintError < ::ROM::SQL::ConstraintError; end
module ROM::SQL::Commands; end

class ROM::SQL::Commands::Create < ::ROM::Commands::Create
  include ::ROM::SQL::Commands::Transaction
  include ::ROM::SQL::Commands::ErrorWrapper
  include ::ROM::SQL::Plugin::Associates
  include ::ROM::SQL::Plugin::Associates::InstanceMethods
  include ::ROM::Plugins::Command::Schema
  extend ::ROM::SQL::Plugin::Associates::ClassMethods
  extend ::ROM::Plugins::Command::Schema::ClassInterface

  def execute(tuples); end

  private

  def finalize(tuples, *_arg1); end
  def insert(tuples); end
  def multi_insert(tuples); end
  def with_input_tuples(tuples); end
end

class ROM::SQL::Commands::Delete < ::ROM::Commands::Delete
  include ::ROM::SQL::Commands::Transaction
  include ::ROM::SQL::Commands::ErrorWrapper

  def execute; end
end

module ROM::SQL::Commands::ErrorWrapper
  def [](*args); end
  def call(*args); end
end

module ROM::SQL::Commands::Transaction
  def transaction(options = T.unsafe(nil), &block); end
end

class ROM::SQL::Commands::Update < ::ROM::Commands::Update
  include ::ROM::SQL::Commands::Transaction
  include ::ROM::SQL::Commands::ErrorWrapper
  include ::ROM::Plugins::Command::Schema
  include ::ROM::SQL::Plugin::Associates
  include ::ROM::SQL::Plugin::Associates::InstanceMethods
  extend ::ROM::Plugins::Command::Schema::ClassInterface
  extend ::ROM::SQL::Plugin::Associates::ClassMethods

  def execute(tuple); end

  private

  def finalize(tuples, *_arg1); end
  def primary_key; end
  def update(tuple); end
  def with_input_tuples(tuples); end
end

class ROM::SQL::ConstraintError < ::ROM::SQL::Error; end

class ROM::SQL::DSL < ::BasicObject
  def initialize(schema); end

  def call(&block); end
  def schema; end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
  def type(identifier); end
  def types; end
end

class ROM::SQL::DatabaseError < ::ROM::SQL::Error; end
ROM::SQL::ERROR_MAP = T.let(T.unsafe(nil), Hash)

class ROM::SQL::Error < ::StandardError
  def initialize(original_exception); end

  def original_exception; end
end

class ROM::SQL::ForeignKeyConstraintError < ::ROM::SQL::ConstraintError; end

class ROM::SQL::Function < ::ROM::Schema::Attribute
  def cast(expr, db_type); end
  def is(other); end
  def name; end
  def qualified; end
  def sql_literal(ds); end

  private

  def func; end
  def method_missing(meth, *args); end
end

class ROM::SQL::Gateway < ::ROM::Gateway
  include ::Dry::Core::Constants
  include ::ROM::SQL::Migration

  def initialize(uri, options = T.unsafe(nil)); end

  def [](name); end
  def create_table(*args, &block); end
  def dataset(name); end
  def dataset?(name); end
  def disconnect; end
  def drop_table(*args, &block); end
  def extend_command_class(klass, dataset); end
  def logger; end
  def options; end
  def schema; end
  def use_logger(logger); end

  private

  def connect(uri, *args); end
  def load_extensions(exts); end
  def transaction_runner(_); end

  class << self
    def instance; end
    def instance=(_arg0); end
  end
end

ROM::SQL::Gateway::CONNECTION_EXTENSIONS = T.let(T.unsafe(nil), Hash)
ROM::SQL::Gateway::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ROM::SQL::Gateway::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
ROM::SQL::Gateway::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
ROM::SQL::Gateway::EMPTY_SET = T.let(T.unsafe(nil), Set)
ROM::SQL::Gateway::EMPTY_STRING = T.let(T.unsafe(nil), String)
ROM::SQL::Gateway::IDENTITY = T.let(T.unsafe(nil), Proc)
ROM::SQL::Gateway::Self = T.let(T.unsafe(nil), Proc)
ROM::SQL::Gateway::Undefined = T.let(T.unsafe(nil), Object)

class ROM::SQL::GroupDSL < ::ROM::SQL::DSL
  private

  def method_missing(meth, *args, &block); end
end

module ROM::SQL::Migration
  def initialize(uri, options = T.unsafe(nil)); end

  def migration(&block); end
  def migrator; end
  def pending_migrations?; end
  def run_migrations(options = T.unsafe(nil)); end

  class << self
    def included(base); end
  end
end

class ROM::SQL::Migration::Migrator
  include ::Dry::Initializer::InstanceDSL
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer

  def create_file(name, version = T.unsafe(nil)); end
  def generate_version; end
  def migration(&block); end
  def migration_file_content; end
  def pending?; end
  def run(options = T.unsafe(nil)); end
end

ROM::SQL::Migration::Migrator::DEFAULT_PATH = T.let(T.unsafe(nil), String)
ROM::SQL::Migration::Migrator::VERSION_FORMAT = T.let(T.unsafe(nil), String)
class ROM::SQL::MissingConfigurationError < ::StandardError; end
class ROM::SQL::MissingPrimaryKeyError < ::StandardError; end
class ROM::SQL::NoAssociationError < ::StandardError; end
class ROM::SQL::NotNullConstraintError < ::ROM::SQL::ConstraintError; end

class ROM::SQL::OrderDSL < ::ROM::SQL::DSL
  private

  def method_missing(meth, *args, &block); end
end

module ROM::SQL::Plugin; end

module ROM::SQL::Plugin::Associates
  include ::ROM::SQL::Plugin::Associates::InstanceMethods

  mixes_in_class_methods ::ROM::SQL::Plugin::Associates::ClassMethods

  class << self
    def included(klass); end
  end
end

class ROM::SQL::Plugin::Associates::AssociateOptions
  def initialize(name, relation, opts); end

  def after?; end
  def assoc; end
  def ensure_valid(command); end
  def name; end
  def opts; end
  def to_hash; end
end

module ROM::SQL::Plugin::Associates::ClassMethods
  def associates(name, options = T.unsafe(nil)); end
  def build(relation, options = T.unsafe(nil)); end
end

module ROM::SQL::Plugin::Associates::InstanceMethods
  def __registry__; end
  def associate(tuples, curried_parent = T.unsafe(nil), assoc:, keys:, parent: T.unsafe(nil)); end
  def with_association(name, opts = T.unsafe(nil)); end
end

class ROM::SQL::Plugin::Associates::MissingJoinKeysError < ::StandardError
  def initialize(command, assoc_name); end

  def tokens(command, assoc_name); end
end

ROM::SQL::Plugin::Associates::MissingJoinKeysError::ERROR_TEMPLATE = T.let(T.unsafe(nil), String)

module ROM::SQL::Plugin::Pagination
  def page(num); end
  def per_page(num); end

  class << self
    def included(klass); end
  end
end

class ROM::SQL::Plugin::Pagination::Pager
  include ::Dry::Initializer::InstanceDSL
  include ::ROM::Initializer::InstanceMethods
  include ::Dry::Core::Equalizer::Methods
  extend ::ROM::Initializer
  extend ::Dry::Initializer

  def at(dataset, current_page, per_page = T.unsafe(nil)); end
  def limit_value; end
  def next_page; end
  def prev_page; end
  def total; end
  def total_pages; end
end

module ROM::SQL::Plugin::Timestamps
  mixes_in_class_methods ::ROM::SQL::Plugin::Timestamps::ClassInterface

  class << self
    def included(klass); end
  end
end

module ROM::SQL::Plugin::Timestamps::ClassInterface
  def datestamp(*args); end
  def datestamps(*args); end
  def timestamp(*args); end
  def timestamps(*args); end

  class << self
    def extended(klass); end
  end
end

module ROM::SQL::Plugin::Timestamps::InstanceMethods
  def datestamp_columns; end
  def set_timestamps(tuples, *_arg1); end
  def timestamp_columns; end

  private

  def build_timestamps; end

  class << self
    def included(base); end
  end
end

class ROM::SQL::ProjectionDSL < ::ROM::SQL::DSL
  def `(value); end

  private

  def method_missing(meth, *args, &block); end
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

class ROM::SQL::QualifiedAttribute
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  def initialize(dataset, attribute); end

  def attribute; end
  def dataset; end
  def sql_literal_append(ds, sql); end
  def to_sym; end

  class << self
    def [](*args); end
  end
end

class ROM::SQL::Relation < ::ROM::Relation
  extend ::ROM::Plugins::Relation::SQL::AutoWrap::ClassInterface
  include ::ROM::Plugins::Relation::KeyInference
  include ::ROM::Plugins::Relation::SQL::AutoCombine
  include ::ROM::Plugins::Relation::SQL::AutoCombine::InstanceInterface
  include ::ROM::Plugins::Relation::SQL::AutoWrap
  include ::ROM::Plugins::Relation::SQL::AutoWrap::InstanceInterface
  include ::ROM::SQL::Relation::Writing
  include ::ROM::SQL::Relation::Reading
  extend ::ROM::Plugins::Relation::SQL::AutoCombine::ClassInterface
  include ::ROM::SQL

  def assoc(name); end
  def columns; end

  class << self
    def associations; end
    def define_default_views!; end
    def inherited(klass); end
    def primary_key_columns(db, table); end
  end
end

module ROM::SQL::Relation::Reading
  def avg(*args); end
  def count; end
  def distinct(*args, &block); end
  def exclude(*args, &block); end
  def exist?(*args, &block); end
  def fetch(pk); end
  def first; end
  def group(*args, &block); end
  def group_and_count(*args, &block); end
  def group_append(*args, &block); end
  def having(*args, &block); end
  def inner_join(*args, &block); end
  def invert; end
  def join(*args, &block); end
  def last; end
  def left_join(*args, &block); end
  def limit(*args); end
  def lock(options = T.unsafe(nil), &block); end
  def map(key = T.unsafe(nil), &block); end
  def max(*args); end
  def min(*args); end
  def offset(num); end
  def order(*args, &block); end
  def pluck(name); end
  def prefix(name = T.unsafe(nil)); end
  def project(*args, &block); end
  def qualified; end
  def qualified_columns; end
  def read(sql); end
  def rename(options); end
  def reverse(*args, &block); end
  def right_join(*args, &block); end
  def select(*args, &block); end
  def select_append(*args, &block); end
  def select_group(*args, &block); end
  def sum(*args); end
  def union(relation, options = T.unsafe(nil), &block); end
  def unique?(criteria); end
  def where(*args, &block); end

  private

  def __join__(type, other, join_cond = T.unsafe(nil), opts = T.unsafe(nil), &block); end
  def coerce_conditions(conditions); end
  def lock_clause(mode: T.unsafe(nil), skip_locked: T.unsafe(nil), of: T.unsafe(nil), wait: T.unsafe(nil)); end
end

ROM::SQL::Relation::Reading::ROW_LOCK_MODES = T.let(T.unsafe(nil), Hash)

module ROM::SQL::Relation::Writing
  def delete(*args, &block); end
  def insert(*args, &block); end
  def multi_insert(*args, &block); end
  def update(*args, &block); end
  def upsert(*args, &block); end
end

class ROM::SQL::RestrictionDSL < ::ROM::SQL::DSL
  def call(&block); end
  def exists(relation); end

  private

  def method_missing(meth, *args, &block); end
end

class ROM::SQL::Rollback < ::Sequel::Rollback; end

class ROM::SQL::Schema < ::ROM::Schema
  def initialize(*_arg0); end

  def call(relation); end
  def canonical; end
  def empty; end
  def finalize!(*args); end
  def group(&block); end
  def initialize_primary_key_names; end
  def join(other); end
  def joined; end
  def order(&block); end
  def primary_key_name; end
  def primary_key_names; end
  def project(*names, &block); end
  def project_fk(mapping); end
  def project_pk; end
  def qualified; end
  def restriction(&block); end
end

class ROM::SQL::Schema::AssociationsDSL < ::BasicObject
  def initialize(source, &block); end

  def belongs_to(name, options = T.unsafe(nil)); end
  def call; end
  def has_many(target, options = T.unsafe(nil)); end
  def has_one(name, options = T.unsafe(nil)); end
  def many_to_many(target, options = T.unsafe(nil)); end
  def many_to_one(target, options = T.unsafe(nil)); end
  def one_to_many(target, options = T.unsafe(nil)); end
  def one_to_one(target, options = T.unsafe(nil)); end
  def one_to_one_through(target, options = T.unsafe(nil)); end
  def registry; end
  def source; end

  private

  def add(association); end
  def dataset_name(name); end
end

class ROM::SQL::Schema::DSL < ::ROM::Schema::DSL
  def associations(&block); end
  def associations_dsl; end
  def call; end

  private

  def opts; end
end

class ROM::SQL::Schema::Inferrer
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  def call(source, gateway); end

  private

  def build_fk(columns:, table:, **rest); end
  def build_type(primary_key:, db_type:, type:, allow_null:, foreign_key:, indexes:, **rest); end
  def column_indexes(indexes, column); end
  def filter_columns(schema); end
  def fks_for(gateway, dataset); end
  def indexes_for(gateway, dataset); end
  def map_decimal_type(type); end
  def map_pk_type(_ruby_type, _db_type); end
  def map_type(ruby_type, db_type, **kw); end

  class << self
    def [](type); end
    def get(type); end
    def inherited(klass); end
    def on_error(relation, e); end
  end
end

ROM::SQL::Schema::Inferrer::CONSTRAINT_DB_TYPE = T.let(T.unsafe(nil), String)
ROM::SQL::Schema::Inferrer::DECIMAL_REGEX = T.let(T.unsafe(nil), Regexp)

module ROM::SQL::SequelAPI
  def group(*args, &block); end
  def having(*args, &block); end
  def inner_join(*args, &block); end
  def left_join(*args, &block); end
  def order(*args, &block); end
  def select(*args, &block); end
  def select_append(*args, &block); end
  def where(*args, &block); end
end

class ROM::SQL::Transaction < ::ROM::Transaction
  def initialize(connection); end

  def run(opts = T.unsafe(nil)); end

  private

  def connection; end
end

module ROM::SQL::Types
  include ::ROM::Types
  extend ::ROM::Types::Methods

  class << self
    def Constructor(*args, &block); end
    def Definition(*args, &block); end
  end
end

ROM::SQL::Types::Blob = T.let(T.unsafe(nil), Dry::Types::Constructor)
ROM::SQL::Types::Serial = T.let(T.unsafe(nil), Dry::Types::Definition)
ROM::SQL::Types::Void = T.let(T.unsafe(nil), Dry::Types::Definition)
class ROM::SQL::UniqueConstraintError < ::ROM::SQL::ConstraintError; end
class ROM::SQL::UnknownDBTypeError < ::StandardError; end
ROM::SQL::VERSION = T.let(T.unsafe(nil), String)
ROM::Self = T.let(T.unsafe(nil), Proc)
class ROM::TupleCountMismatchError < ::ROM::CommandError; end
ROM::Undefined = T.let(T.unsafe(nil), Object)
class ROM::UnknownPluginError < ::StandardError; end
class ROM::UnsupportedRelationError < ::StandardError; end
ROM::VERSION = T.let(T.unsafe(nil), String)
class Sequel::Rollback < ::Sequel::Error; end

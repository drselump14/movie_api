# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hanami-controller` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Hanami
  class << self
    def app; end
    def app?(app); end
    def boot; end
    def code_reloading?; end
    def configuration; end
    def configure(&blk); end
    def env; end
    def env?(*names); end
    def environment; end
    def logger; end
    def plugin(&blk); end
    def plugins; end
    def public_directory; end
    def root; end
  end
end

module Hanami::Action
  include ::Hanami::Action::Head
  include ::Hanami::Action::Mime
  include ::Hanami::Action::Redirect
  include ::Hanami::Action::Exposable::Guard
  include ::Hanami::Action::Exposable
  include ::Hanami::Action::Throwable
  include ::Hanami::Utils::ClassAttribute
  include ::Hanami::Action::Callbacks
  include ::Hanami::Action::Validatable
  include ::Hanami::Action::Glue
  include ::Hanami::Action::Configurable
  include ::Hanami::Action::Rack

  private

  def finish; end
  def flash; end
  def session; end

  class << self
    def included(base); end
  end
end

class Hanami::Action::BaseParams
  def initialize(env); end

  def [](key); end
  def dig(*keys); end
  def each(&blk); end
  def env; end
  def get(*keys); end
  def raw; end
  def to_h; end
  def to_hash; end
  def valid?; end

  private

  def _extract_params; end
  def _router_params(fallback = T.unsafe(nil)); end
end

Hanami::Action::BaseParams::DEFAULT_REQUEST_METHOD = T.let(T.unsafe(nil), String)
Hanami::Action::BaseParams::RACK_INPUT = T.let(T.unsafe(nil), String)
Hanami::Action::BaseParams::RACK_SESSION = T.let(T.unsafe(nil), String)
Hanami::Action::BaseParams::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Hanami::Action::BaseParams::ROUTER_PARAMS = T.let(T.unsafe(nil), String)

module Hanami::Action::Callable
  def call(env); end

  private

  def finish; end
end

module Hanami::Action::Callbacks
  include ::Hanami::Utils::ClassAttribute

  mixes_in_class_methods ::Hanami::Action::Callbacks::ClassMethods

  class << self
    def included(base); end
  end
end

module Hanami::Action::Callbacks::ClassMethods
  def after(*callbacks, &blk); end
  def append_after(*callbacks, &blk); end
  def append_before(*callbacks, &blk); end
  def before(*callbacks, &blk); end
  def prepend_after(*callbacks, &blk); end
  def prepend_before(*callbacks, &blk); end

  class << self
    def extended(base); end
  end
end

module Hanami::Action::Callbacks::InstanceMethods
  def call(params); end

  private

  def _run_after_callbacks(params); end
  def _run_before_callbacks(params); end
end

module Hanami::Action::Configurable
  include ::Hanami::Utils::ClassAttribute
  include ::Hanami::Action::Glue

  private

  def configuration; end

  class << self
    def included(base); end
  end
end

module Hanami::Action::Exposable
  include ::Hanami::Action::Exposable::Guard

  mixes_in_class_methods ::Hanami::Action::Exposable::ClassMethods

  def exposures; end
  def finish; end

  class << self
    def included(base); end
  end
end

module Hanami::Action::Exposable::ClassMethods
  def _expose(*names); end
  def expose(*names); end
  def exposures; end

  private

  def attr_reader?(name); end
end

module Hanami::Action::Exposable::Guard
  mixes_in_class_methods ::Hanami::Action::Exposable::Guard::ClassMethods

  class << self
    def included(base); end
  end
end

module Hanami::Action::Exposable::Guard::ClassMethods
  def expose(*names); end

  private

  def detect_reserved_words!(names); end
  def reserved_word?(name, namespace = T.unsafe(nil)); end
end

module Hanami::Action::Glue
  def renderable?; end

  protected

  def finish; end
  def sending_file?; end

  class << self
    def included(base); end
  end
end

Hanami::Action::Glue::ADDITIONAL_HTTP_STATUSES_WITHOUT_BODY = T.let(T.unsafe(nil), Set)
Hanami::Action::Glue::ENV_KEY = T.let(T.unsafe(nil), String)

module Hanami::Action::Head
  def finish; end

  protected

  def _requires_no_body?; end

  private

  def keep_response_header?(header); end
end

Hanami::Action::Head::ENTITY_HEADERS = T.let(T.unsafe(nil), Hash)
Hanami::Action::Head::HTTP_STATUSES_WITHOUT_BODY = T.let(T.unsafe(nil), Set)

module Hanami::Action::Mime
  mixes_in_class_methods ::Hanami::Action::Mime::ClassMethods

  def charset; end
  def charset=(value); end
  def content_type; end
  def format; end

  private

  def accept; end
  def accept?(mime_type); end
  def accept_header?; end
  def best_q_match(q_value_header, available_mimes); end
  def content_type_from_accept_header; end
  def content_type_with_charset; end
  def default_charset; end
  def default_content_type; end
  def default_response_type; end
  def detect_format; end
  def finish; end
  def format=(format); end

  class << self
    def included(base); end
  end
end

Hanami::Action::Mime::CONTENT_TYPE = T.let(T.unsafe(nil), String)

module Hanami::Action::Mime::ClassMethods
  def format_to_mime_type(format); end

  private

  def accept(*formats); end
  def content_type(*formats); end
end

Hanami::Action::Mime::DEFAULT_ACCEPT = T.let(T.unsafe(nil), String)
Hanami::Action::Mime::DEFAULT_CHARSET = T.let(T.unsafe(nil), String)
Hanami::Action::Mime::DEFAULT_CONTENT_TYPE = T.let(T.unsafe(nil), String)
Hanami::Action::Mime::HTTP_ACCEPT = T.let(T.unsafe(nil), String)
Hanami::Action::Mime::HTTP_CONTENT_TYPE = T.let(T.unsafe(nil), String)

module Hanami::Action::Mime::InstanceMethods
  def initialize(*_arg0); end
end

Hanami::Action::Mime::MIME_TYPES = T.let(T.unsafe(nil), Hash)

class Hanami::Action::Mime::RequestMimeWeight
  include ::Comparable

  def initialize(mime, quality, index, format = T.unsafe(nil)); end

  def <=>(other); end
  def format; end
  def index; end
  def mime; end
  def priority; end
  def quality; end

  private

  def calculate_priority(mime); end
end

class Hanami::Action::Params < ::Hanami::Action::BaseParams
  include ::Hanami::Validations::Form
  include ::Hanami::Validations
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Validations::ClassMethods
  extend ::Hanami::Utils::ClassAttribute::ClassMethods
  extend ::Hanami::Validations::Form::ClassMethods

  def initialize(env); end

  def error_messages(error_set = T.unsafe(nil)); end
  def errors; end
  def raw; end
  def to_h; end
  def to_hash; end
  def valid?; end

  private

  def _params; end

  class << self
    def _base_rules; end
    def _messages; end
    def _messages=(_arg0); end
    def _messages_path; end
    def _messages_path=(_arg0); end
    def _namespace; end
    def _namespace=(_arg0); end
    def _predicates; end
    def _predicates=(_arg0); end
    def _predicates_module; end
    def _predicates_module=(_arg0); end
    def params(&blk); end
    def schema; end
    def schema=(_arg0); end
  end
end

class Hanami::Action::Params::Errors < ::SimpleDelegator
  def initialize(errors = T.unsafe(nil)); end

  def add(*args); end

  private

  def _nested_attribute(keys, key); end
end

module Hanami::Action::Rack
  mixes_in_class_methods ::Hanami::Action::Rack::ClassMethods

  protected

  def headers; end
  def parsed_request_body; end
  def request; end
  def request_id; end
  def response; end

  private

  def _send_file(response); end
  def body=(body); end
  def head?; end
  def request_method; end
  def send_file(path); end
  def status=(status); end
  def unsafe_send_file(path); end

  class << self
    def included(base); end
  end
end

Hanami::Action::Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

module Hanami::Action::Rack::Callable
  def call(env); end
end

module Hanami::Action::Rack::ClassMethods
  def params_class; end
  def rack_builder; end
  def use(middleware, *args, &block); end
end

Hanami::Action::Rack::DEFAULT_REQUEST_ID_LENGTH = T.let(T.unsafe(nil), Integer)
Hanami::Action::Rack::DEFAULT_RESPONSE_BODY = T.let(T.unsafe(nil), Array)
Hanami::Action::Rack::DEFAULT_RESPONSE_CODE = T.let(T.unsafe(nil), Integer)

module Hanami::Action::Rack::Errors
  class << self
    def _dump_exception(exception); end
    def set(env, exception); end
  end
end

Hanami::Action::Rack::Errors::RACK_ERRORS = T.let(T.unsafe(nil), String)
Hanami::Action::Rack::Errors::RACK_EXCEPTION = T.let(T.unsafe(nil), String)
Hanami::Action::Rack::FILE_SYSTEM_ROOT = T.let(T.unsafe(nil), Pathname)

class Hanami::Action::Rack::File
  def initialize(path, root); end

  def call(env); end
end

Hanami::Action::Rack::File::PATH_INFO = T.let(T.unsafe(nil), String)
Hanami::Action::Rack::HEAD = T.let(T.unsafe(nil), String)

module Hanami::Action::Rack::InstanceMethods
  def initialize(*_arg0); end
end

Hanami::Action::Rack::NOT_FOUND = T.let(T.unsafe(nil), Integer)
Hanami::Action::Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Hanami::Action::Rack::RESPONSE_BODY = T.let(T.unsafe(nil), Integer)
Hanami::Action::Rack::RESPONSE_CODE = T.let(T.unsafe(nil), Integer)
Hanami::Action::Rack::RESPONSE_HEADERS = T.let(T.unsafe(nil), Integer)
Hanami::Action::Rack::ROUTER_PARSED_BODY = T.let(T.unsafe(nil), String)
Hanami::Action::Rack::X_CASCADE = T.let(T.unsafe(nil), String)

module Hanami::Action::Redirect
  private

  def redirect_to(url, status: T.unsafe(nil)); end
end

Hanami::Action::Redirect::LOCATION = T.let(T.unsafe(nil), String)

class Hanami::Action::Request < ::Rack::Request
  def [](*_arg0); end
  def []=(*_arg0); end
  def content_type; end
  def cookies; end
  def delete_param(*_arg0); end
  def params; end
  def session; end
  def update_param(*_arg0); end
  def values_at(*_arg0); end
end

module Hanami::Action::Throwable
  mixes_in_class_methods ::Hanami::Action::Throwable::ClassMethods

  protected

  def halt(code, message = T.unsafe(nil)); end
  def status(code, message); end

  private

  def _exception_handler(exception); end
  def _handle_exception(exception); end
  def _reference_in_rack_errors(exception); end
  def _rescue; end

  class << self
    def included(base); end
  end
end

module Hanami::Action::Throwable::ClassMethods
  private

  def handle_exception(exception); end
end

module Hanami::Action::Validatable
  mixes_in_class_methods ::Hanami::Action::Validatable::ClassMethods

  class << self
    def included(base); end
  end
end

module Hanami::Action::Validatable::ClassMethods
  def params(klass = T.unsafe(nil), &blk); end
end

Hanami::Action::Validatable::PARAMS_CLASS_NAME = T.let(T.unsafe(nil), String)

module Hanami::Controller
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Utils::ClassAttribute::ClassMethods

  class << self
    def configuration; end
    def configuration=(_arg0); end
    def configure(&blk); end
    def dupe; end
    def duplicate(mod, controllers = T.unsafe(nil), &blk); end
    def load!; end
  end
end

class Hanami::Controller::Configuration
  def initialize; end

  def action_module(value = T.unsafe(nil)); end
  def cookies(options = T.unsafe(nil)); end
  def copy!(base); end
  def default_charset(charset = T.unsafe(nil)); end
  def default_headers(headers = T.unsafe(nil)); end
  def default_request_format(format = T.unsafe(nil)); end
  def default_response_format(format = T.unsafe(nil)); end
  def duplicate; end
  def exception_handler(exception); end
  def exception_handler_for(exception); end
  def format(hash); end
  def format_for(mime_type); end
  def handle_exception(exception); end
  def handle_exceptions(value = T.unsafe(nil)); end
  def handle_exceptions=(_arg0); end
  def handled_exception?(exception); end
  def load!; end
  def mime_type_for(format); end
  def mime_types; end
  def modules; end
  def prepare(&blk); end
  def public_directory(value = T.unsafe(nil)); end
  def reset!; end
  def restrict_mime_types!(mime_types); end
  def root_directory; end

  protected

  def _sort_handled_exceptions!; end
  def action_module=(_arg0); end
  def cookies=(_arg0); end
  def default_charset=(_arg0); end
  def default_headers=(_arg0); end
  def default_request_format=(_arg0); end
  def default_response_format=(_arg0); end
  def formats; end
  def formats=(_arg0); end
  def handled_exceptions; end
  def handled_exceptions=(_arg0); end
  def modules=(_arg0); end
  def public_directory=(_arg0); end

  class << self
    def for(base); end
  end
end

Hanami::Controller::Configuration::DEFAULT_ERROR_CODE = T.let(T.unsafe(nil), Integer)
Hanami::Controller::Configuration::DEFAULT_FORMATS = T.let(T.unsafe(nil), Hash)
Hanami::Controller::Configuration::DEFAULT_PUBLIC_DIRECTORY = T.let(T.unsafe(nil), String)
class Hanami::Controller::Error < ::StandardError; end
class Hanami::Controller::IllegalExposureError < ::Hanami::Controller::Error; end

class Hanami::Controller::MissingSessionError < ::Hanami::Controller::Error
  def initialize(session_method); end
end

class Hanami::Controller::UnknownFormatError < ::Hanami::Controller::Error
  def initialize(format); end
end

Hanami::Controller::VERSION = T.let(T.unsafe(nil), String)
Hanami::DEFAULT_PUBLIC_DIRECTORY = T.let(T.unsafe(nil), String)
module Hanami::Http; end

class Hanami::Http::Status
  class << self
    def for_code(code); end
    def message_for(code); end
  end
end

Hanami::Http::Status::ALL = T.let(T.unsafe(nil), Hash)
Hanami::VERSION = T.let(T.unsafe(nil), String)

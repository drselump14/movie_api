# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-system` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Dry
  class << self
    def AutoInject(container, options = T.unsafe(nil)); end
    def Equalizer(*keys, **options); end
  end
end

module Dry::System
  include ::Dry::Core::Constants

  class << self
    def providers; end
    def register_component(identifier, provider:, &block); end
    def register_provider(identifier, options); end
  end
end

module Dry::System::Components; end

class Dry::System::Components::Bootable
  def initialize(identifier, options = T.unsafe(nil), &block); end

  def after(event, &block); end
  def before(event, &block); end
  def boot?; end
  def boot_file; end
  def boot_path; end
  def config; end
  def configure(&block); end
  def container; end
  def container_boot_files; end
  def finalize; end
  def identifier; end
  def init; end
  def namespace; end
  def new(identifier, new_options = T.unsafe(nil)); end
  def options; end
  def settings(&block); end
  def start; end
  def statuses; end
  def stop; end
  def trigger(key, event); end
  def triggers; end
  def with(new_options); end

  private

  def block; end
  def configure!; end
  def lf_container; end
  def lifecycle; end
end

Dry::System::Components::Bootable::DEFAULT_FINALIZE = T.let(T.unsafe(nil), Proc)

class Dry::System::Components::Config
  def initialize; end

  def to_hash; end

  private

  def method_missing(meth, value = T.unsafe(nil)); end

  class << self
    def new(&block); end
  end
end

Dry::System::DEFAULT_SEPARATOR = T.let(T.unsafe(nil), String)
class Dry::System::DuplicatedComponentKeyError < ::ArgumentError; end
Dry::System::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::System::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::System::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::System::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::System::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::System::IDENTITY = T.let(T.unsafe(nil), Proc)

class Dry::System::Lifecycle < ::BasicObject
  def initialize(container, opts, &block); end

  def call(*triggers); end
  def component; end
  def config; end
  def configure(&block); end
  def container; end
  def init(&block); end
  def opts; end
  def register(*args, &block); end
  def settings(&block); end
  def start(&block); end
  def statuses; end
  def stop(&block); end
  def target; end
  def triggers; end
  def use(*names); end

  private

  def method_missing(meth, *args, &block); end
  def trigger!(name, &block); end

  class << self
    def cache; end
    def new(container, opts = T.unsafe(nil), &block); end
  end
end

Dry::System::PATH_SEPARATOR = T.let(T.unsafe(nil), String)

class Dry::System::PluginDependencyMissing < ::StandardError
  def initialize(plugin, message); end
end

class Dry::System::Provider
  def initialize(identifier, options); end

  def boot_file(name); end
  def boot_files; end
  def boot_path; end
  def component(name, options = T.unsafe(nil)); end
  def components; end
  def identifier; end
  def load_components; end
  def options; end
  def register_component(name, fn); end
end

class Dry::System::ProviderRegistry
  include ::Enumerable

  def initialize; end

  def [](identifier); end
  def each(&block); end
  def items; end
  def register(identifier, options); end
end

Dry::System::RB_EXT = T.let(T.unsafe(nil), String)
Dry::System::RB_GLOB = T.let(T.unsafe(nil), String)
Dry::System::Self = T.let(T.unsafe(nil), Proc)
module Dry::System::Settings; end

class Dry::System::Settings::Configuration < ::Dry::Struct
  include ::Dry::Equalizer::Methods

  class << self
    def load(root, env); end
    def setting(*args); end

    private

    def load_files(root, env); end
  end
end

class Dry::System::Settings::DSL < ::BasicObject
  def initialize(identifier, &block); end

  def call; end
  def identifier; end
  def key(name, type); end
  def schema; end
end

class Dry::System::Settings::FileLoader
  def call(root, env); end

  private

  def files(root, env); end
  def parser; end
end

class Dry::System::Settings::FileParser
  def call(file); end

  private

  def parse_line(line, hash); end
  def parse_value(value); end
end

Dry::System::Settings::FileParser::LINE = T.let(T.unsafe(nil), Regexp)
Dry::System::Undefined = T.let(T.unsafe(nil), Object)
Dry::System::WORD_REGEX = T.let(T.unsafe(nil), Regexp)

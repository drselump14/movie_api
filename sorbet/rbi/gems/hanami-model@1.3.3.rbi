# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hanami-model` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Hanami
  class << self
    def app; end
    def app?(app); end
    def boot; end
    def code_reloading?; end
    def configuration; end
    def configure(&blk); end
    def env; end
    def env?(*names); end
    def environment; end
    def logger; end
    def plugin(&blk); end
    def plugins; end
    def public_directory; end
    def root; end
  end
end

Hanami::DEFAULT_PUBLIC_DIRECTORY = T.let(T.unsafe(nil), String)

class Hanami::Entity
  def initialize(attributes = T.unsafe(nil)); end

  def ==(other); end
  def freeze; end
  def hash; end
  def id; end
  def method_missing(method_name, *_arg1); end
  def to_h; end
  def to_hash; end

  protected

  def attribute?(name); end

  private

  def attributes; end
  def respond_to_missing?(name, _include_all); end

  class << self
    def inherited(klass); end
  end
end

module Hanami::Entity::ClassMethods
  def attributes(type = T.unsafe(nil), &blk); end
  def schema; end
  def schema=(value); end
end

class Hanami::Entity::Schema
  def initialize(type = T.unsafe(nil), &blk); end

  def [](attributes); end
  def attribute?(name); end
  def call(attributes); end

  protected

  def schema; end
end

class Hanami::Entity::Schema::Definition
  def initialize(type = T.unsafe(nil), &blk); end

  def attribute?(name); end
  def call(attributes); end

  private

  def attributes; end
  def schema; end
end

class Hanami::Entity::Schema::Definition::Dsl
  def initialize(&blk); end

  def attribute(name, type); end
  def to_h; end

  class << self
    def build(type, &blk); end
  end
end

Hanami::Entity::Schema::Definition::Dsl::DEFAULT_TYPE = T.let(T.unsafe(nil), Symbol)
Hanami::Entity::Schema::Definition::Dsl::TYPES = T.let(T.unsafe(nil), Array)

class Hanami::Entity::Schema::Schemaless
  def initialize; end

  def attribute?(_name); end
  def call(attributes); end
end

module Hanami::Entity::Types
  include ::ROM::Types
  include ::Hanami::Model::Types
  extend ::Hanami::Model::Types::ClassMethods
end

module Hanami::Model
  class << self
    def config; end
    def configuration; end
    def configure(&block); end
    def container; end
    def disconnect; end
    def load!(&blk); end
    def loaded; end
    def loaded?; end
    def repositories; end
  end
end

class Hanami::Model::Association
  class << self
    def build(repository, target, subject); end
    def lookup(association); end
  end
end

module Hanami::Model::Associations; end

class Hanami::Model::Associations::BelongsTo
  def initialize(repository, source, target, subject, scope = T.unsafe(nil)); end

  def one; end
  def repository; end
  def scope; end
  def source; end
  def subject; end
  def target; end

  private

  def _build_scope; end
  def association; end
  def association_keys; end
  def container; end
  def foreign_key; end
  def primary_key; end
  def relation(name); end

  class << self
    def schema_type(entity); end
  end
end

class Hanami::Model::Associations::Dsl
  def initialize(repository, &blk); end

  def belongs_to(relation, *_arg1); end
  def has_many(relation, **args); end
  def has_one(relation, *_arg1); end
end

class Hanami::Model::Associations::HasMany
  def initialize(repository, source, target, subject, scope = T.unsafe(nil)); end

  def add(data); end
  def count; end
  def create(data); end
  def delete; end
  def each(&blk); end
  def map(&blk); end
  def remove(id); end
  def repository; end
  def scope; end
  def source; end
  def subject; end
  def target; end
  def to_a; end
  def where(condition); end

  private

  def __new__(new_scope); end
  def _build_scope; end
  def aggregate(name); end
  def associate(data); end
  def association(name); end
  def association_keys; end
  def command(target, relation, options = T.unsafe(nil)); end
  def container; end
  def entity; end
  def foreign_key; end
  def primary_key; end
  def relation(name); end
  def serialize(data); end
  def target_association; end
  def unassociate; end

  class << self
    def schema_type(entity); end
  end
end

class Hanami::Model::Associations::HasOne
  def initialize(repository, source, target, subject, scope = T.unsafe(nil)); end

  def add(data); end
  def create(data); end
  def delete; end
  def one; end
  def remove; end
  def replace(data); end
  def repository; end
  def scope; end
  def source; end
  def subject; end
  def target; end
  def update(data); end

  private

  def _build_scope; end
  def aggregate(name); end
  def associate(data); end
  def association_keys; end
  def command(target, relation, options = T.unsafe(nil)); end
  def container; end
  def entity; end
  def foreign_key; end
  def primary_key; end
  def relation(name); end
  def serialize(data); end

  class << self
    def schema_type(entity); end
  end
end

class Hanami::Model::Associations::ManyToMany
  def initialize(repository, source, target, subject, scope = T.unsafe(nil)); end

  def add(*data); end
  def count; end
  def delete; end
  def each(&blk); end
  def map(&blk); end
  def remove(target_id); end
  def repository; end
  def scope; end
  def source; end
  def subject; end
  def target; end
  def through; end
  def to_a; end
  def where(condition); end

  private

  def __new__(new_scope); end
  def _build_scope; end
  def associate(data); end
  def association; end
  def association_keys; end
  def command(target, relation, options = T.unsafe(nil)); end
  def container; end
  def relation(name); end
  def serialize(data); end
  def source_foreign_key; end
  def source_primary_key; end
  def target_foreign_key; end
  def target_primary_key; end

  class << self
    def schema_type(entity); end
  end
end

class Hanami::Model::CheckConstraintViolationError < ::Hanami::Model::ConstraintViolationError
  def initialize(message = T.unsafe(nil)); end
end

class Hanami::Model::Configuration
  def initialize(configurator); end

  def configure_gateway; end
  def connection; end
  def define_entities_mappings(container, repositories); end
  def define_mappings(root, &blk); end
  def entities; end
  def gateway; end
  def load!(repositories, &blk); end
  def logger; end
  def logger=(value); end
  def mappings; end
  def method_missing(method_name, *args, &blk); end
  def migrations; end
  def migrations_logger; end
  def register_entity(plural, singular, klass); end
  def rom; end
  def root; end
  def schema; end
  def url; end

  private

  def respond_to_missing?(method_name, include_all); end
end

class Hanami::Model::Configurator
  def _gateway; end
  def _logger; end
  def _migrations; end
  def _schema; end
  def backend; end
  def directory; end
  def migrations_logger(stream = T.unsafe(nil)); end
  def url; end

  private

  def adapter(backend, url); end
  def gateway(&blk); end
  def logger(stream, options = T.unsafe(nil)); end
  def migrations(path); end
  def path(path); end
  def schema(path); end

  class << self
    def build(&block); end
  end
end

class Hanami::Model::ConstraintViolationError < ::Hanami::Model::Error
  def initialize(message = T.unsafe(nil)); end
end

class Hanami::Model::DatabaseError < ::Hanami::Model::Error; end

class Hanami::Model::EntityName
  def initialize(name); end

  def to_s; end
  def underscore; end
end

Hanami::Model::EntityName::SUFFIX = T.let(T.unsafe(nil), Regexp)

class Hanami::Model::Error < ::StandardError
  class << self
    def for(exception); end
    def mapping; end
    def register(external, internal); end
  end
end

class Hanami::Model::ForeignKeyConstraintViolationError < ::Hanami::Model::ConstraintViolationError
  def initialize(message = T.unsafe(nil)); end
end

class Hanami::Model::InvalidCommandError < ::Hanami::Model::Error
  def initialize(message = T.unsafe(nil)); end
end

class Hanami::Model::MappedRelation < ::SimpleDelegator
  def initialize(relation); end

  def [](attribute); end

  class << self
    def mapper_name; end
  end
end

Hanami::Model::MappedRelation::MAPPER_NAME = T.let(T.unsafe(nil), Symbol)

class Hanami::Model::Mapping
  extend ::Transproc::Registry

  def initialize(&blk); end

  def attribute(name, options); end
  def model(entity); end
  def process(input); end
  def register_as(name); end
  def reverse?; end
  def t(name, *args); end
  def translate(attribute); end
end

class Hanami::Model::MissingPrimaryKeyError < ::Hanami::Model::Error; end

class Hanami::Model::NotNullConstraintViolationError < ::Hanami::Model::ConstraintViolationError
  def initialize(message = T.unsafe(nil)); end
end

module Hanami::Model::Plugins; end

module Hanami::Model::Plugins::Mapping
  mixes_in_class_methods ::Hanami::Model::Plugins::Mapping::ClassMethods

  class << self
    def included(klass); end
  end
end

module Hanami::Model::Plugins::Mapping::ClassMethods
  def build(relation, options = T.unsafe(nil)); end
end

class Hanami::Model::Plugins::Mapping::InputWithMapping < ::Hanami::Model::Plugins::WrappingInput
  def initialize(relation, input); end

  def [](value); end
end

module Hanami::Model::Plugins::Schema
  mixes_in_class_methods ::Hanami::Model::Plugins::Schema::ClassMethods

  class << self
    def included(klass); end
  end
end

module Hanami::Model::Plugins::Schema::ClassMethods
  def build(relation, options = T.unsafe(nil)); end
end

class Hanami::Model::Plugins::Schema::InputWithSchema < ::Hanami::Model::Plugins::WrappingInput
  def initialize(relation, input); end

  def [](value); end
end

module Hanami::Model::Plugins::Timestamps
  mixes_in_class_methods ::Hanami::Model::Plugins::Timestamps::ClassMethods

  class << self
    def included(klass); end
  end
end

module Hanami::Model::Plugins::Timestamps::ClassMethods
  def build(relation, options = T.unsafe(nil)); end
end

class Hanami::Model::Plugins::Timestamps::InputWithCreateTimestamp < ::Hanami::Model::Plugins::Timestamps::InputWithUpdateTimestamp
  protected

  def _touch(value, now); end
end

class Hanami::Model::Plugins::Timestamps::InputWithTimestamp < ::Hanami::Model::Plugins::WrappingInput
  def initialize(relation, input); end

  def [](value); end

  protected

  def _touch(_value); end

  private

  def timestamps?; end
end

Hanami::Model::Plugins::Timestamps::InputWithTimestamp::TIMESTAMPS = T.let(T.unsafe(nil), Array)

class Hanami::Model::Plugins::Timestamps::InputWithUpdateTimestamp < ::Hanami::Model::Plugins::Timestamps::InputWithTimestamp
  protected

  def _touch(value, now); end
end

class Hanami::Model::Plugins::WrappingInput
  def initialize(_relation, input); end
end

class Hanami::Model::RelationName < ::Hanami::Model::EntityName
  class << self
    def new(name); end
  end
end

module Hanami::Model::Types
  include ::ROM::Types
  extend ::ROM::Types::Methods

  mixes_in_class_methods ::Hanami::Model::Types::ClassMethods

  class << self
    def included(mod); end
  end
end

module Hanami::Model::Types::ClassMethods
  def Collection(type); end
  def Entity(type); end
end

module Hanami::Model::Types::Schema; end

class Hanami::Model::Types::Schema::CoercibleType < ::Dry::Types::Definition
  def call(value); end
  def coerce(value); end
  def object; end
  def valid?(value); end
end

class Hanami::Model::UniqueConstraintViolationError < ::Hanami::Model::ConstraintViolationError
  def initialize(message = T.unsafe(nil)); end
end

class Hanami::Model::UnknownAttributeError < ::Hanami::Model::Error; end

class Hanami::Model::UnknownDatabaseAdapterError < ::Hanami::Model::Error
  def initialize(url); end
end

class Hanami::Model::UnknownDatabaseTypeError < ::Hanami::Model::Error; end
Hanami::Model::VERSION = T.let(T.unsafe(nil), String)

class Hanami::Repository < ::ROM::Repository::Root
  def initialize; end

  def all; end
  def clear; end
  def command(*args, **opts, &block); end
  def find(id); end
  def first; end
  def last; end

  private

  def assoc(target, subject = T.unsafe(nil)); end

  class << self
    def associations(&blk); end
    def configuration; end
    def container; end
    def define_associations; end
    def define_mapping; end
    def define_relation; end
    def inherited(klass); end
    def load!; end
    def mapping(&blk); end
    def schema(&blk); end
  end
end

Hanami::Repository::COMMAND_PLUGINS = T.let(T.unsafe(nil), Array)

module Hanami::Repository::Commands
  def create(*args); end
  def delete(*args); end
  def update(*args); end
end

Hanami::VERSION = T.let(T.unsafe(nil), String)

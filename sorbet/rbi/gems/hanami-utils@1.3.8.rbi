# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hanami-utils` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

class Boolean; end

module Hanami
  class << self
    def app; end
    def app?(app); end
    def boot; end
    def code_reloading?; end
    def configuration; end
    def configure(&blk); end
    def env; end
    def env?(*names); end
    def environment; end
    def logger; end
    def plugin(&blk); end
    def plugins; end
    def public_directory; end
    def root; end
  end
end

Hanami::DEFAULT_PUBLIC_DIRECTORY = T.let(T.unsafe(nil), String)

module Hanami::Utils
  class << self
    def for_each_file_in(directory, &blk); end
    def jruby?; end
    def reload!(directory); end
    def require!(directory); end
    def rubinius?; end
  end
end

class Hanami::Utils::BasicObject < ::BasicObject
  def class; end
  def inspect; end
  def instance_of?(_arg0); end
  def is_a?(_arg0); end
  def kind_of?(_arg0); end
  def object_id; end
  def pretty_print(printer); end
  def respond_to?(method_name, include_all = T.unsafe(nil)); end

  private

  def __inspect; end
  def respond_to_missing?(_method_name, _include_all); end

  class << self
    def const_missing(name); end
  end
end

class Hanami::Utils::Blank
  class << self
    def blank?(object); end
    def filled?(object); end
  end
end

Hanami::Utils::Blank::STRING_MATCHER = T.let(T.unsafe(nil), Regexp)
module Hanami::Utils::Callbacks; end

class Hanami::Utils::Callbacks::Callback
  def initialize(callback); end

  def call(context, *args); end
  def callback; end
end

class Hanami::Utils::Callbacks::Chain
  def initialize; end

  def append(*callbacks, &block); end
  def freeze; end
  def prepend(*callbacks, &block); end
  def run(context, *args); end

  private

  def callables(callbacks, block); end
end

class Hanami::Utils::Callbacks::Factory
  class << self
    def fabricate(callback); end
  end
end

class Hanami::Utils::Callbacks::MethodCallback < ::Hanami::Utils::Callbacks::Callback
  def call(context, *args); end
  def eql?(other); end
  def hash; end
end

class Hanami::Utils::Class
  class << self
    def load(name, namespace = T.unsafe(nil)); end
    def load!(name, namespace = T.unsafe(nil)); end
    def load_from_pattern!(pattern, namespace = T.unsafe(nil)); end
    def tokenize(pattern); end
  end
end

Hanami::Utils::Class::TOKENIZE_REGEXP = T.let(T.unsafe(nil), Regexp)
Hanami::Utils::Class::TOKENIZE_SEPARATOR = T.let(T.unsafe(nil), String)

module Hanami::Utils::ClassAttribute
  mixes_in_class_methods ::Hanami::Utils::ClassAttribute::ClassMethods

  class << self
    def included(base); end
  end
end

module Hanami::Utils::ClassAttribute::ClassMethods
  def class_attribute(*attributes); end

  protected

  def inherited(subclass); end

  private

  def class_attributes; end
end

class Hanami::Utils::Deprecation
  def initialize(message); end

  private

  def caller_index; end
end

module Hanami::Utils::Duplicable
  class << self
    def dup(value, &blk); end
  end
end

module Hanami::Utils::Escape
  class << self
    def html(input); end
    def html_attribute(input); end
    def url(input, schemes = T.unsafe(nil)); end

    private

    def encode(input); end
    def encode_char(char, safe_chars = T.unsafe(nil)); end
    def hex_for_non_alphanumeric_code(input); end
  end
end

Hanami::Utils::Escape::DEFAULT_URL_SCHEMES = T.let(T.unsafe(nil), Array)
Hanami::Utils::Escape::HEX_BASE = T.let(T.unsafe(nil), Integer)
Hanami::Utils::Escape::HEX_CODES = T.let(T.unsafe(nil), Hash)
Hanami::Utils::Escape::HTML_ATTRIBUTE_SAFE_CHARS = T.let(T.unsafe(nil), Hash)
Hanami::Utils::Escape::HTML_CHARS = T.let(T.unsafe(nil), Hash)
Hanami::Utils::Escape::HTML_ENTITIES = T.let(T.unsafe(nil), Hash)
Hanami::Utils::Escape::LOW_HEX_CODE_LIMIT = T.let(T.unsafe(nil), Integer)
Hanami::Utils::Escape::NON_PRINTABLE_CHARS = T.let(T.unsafe(nil), Hash)
Hanami::Utils::Escape::REPLACEMENT_HEX = T.let(T.unsafe(nil), String)

class Hanami::Utils::Escape::SafeString < ::String
  def encode(*args); end
  def to_s; end
end

module Hanami::Utils::FileList
  class << self
    def [](*args); end
  end
end

Hanami::Utils::HANAMI_JRUBY = T.let(T.unsafe(nil), String)
Hanami::Utils::HANAMI_RUBINIUS = T.let(T.unsafe(nil), String)

class Hanami::Utils::Hash
  extend ::Transproc::Registry

  def initialize(hash = T.unsafe(nil), &blk); end

  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def deep_dup; end
  def deep_symbolize!; end
  def delete(key); end
  def eql?(other); end
  def hash; end
  def inspect; end
  def keys; end
  def method_missing(method_name, *args, &blk); end
  def stringify!; end
  def symbolize!; end
  def to_a; end
  def to_h; end
  def to_hash; end

  private

  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  class << self
    def deep_dup(input); end
    def deep_serialize(input); end
    def deep_stringify(input); end
    def deep_symbolize(input); end
    def stringify(input); end
    def symbolize(input); end
  end
end

Hanami::Utils::Hash::DUPLICATE_LOGIC = T.let(T.unsafe(nil), Proc)

class Hanami::Utils::IO
  class << self
    def silence_warnings; end
  end
end

module Hanami::Utils::Inflector
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Utils::ClassAttribute::ClassMethods

  class << self
    def add_to_inflecto(singular, plural); end
    def exception(singular, plural); end
    def inflections(&blk); end
    def pluralize(string); end
    def plurals; end
    def plurals=(_arg0); end
    def singularize(string); end
    def singulars; end
    def singulars=(_arg0); end
    def uncountable(*words); end
  end
end

Hanami::Utils::Inflector::A = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::CH = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::CHES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::EAUX = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::ES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::F = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::I = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::ICE = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::ICES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::IDES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::IES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::IFE = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::IS = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::IVES = T.let(T.unsafe(nil), String)

class Hanami::Utils::Inflector::IrregularRules
  def initialize(rules); end

  def ===(other); end
  def add(key, value); end
  def apply(string); end

  private

  def extract_last_alphanumeric_token(string); end
end

Hanami::Utils::Inflector::MA = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::MATA = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::MEN = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::MINA = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::NA = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::NON = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::O = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::OES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::OUSE = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::RSE = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::RSES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::S = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::SES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::SSES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::TA = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::UM = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::US = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::USES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::VES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::X = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::XES = T.let(T.unsafe(nil), String)
Hanami::Utils::Inflector::Y = T.let(T.unsafe(nil), String)

module Hanami::Utils::Kernel
  class << self
    def Array(arg); end
    def BigDecimal(arg, precision = T.unsafe(nil)); end
    def Boolean(arg); end
    def Date(arg); end
    def DateTime(arg); end
    def Float(arg); end
    def Hash(arg); end
    def Integer(arg); end
    def Pathname(arg); end
    def Set(arg); end
    def String(arg); end
    def Symbol(arg); end
    def Time(arg); end
    def numeric?(arg); end

    private

    def inspect_type_error(arg); end
  end
end

Hanami::Utils::Kernel::BOOLEAN_FALSE_STRING = T.let(T.unsafe(nil), String)
Hanami::Utils::Kernel::BOOLEAN_TRUE_INTEGER = T.let(T.unsafe(nil), Integer)
Hanami::Utils::Kernel::NUMERIC_MATCHER = T.let(T.unsafe(nil), Regexp)

class Hanami::Utils::LoadPaths
  def initialize(*paths); end

  def <<(*paths); end
  def ==(other); end
  def each; end
  def freeze; end
  def push(*paths); end

  protected

  def paths; end

  private

  def initialize_copy(original); end
  def realpath(path); end
end

class Hanami::Utils::PathPrefix < ::Hanami::Utils::String
  def initialize(string = T.unsafe(nil), separator = T.unsafe(nil)); end

  def join(*strings); end
  def relative_join(strings, separator = T.unsafe(nil)); end

  protected

  def absolute!; end
  def absolute?; end
  def relative!; end

  private

  def separator; end
end

Hanami::Utils::PathPrefix::DEFAULT_SEPARATOR = T.let(T.unsafe(nil), String)

class Hanami::Utils::String
  extend ::Transproc::Registry
  extend ::Transproc::Composer

  def initialize(string); end

  def ==(other); end
  def capitalize; end
  def classify; end
  def dasherize; end
  def demodulize; end
  def eql?(other); end
  def gsub(pattern, replacement = T.unsafe(nil), &blk); end
  def hash; end
  def method_missing(method_name, *args, &blk); end
  def namespace; end
  def pluralize; end
  def rsub(pattern, replacement); end
  def scan(pattern, &blk); end
  def singularize; end
  def split(pattern, limit = T.unsafe(nil)); end
  def titleize; end
  def to_s; end
  def to_str; end
  def tokenize; end
  def underscore; end

  private

  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  class << self
    def bind(value, binding, fun); end
    def capitalize(input); end
    def classify(input); end
    def dasherize(input); end
    def demodulize(input); end
    def namespace(input); end
    def pluralize(input); end
    def rsub(input, pattern, replacement); end
    def singularize(input); end
    def titleize(input); end
    def transform(input, *transformations); end
    def underscore(input); end
  end
end

Hanami::Utils::String::CAPITALIZE_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Utils::String::CLASSIFY_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Utils::String::CLASSIFY_WORD_SEPARATOR = T.let(T.unsafe(nil), Regexp)
Hanami::Utils::String::DASHERIZE_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Utils::String::EMPTY_STRING = T.let(T.unsafe(nil), String)
Hanami::Utils::String::NAMESPACE_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Utils::String::TITLEIZE_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Utils::String::TOKENIZE_REGEXP = T.let(T.unsafe(nil), Regexp)
Hanami::Utils::String::TOKENIZE_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Utils::String::UNDERSCORE_DIVISION_TARGET = T.let(T.unsafe(nil), String)
Hanami::Utils::String::UNDERSCORE_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Utils::VERSION = T.let(T.unsafe(nil), String)
Hanami::VERSION = T.let(T.unsafe(nil), String)

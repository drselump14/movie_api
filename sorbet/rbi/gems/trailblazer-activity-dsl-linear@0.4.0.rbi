# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-activity-dsl-linear` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Trailblazer
  class << self
    def Context(wrapped_options, mutable_options = T.unsafe(nil), context_options = T.unsafe(nil)); end
    def Operation(options); end
    def Option(proc); end
  end
end

class Trailblazer::Activity
  def initialize(schema); end

  def [](*key); end
  def call(args, **circuit_options); end
  def inspect; end
  def to_h; end

  class << self
    def End(semantic); end
    def FastTrack(options); end
    def Output(signal, semantic); end
    def Path(options); end
    def Railway(options); end
  end
end

module Trailblazer::Activity::DSL; end

module Trailblazer::Activity::DSL::Linear
  include ::Trailblazer::Activity::DSL::Linear::Helper
  extend ::Trailblazer::Activity::DSL::Linear::Helper::ClassMethods

  private

  def Merge(old_seq, new_seq, end_id: T.unsafe(nil)); end
  def strip_start_and_ends(seq, end_id:); end

  class << self
    def Merge(old_seq, new_seq, end_id: T.unsafe(nil)); end
    def VariableMapping(input: T.unsafe(nil), output: T.unsafe(nil), output_with_outer_ctx: T.unsafe(nil)); end
    def strip_start_and_ends(seq, end_id:); end
  end
end

module Trailblazer::Activity::DSL::Linear::Compiler
  private

  def call(sequence, find_stops: T.unsafe(nil), find_start: T.unsafe(nil)); end
  def find_connections(seq_row, strategies, sequence); end
  def find_start_task_ids(intermediate_wiring); end
  def find_stop_task_ids(intermediate_wiring); end

  class << self
    def call(sequence, find_stops: T.unsafe(nil), find_start: T.unsafe(nil)); end
    def find_connections(seq_row, strategies, sequence); end
    def find_start_task_ids(intermediate_wiring); end
    def find_stop_task_ids(intermediate_wiring); end
  end
end

module Trailblazer::Activity::DSL::Linear::DSL
  private

  def apply_adds_from_dsl(sequence, sequence_insert:, adds:, **options); end
  def insert_task(sequence, sequence_insert:, **options); end

  class << self
    def apply_adds_from_dsl(sequence, sequence_insert:, adds:, **options); end
    def insert_task(sequence, sequence_insert:, **options); end
  end
end

module Trailblazer::Activity::DSL::Linear::Helper
  mixes_in_class_methods ::Trailblazer::Activity::DSL::Linear::Helper::ClassMethods

  class << self
    def included(base); end
  end
end

module Trailblazer::Activity::DSL::Linear::Helper::ClassMethods
  extend ::Forwardable

  def End(semantic); end
  def Id(id); end
  def Model(*args, &block); end
  def Nested(*args, &block); end
  def Output(signal, semantic = T.unsafe(nil)); end
  def Path(track_color: T.unsafe(nil), connect_to: T.unsafe(nil), before: T.unsafe(nil), **options, &block); end
  def Rescue(*args, &block); end
  def Subprocess(activity, patch: T.unsafe(nil)); end
  def Track(color, wrap_around: T.unsafe(nil)); end
  def Wrap(*args, &block); end
  def end_id(_end); end
  def normalize(options, local_keys); end

  private

  def connect_for_sequence(sequence, connect_to:); end
end

module Trailblazer::Activity::DSL::Linear::Helper::ClassMethods::Patch
  private

  def call(activity, path, customization); end
  def customize(activity, options:); end

  class << self
    def call(activity, path, customization); end
    def customize(activity, options:); end
  end
end

Trailblazer::Activity::DSL::Linear::Helper::Contract = Trailblazer::Macro::Contract

class Trailblazer::Activity::DSL::Linear::Helper::Extension < ::Struct
  def call(*args, &block); end
  def callable; end
  def callable=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::DSL::Linear::Helper::Id < ::Struct
  def value; end
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::DSL::Linear::Helper::OutputSemantic < ::Struct
  def value; end
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

Trailblazer::Activity::DSL::Linear::Helper::Policy = Trailblazer::Macro::Policy

class Trailblazer::Activity::DSL::Linear::Helper::Track < ::Struct
  def adds; end
  def adds=(_); end
  def color; end
  def color=(_); end
  def options; end
  def options=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Trailblazer::Activity::DSL::Linear::Insert
  private

  def Append(sequence, new_rows, insert_id); end
  def Delete(sequence, _, insert_id); end
  def Prepend(sequence, new_rows, insert_id); end
  def Replace(sequence, new_rows, insert_id); end
  def find(sequence, insert_id); end
  def find_index(sequence, insert_id); end

  class << self
    def Append(sequence, new_rows, insert_id); end
    def Delete(sequence, _, insert_id); end
    def Prepend(sequence, new_rows, insert_id); end
    def Replace(sequence, new_rows, insert_id); end
    def find(sequence, insert_id); end
    def find_index(sequence, insert_id); end
  end
end

module Trailblazer::Activity::DSL::Linear::Normalizer
  private

  def activity_normalizer(sequence); end
  def add_end(end_event, magnetic_to:, id:); end
  def cleanup_options(_arg0, *_arg1); end
  def compile_wirings(_arg0, *_arg1); end
  def inherit_option(_arg0, *_arg1); end
  def input_output_dsl(_arg0, *_arg1); end
  def merge_normalizer_options(_arg0, *_arg1); end
  def merge_user_options(_arg0, *_arg1); end
  def normalize_connections_from_dsl(_arg0, *_arg1); end
  def normalize_context(_arg0, *_arg1); end
  def normalize_id(_arg0, **_arg1); end
  def normalize_outputs_from_dsl(_arg0, *_arg1); end
  def normalize_override(_arg0, *_arg1); end
  def normalize_step_interface(_arg0, *_arg1); end
  def output_to_id(ctx, output, target); end
  def output_to_track(ctx, output, track); end
  def wrap_task_with_step_interface(_arg0, **_arg1); end

  class << self
    def activity_normalizer(sequence); end
    def add_end(end_event, magnetic_to:, id:); end
    def cleanup_options(_arg0, *_arg1); end
    def compile_wirings(_arg0, *_arg1); end
    def inherit_option(_arg0, *_arg1); end
    def input_output_dsl(_arg0, *_arg1); end
    def merge_normalizer_options(_arg0, *_arg1); end
    def merge_user_options(_arg0, *_arg1); end
    def normalize_connections_from_dsl(_arg0, *_arg1); end
    def normalize_context(_arg0, *_arg1); end
    def normalize_id(_arg0, **_arg1); end
    def normalize_outputs_from_dsl(_arg0, *_arg1); end
    def normalize_override(_arg0, *_arg1); end
    def normalize_step_interface(_arg0, *_arg1); end
    def output_to_id(ctx, output, target); end
    def output_to_track(ctx, output, track); end
    def wrap_task_with_step_interface(_arg0, **_arg1); end
  end
end

module Trailblazer::Activity::DSL::Linear::Search
  private

  def ById(output, id); end
  def Forward(output, target_color); end
  def Noop(output); end
  def WrapAround(output, target_color); end
  def find_in_range(range, target_color); end

  class << self
    def ById(output, id); end
    def Forward(output, target_color); end
    def Noop(output); end
    def WrapAround(output, target_color); end
    def find_in_range(range, target_color); end
  end
end

class Trailblazer::Activity::DSL::Linear::Sequence < ::Array
  class << self
    def apply_adds(sequence, adds); end
    def create_row(task:, magnetic_to:, wirings:, **options); end
    def insert_row(sequence, row:, insert:); end
  end
end

class Trailblazer::Activity::DSL::Linear::Sequence::IndexError < ::IndexError
  def initialize(sequence, step_id); end

  def step_id; end
end

class Trailblazer::Activity::DSL::Linear::State
  def initialize(normalizers:, initial_sequence:, fields: T.unsafe(nil), **normalizer_options); end

  def copy; end
  def to_h; end
  def update_options(fields); end
  def update_sequence(&block); end
end

class Trailblazer::Activity::DSL::Linear::State::Normalizer
  def initialize(normalizer_sequences); end

  def call(name, *args); end
  def compile_normalizer(normalizer_sequence); end
end

module Trailblazer::Activity::DSL::Linear::Strategy
  def Path(**options, &block); end
  def call(args, **circuit_options); end
  def inherited(inheriter); end
  def initialize!(state); end
  def invoke(*args); end
  def to_h; end

  private

  def forward_block(args, block); end
  def merge!(activity); end
  def recompile_activity!(seq); end
  def recompile_activity_for(type, *args, &block); end
  def step(*args, &block); end

  class << self
    def task_for!(state, type, task, options = T.unsafe(nil), &block); end
  end
end

class Trailblazer::Activity::DSL::Linear::Strategy::BlockProxy < ::Struct
  def block; end
  def block=(_); end
  def options; end
  def options=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Trailblazer::Activity::DSL::Linear::VariableMapping
  private

  def default_input; end
  def default_output; end
  def filter_for(filter); end
  def output_option_for(option, pass_outer_ctx); end

  class << self
    def default_input; end
    def default_output; end
    def filter_for(filter); end
    def output_option_for(option, pass_outer_ctx); end
  end
end

module Trailblazer::Activity::DSL::Linear::VariableMapping::DSL
  class << self
    def filter_from_dsl(map); end
    def hash_for(ary); end
  end
end

module Trailblazer::Activity::DSL::Linear::VariableMapping::Input; end

class Trailblazer::Activity::DSL::Linear::VariableMapping::Input::Scoped
  def initialize(filter); end

  def call(_arg0, **circuit_options); end
end

module Trailblazer::Activity::DSL::Linear::VariableMapping::Output; end

class Trailblazer::Activity::DSL::Linear::VariableMapping::Output::Unscoped
  def initialize(filter); end

  def call(new_ctx, _arg1, **circuit_options); end
  def call_filter(new_ctx, _arg1, **circuit_options); end
end

class Trailblazer::Activity::DSL::Linear::VariableMapping::Output::Unscoped::WithOuterContext < ::Trailblazer::Activity::DSL::Linear::VariableMapping::Output::Unscoped
  def call_filter(new_ctx, _arg1, **circuit_options); end
end

class Trailblazer::Activity::FastTrack
  include ::Trailblazer::Activity::DSL::Linear::Helper
  extend ::Trailblazer::Activity::DSL::Linear::Helper::ClassMethods
  extend ::Trailblazer::Activity::DSL::Linear::Strategy

  class << self
    private

    def fail(*args, &block); end
    def pass(*args, &block); end
  end
end

module Trailblazer::Activity::FastTrack::DSL
  private

  def fail_fast_option(_arg0, *_arg1); end
  def fail_fast_option_for_fail(_arg0, *_arg1); end
  def fast_track_option(_arg0, *_arg1); end
  def initial_sequence(initial_sequence:, fail_fast_end: T.unsafe(nil), pass_fast_end: T.unsafe(nil), **_o); end
  def merge_connections_for(ctx, options, option_name, semantic, magnetic_to = T.unsafe(nil)); end
  def merge_outputs_for(ctx, outputs); end
  def normalizer; end
  def normalizer_for_fail; end
  def normalizer_for_pass; end
  def pass_fast_option(_arg0, *_arg1); end
  def pass_fast_option_for_pass(_arg0, *_arg1); end
  def step_options(sequence); end

  class << self
    def OptionsForState(normalizers: T.unsafe(nil), **options); end
    def fail_fast_option(_arg0, *_arg1); end
    def fail_fast_option_for_fail(_arg0, *_arg1); end
    def fast_track_option(_arg0, *_arg1); end
    def initial_sequence(initial_sequence:, fail_fast_end: T.unsafe(nil), pass_fast_end: T.unsafe(nil), **_o); end
    def merge_connections_for(ctx, options, option_name, semantic, magnetic_to = T.unsafe(nil)); end
    def merge_outputs_for(ctx, outputs); end
    def normalizer; end
    def normalizer_for_fail; end
    def normalizer_for_pass; end
    def pass_fast_option(_arg0, *_arg1); end
    def pass_fast_option_for_pass(_arg0, *_arg1); end
    def step_options(sequence); end
  end
end

Trailblazer::Activity::FastTrack::DSL::Normalizers = T.let(T.unsafe(nil), Trailblazer::Activity::DSL::Linear::State::Normalizer)
class Trailblazer::Activity::FastTrack::FailFast < ::Trailblazer::Activity::Signal; end
Trailblazer::Activity::FastTrack::Linear = Trailblazer::Activity::DSL::Linear
class Trailblazer::Activity::FastTrack::PassFast < ::Trailblazer::Activity::Signal; end

class Trailblazer::Activity::NodeAttributes < ::Struct
  def data; end
  def data=(_); end
  def id; end
  def id=(_); end
  def outputs; end
  def outputs=(_); end
  def task; end
  def task=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::Output < ::Struct
  def semantic; end
  def semantic=(_); end
  def signal; end
  def signal=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::Path
  include ::Trailblazer::Activity::DSL::Linear::Helper
  extend ::Trailblazer::Activity::DSL::Linear::Helper::ClassMethods
  extend ::Trailblazer::Activity::DSL::Linear::Strategy
end

module Trailblazer::Activity::Path::DSL
  private

  def append_end(sequence, **options); end
  def append_end_options(task:, magnetic_to:, id:, append_to: T.unsafe(nil)); end
  def initial_sequence(track_name:, end_task:, end_id:); end
  def merge_path_connections(_arg0, *_arg1); end
  def merge_path_outputs(_arg0, *_arg1); end
  def normalize_magnetic_to(_arg0, *_arg1); end
  def normalize_sequence_insert(_arg0, *_arg1); end
  def normalizer; end
  def prepend_step_options(sequence); end
  def prepend_to_path(sequence, steps, insertion_method = T.unsafe(nil), insert_id = T.unsafe(nil)); end
  def raise_on_duplicate_id(_arg0, *_arg1); end
  def sequence_insert_options; end
  def start_sequence(track_name:); end
  def unary_connections(track_name: T.unsafe(nil)); end
  def unary_outputs; end

  class << self
    def OptionsForState(normalizers: T.unsafe(nil), track_name: T.unsafe(nil), end_task: T.unsafe(nil), end_id: T.unsafe(nil), **options); end
    def append_end(sequence, **options); end
    def append_end_options(task:, magnetic_to:, id:, append_to: T.unsafe(nil)); end
    def initial_sequence(track_name:, end_task:, end_id:); end
    def merge_path_connections(_arg0, *_arg1); end
    def merge_path_outputs(_arg0, *_arg1); end
    def normalize_magnetic_to(_arg0, *_arg1); end
    def normalize_sequence_insert(_arg0, *_arg1); end
    def normalizer; end
    def prepend_step_options(sequence); end
    def prepend_to_path(sequence, steps, insertion_method = T.unsafe(nil), insert_id = T.unsafe(nil)); end
    def raise_on_duplicate_id(_arg0, *_arg1); end
    def sequence_insert_options; end
    def start_sequence(track_name:); end
    def unary_connections(track_name: T.unsafe(nil)); end
    def unary_outputs; end
  end
end

Trailblazer::Activity::Path::DSL::Linear = Trailblazer::Activity::DSL::Linear
Trailblazer::Activity::Path::DSL::Normalizers = T.let(T.unsafe(nil), Trailblazer::Activity::DSL::Linear::State::Normalizer)

class Trailblazer::Activity::Path::DSL::State < ::Trailblazer::Activity::DSL::Linear::State
  def step(*args); end
end

class Trailblazer::Activity::Railway
  include ::Trailblazer::Activity::DSL::Linear::Helper
  extend ::Trailblazer::Activity::DSL::Linear::Helper::ClassMethods
  extend ::Trailblazer::Activity::DSL::Linear::Strategy

  class << self
    private

    def fail(*args, &block); end
    def pass(*args, &block); end
  end
end

module Trailblazer::Activity::Railway::DSL
  private

  def failure_connections; end
  def failure_outputs; end
  def initial_sequence(failure_end:, initial_sequence:, **path_options); end
  def normalize_path_connections(_arg0, *_arg1); end
  def normalize_path_outputs(_arg0, *_arg1); end
  def normalizer; end
  def normalizer_for_fail; end
  def normalizer_for_pass; end
  def step_options(sequence); end

  class << self
    def OptionsForState(normalizers: T.unsafe(nil), failure_end: T.unsafe(nil), **options); end
    def failure_connections; end
    def failure_outputs; end
    def initial_sequence(failure_end:, initial_sequence:, **path_options); end
    def normalize_path_connections(_arg0, *_arg1); end
    def normalize_path_outputs(_arg0, *_arg1); end
    def normalizer; end
    def normalizer_for_fail; end
    def normalizer_for_pass; end
    def step_options(sequence); end
  end
end

module Trailblazer::Activity::Railway::DSL::Fail
  private

  def connect_success_to_failure(_arg0, *_arg1); end
  def merge_magnetic_to(_arg0, *_arg1); end

  class << self
    def connect_success_to_failure(_arg0, *_arg1); end
    def merge_magnetic_to(_arg0, *_arg1); end
  end
end

Trailblazer::Activity::Railway::DSL::Linear = Trailblazer::Activity::DSL::Linear
Trailblazer::Activity::Railway::DSL::Normalizers = T.let(T.unsafe(nil), Trailblazer::Activity::DSL::Linear::State::Normalizer)

module Trailblazer::Activity::Railway::DSL::Pass
  private

  def connect_failure_to_success(_arg0, *_arg1); end

  class << self
    def connect_failure_to_success(_arg0, *_arg1); end
  end
end

class Trailblazer::Activity::Railway::DSL::State < ::Trailblazer::Activity::Path::DSL::State
  def fail(*args); end
  def pass(*args); end
end

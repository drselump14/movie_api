# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rom-mapper` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module ROM
  include ::Dry::Core::Constants
  extend ::ROM::Global

  class << self
    def container(*args, &block); end
  end
end

class ROM::AdapterLoadError < ::StandardError; end
class ROM::CommandError < ::StandardError; end
class ROM::DuplicateConfigurationError < ::StandardError; end
class ROM::DuplicateContainerError < ::StandardError; end
ROM::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ROM::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
ROM::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
ROM::EMPTY_SET = T.let(T.unsafe(nil), Set)
ROM::EMPTY_STRING = T.let(T.unsafe(nil), String)
class ROM::EnvAlreadyFinalizedError < ::StandardError; end

class ROM::Header
  include ::Enumerable
  include ::Dry::Core::Equalizer::Methods

  def initialize(attributes, options = T.unsafe(nil)); end

  def [](name); end
  def aliased?; end
  def attributes; end
  def combined; end
  def copy_keys; end
  def each; end
  def keys; end
  def mapping; end
  def model; end
  def non_primitives; end
  def pop_keys; end
  def postprocessed; end
  def preprocessed; end
  def primitives; end
  def reject_keys; end
  def tuple_keys; end
  def wraps; end

  private

  def by_type(*types); end
  def initialize_mapping; end
  def initialize_pop_keys; end
  def initialize_tuple_keys; end

  class << self
    def coerce(input, options = T.unsafe(nil)); end
  end
end

class ROM::Header::Array < ::ROM::Header::Embedded; end

class ROM::Header::Attribute
  include ::Dry::Core::Equalizer::Methods

  def initialize(name, meta); end

  def aliased?; end
  def key; end
  def mapping; end
  def meta; end
  def name; end
  def type; end
  def typed?; end
  def union?; end

  class << self
    def [](meta); end
    def coerce(input); end
  end
end

class ROM::Header::Combined < ::ROM::Header::Embedded; end

class ROM::Header::Embedded < ::ROM::Header::Attribute
  def initialize(*_arg0); end

  def header; end
  def pop_keys; end
  def tuple_keys; end
end

class ROM::Header::Exclude < ::ROM::Header::Attribute; end
class ROM::Header::Fold < ::ROM::Header::Array; end
class ROM::Header::Group < ::ROM::Header::Array; end
class ROM::Header::Hash < ::ROM::Header::Embedded; end
ROM::Header::TYPE_MAP = T.let(T.unsafe(nil), Hash)
class ROM::Header::Unfold < ::ROM::Header::Array; end
class ROM::Header::Ungroup < ::ROM::Header::Array; end
class ROM::Header::Unwrap < ::ROM::Header::Hash; end
class ROM::Header::Wrap < ::ROM::Header::Hash; end
ROM::IDENTITY = T.let(T.unsafe(nil), Proc)
class ROM::InvalidOptionKeyError < ::StandardError; end
class ROM::InvalidOptionValueError < ::StandardError; end
class ROM::KeyMissing < ::ROM::CommandError; end

class ROM::Mapper
  include ::Dry::Core::Constants
  include ::ROM::Mapper::DSL
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::ROM::Mapper::DSL::ClassMethods

  def initialize(header, processor = T.unsafe(nil)); end

  def call(relation); end
  def header; end
  def model; end
  def transformers; end

  class << self
    def build(header = T.unsafe(nil), processor = T.unsafe(nil)); end
    def headers(header); end
    def processors; end
    def register_processor(processor); end
    def registry(descendants); end
  end
end

class ROM::Mapper::AttributeDSL
  include ::ROM::Mapper::ModelDSL

  def initialize(attributes, options); end

  def attribute(name, options = T.unsafe(nil), &block); end
  def attributes; end
  def combine(name, options, &block); end
  def copy_keys; end
  def embedded(name, options, &block); end
  def exclude(name); end
  def fold(*args, &block); end
  def group(*args, &block); end
  def header; end
  def options; end
  def prefix(value = T.unsafe(nil)); end
  def prefix_separator(value = T.unsafe(nil)); end
  def reject_keys; end
  def step(options = T.unsafe(nil), &block); end
  def steps; end
  def symbolize_keys; end
  def unfold(name, options = T.unsafe(nil)); end
  def ungroup(*args, &block); end
  def unwrap(*args, &block); end
  def wrap(*args, &block); end

  private

  def add_attribute(name, options); end
  def attributes_from_block(name, options, &block); end
  def attributes_from_hash(hash, options); end
  def attributes_from_mapper(mapper, name, options); end
  def dsl(name_or_attrs, options, &block); end
  def ensure_mapper_configuration(method_name, args, block_present); end
  def new(options, &block); end
  def remove(*names); end
  def with_attr_options(name, options = T.unsafe(nil)); end
  def with_name_or_options(*args); end
end

module ROM::Mapper::DSL
  mixes_in_class_methods ::ROM::Mapper::DSL::ClassMethods

  class << self
    def included(klass); end
  end
end

module ROM::Mapper::DSL::ClassMethods
  def base_relation; end
  def header; end
  def inherited(klass); end
  def use(plugin, options = T.unsafe(nil)); end

  private

  def attributes; end
  def dsl; end
  def method_missing(name, *args, &block); end
  def options; end
  def respond_to_missing?(name, _include_private = T.unsafe(nil)); end
end

ROM::Mapper::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ROM::Mapper::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
ROM::Mapper::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
ROM::Mapper::EMPTY_SET = T.let(T.unsafe(nil), Set)
ROM::Mapper::EMPTY_STRING = T.let(T.unsafe(nil), String)
ROM::Mapper::IDENTITY = T.let(T.unsafe(nil), Proc)

module ROM::Mapper::ModelDSL
  def attributes; end
  def builder; end
  def klass; end
  def model(options = T.unsafe(nil)); end

  private

  def build_class; end
end

ROM::Mapper::ModelDSL::DEFAULT_TYPE = T.let(T.unsafe(nil), Symbol)
ROM::Mapper::Self = T.let(T.unsafe(nil), Proc)
ROM::Mapper::Undefined = T.let(T.unsafe(nil), Object)
class ROM::MapperMisconfiguredError < ::StandardError; end
class ROM::MapperMissingError < ::StandardError; end
class ROM::MissingAdapterIdentifierError < ::StandardError; end

class ROM::ModelBuilder
  def initialize(options = T.unsafe(nil)); end

  def call(attrs); end
  def const_name; end
  def define_const; end
  def klass; end
  def name; end
  def namespace; end

  class << self
    def [](type); end
    def call(*args); end
  end
end

class ROM::ModelBuilder::PORO < ::ROM::ModelBuilder
  def define_class(attrs); end
end

class ROM::NoRelationError < ::StandardError; end

class ROM::Processor
  class << self
    def build; end
    def inherited(processor); end
  end
end

class ROM::Processor::Transproc < ::ROM::Processor
  include ::Transproc::Composer

  def initialize(mapper, header); end

  def header; end
  def mapper; end
  def mapping; end
  def model; end
  def row_proc; end
  def to_transproc; end

  private

  def combined_args(attribute); end
  def initialize_row_proc; end
  def new(*args); end
  def process_header_keys(ops); end
  def row_proc_from(attribute); end
  def t(*args); end
  def visit(attribute, *args); end
  def visit_array(attribute); end
  def visit_attribute(attribute); end
  def visit_combined(attribute); end
  def visit_exclude(attribute); end
  def visit_fold(attribute, preprocess = T.unsafe(nil)); end
  def visit_group(attribute, preprocess = T.unsafe(nil)); end
  def visit_hash(attribute); end
  def visit_unfold(attribute, preprocess = T.unsafe(nil)); end
  def visit_ungroup(attribute, preprocess = T.unsafe(nil)); end
  def visit_unwrap(attribute); end
  def visit_wrap(attribute); end
  def with_row_proc(attribute); end

  class << self
    def build(mapper, header); end
  end
end

module ROM::Processor::Transproc::Functions
  extend ::Transproc::Registry

  class << self
    def filter_empty(arr); end
    def identity(tuple); end
    def inject_union_value(tuple, name, keys, coercer); end
  end
end

ROM::Processor::Transproc::Functions::INVALID_INJECT_UNION_VALUE = T.let(T.unsafe(nil), String)
class ROM::RelationAlreadyDefinedError < ::StandardError; end
ROM::Self = T.let(T.unsafe(nil), Proc)
class ROM::TupleCountMismatchError < ::ROM::CommandError; end
ROM::Undefined = T.let(T.unsafe(nil), Object)
class ROM::UnknownPluginError < ::StandardError; end
class ROM::UnsupportedRelationError < ::StandardError; end
ROM::VERSION = T.let(T.unsafe(nil), String)

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-initializer` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Dry
  class << self
    def AutoInject(container, options = T.unsafe(nil)); end
    def Equalizer(*keys, **options); end
  end
end

module Dry::Initializer
  extend ::Dry::Initializer::ClassDSL

  def option(*args); end
  def param(*args); end

  private

  def __initializer_builder__(**settings); end
  def __initializer_mixin__; end
  def inherited(klass); end
end

class Dry::Initializer::Attribute
  def initialize(options); end

  def ==(other); end
  def coercer; end
  def default; end
  def getter; end
  def optional; end
  def postsetter; end
  def reader; end
  def source; end
  def target; end

  private

  def coercer_hash(type); end
  def default_hash(type); end
  def reader_definition; end
  def undefined; end
  def validate; end
  def validate_coercer; end
  def validate_default; end
  def validate_target; end

  class << self
    def dispatchers; end
    def new(source, coercer = T.unsafe(nil), **options); end
    def option(*args); end
    def param(*args); end
  end
end

class Dry::Initializer::Builder
  def initialize(**config); end

  def call(mixin); end
  def option(*args, **opts); end
  def param(*args, **opts); end

  private

  def attributes; end
  def clear_method(mixin, name); end
  def code; end
  def coercers; end
  def defaults; end
  def defined_options; end
  def duplications; end
  def getters; end
  def initializer_postsetters; end
  def initializer_presetters; end
  def initializer_setters; end
  def initializer_signatures; end
  def insert(collection, new_item); end
  def validate_collections; end
end

module Dry::Initializer::ClassDSL
  def [](**settings); end
  def config; end
  def define(fn = T.unsafe(nil), &block); end

  private

  def extended(klass); end
  def mixin(fn = T.unsafe(nil), &block); end
end

class Dry::Initializer::DefaultValueError < ::TypeError
  def initialize(name, value); end
end

module Dry::Initializer::InstanceDSL
  def initialize(*args); end

  private

  def __initialize__(*_arg0); end
end

Dry::Initializer::Mixin = Dry::Initializer

class Dry::Initializer::Option < ::Dry::Initializer::Attribute
  def coercer_hash; end
  def default_hash; end
  def fast_setter; end
  def initializer_signature; end
  def presetter; end
  def safe_setter; end

  private

  def default_part; end
  def dispensable?; end
  def maybe_optional; end
  def safe_coerced; end
  def safe_default; end
end

class Dry::Initializer::Param < ::Dry::Initializer::Attribute
  def initialize(*args, **options); end

  def coercer_hash; end
  def default_hash; end
  def fast_setter; end
  def initializer_signature; end
  def presetter; end
  def safe_setter; end

  private

  def default_part; end
  def maybe_coerced; end
  def maybe_default; end
end

class Dry::Initializer::ParamsOrderError < ::RuntimeError
  def initialize(required, optional); end
end

class Dry::Initializer::TypeConstraintError < ::TypeError
  def initialize(name, type); end
end

Dry::Initializer::UNDEFINED = T.let(T.unsafe(nil), Object)

# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/trailblazer-activity/all/trailblazer-activity.rbi
#
# trailblazer-activity-0.12.1

module Trailblazer
end
module Trailblazer::Version
end
module Trailblazer::Version::Activity
end
class Trailblazer::Activity
  def [](*key); end
  def call(args, **circuit_options); end
  def initialize(schema); end
  def inspect; end
  def self.End(semantic); end
  def self.Output(signal, semantic); end
  def to_h; end
end
class Trailblazer::Activity::End
  def call(args, **circuit_options); end
  def initialize(semantic:, **options); end
  def inspect; end
  def to_h; end
  def to_s; end
end
class Trailblazer::Activity::Start < Trailblazer::Activity::End
  def call(args, **circuit_options); end
end
class Trailblazer::Activity::Signal
end
class Trailblazer::Activity::Right < Trailblazer::Activity::Signal
end
class Trailblazer::Activity::Left < Trailblazer::Activity::Signal
end
class Trailblazer::Activity::Output < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def semantic; end
  def semantic=(_); end
  def signal; end
  def signal=(_); end
end
class Trailblazer::Activity::Schema < Anonymous_Struct_157
end
module Trailblazer::Activity::Schema::Implementation
  def self.Task(task, outputs, extensions = nil); end
end
class Trailblazer::Activity::Schema::Implementation::Task < Struct
  def circuit_task; end
  def circuit_task=(_); end
  def extensions; end
  def extensions=(_); end
  def outputs; end
  def outputs=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Anonymous_Struct_158 < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def start_task_ids; end
  def start_task_ids=(_); end
  def stop_task_ids; end
  def stop_task_ids=(_); end
  def wiring; end
  def wiring=(_); end
end
class Trailblazer::Activity::Schema::Intermediate < Anonymous_Struct_158
  def self.Out(*args); end
  def self.TaskRef(id, data = nil); end
  def self.call(intermediate, implementation, config_merge: nil); end
  def self.circuit(intermediate, implementation); end
  def self.config(implementation, config:); end
  def self.connections_for(outs, task_outputs, implementation); end
  def self.for_semantic(outputs, semantic); end
  def self.node_attributes(intermediate, implementation); end
  def self.outputs(stop_task_ids, nodes_attributes); end
end
class Trailblazer::Activity::Schema::Intermediate::TaskRef < Struct
  def data; end
  def data=(_); end
  def id; end
  def id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Trailblazer::Activity::Schema::Intermediate::Out < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def semantic; end
  def semantic=(_); end
  def target; end
  def target=(_); end
end
class Trailblazer::Activity::NodeAttributes < Struct
  def data; end
  def data=(_); end
  def id; end
  def id=(_); end
  def outputs; end
  def outputs=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def task; end
  def task=(_); end
end
class Anonymous_Struct_157 < Struct
  def circuit; end
  def circuit=(_); end
  def config; end
  def config=(_); end
  def nodes; end
  def nodes=(_); end
  def outputs; end
  def outputs=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Trailblazer::Activity::Circuit
  def call(args, start_task: nil, runner: nil, **circuit_options); end
  def initialize(map, stop_events, start_task:, name: nil); end
  def next_for(last_task, signal); end
  def to_h; end
end
class Trailblazer::Activity::Circuit::IllegalSignalError < RuntimeError
  def initialize(task, signal:, outputs:, exec_context:); end
  def signal; end
  def task; end
end
module Trailblazer::Activity::State
end
module Trailblazer::Activity::State::Config
  def get(state, *args); end
  def self.get(state, *args); end
  def self.set(state, *args); end
  def set(state, *args); end
end
module Trailblazer::Activity::Introspect
  def self.Graph(*args); end
  def self.render_task(proc); end
end
class Trailblazer::Activity::Introspect::Graph
  def Node(*args); end
  def collect(strategy: nil); end
  def find(id = nil, &block); end
  def find_by_id(id); end
  def find_with_block; end
  def initialize(activity); end
  def node_for(node_attributes); end
  def outgoings_for(node); end
  def stop_events; end
end
class Trailblazer::Activity::Introspect::Graph::Node < Struct
  def data; end
  def data=(_); end
  def id; end
  def id=(_); end
  def outgoings; end
  def outgoings=(_); end
  def outputs; end
  def outputs=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def task; end
  def task=(_); end
end
class Trailblazer::Activity::Introspect::Graph::Outgoing < Struct
  def output; end
  def output=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def task; end
  def task=(_); end
end
module Trailblazer::Activity::TaskWrap
  def Extension(merge:); end
  def initial_wrap_static(*arg0); end
  def invoke(activity, args, wrap_runtime: nil, wrap_static: nil, **circuit_options); end
  def self.Extension(merge:); end
  def self.call_task(wrap_ctx, original_args); end
  def self.initial_wrap_static(*arg0); end
  def self.invoke(activity, args, wrap_runtime: nil, wrap_static: nil, **circuit_options); end
  def self.wrap_static_for(task, activity:, **arg2); end
end
class Trailblazer::Activity::TaskWrap::Pipeline
  def call(wrap_ctx, original_args); end
  def initialize(sequence); end
  def self.append(pipe, _, insertion); end
  def self.insert_after(pipe, after_id, insertion); end
  def self.insert_before(pipe, before_id, insertion); end
  def sequence; end
end
class Trailblazer::Activity::TaskWrap::Pipeline::Merge
  def call(task_wrap_pipeline); end
  def initialize(*extension_rows); end
end
module Trailblazer::Activity::TaskWrap::Runner
  def self.call(task, args, **circuit_options); end
  def self.merge_static_with_runtime(task, wrap_runtime:, **circuit_options); end
end
module Trailblazer::Activity::TaskWrap::VariableMapping
  def self.Extension(input, output, id: nil); end
  def self.merge_for(input, output, id:); end
end
class Trailblazer::Activity::TaskWrap::Input
  def apply_filter(arg0, original_circuit_options); end
  def call(wrap_ctx, original_args); end
  def initialize(filter, id:); end
end
class Trailblazer::Activity::TaskWrap::Output
  def call(wrap_ctx, original_args); end
  def initialize(filter, id:); end
end
module Trailblazer::Activity::TaskWrap::Inject
end
module Trailblazer::Activity::TaskWrap::Inject::Defaults
  def Extension(defaults); end
  def defaults_for(defaults, original_ctx); end
  def self.Extension(defaults); end
  def self.defaults_for(defaults, original_ctx); end
end
class Trailblazer::Activity::TaskWrap::Extension
  def call(config:, task:, **arg2); end
  def initialize(merge:); end
end
module Trailblazer::Activity::TaskBuilder
  def self.Binary(user_proc); end
  def self.binary_signal_for(result, on_true, on_false); end
end
class Trailblazer::Activity::TaskBuilder::Task
  def call(arg0, **circuit_options); end
  def initialize(task, user_proc); end
  def inspect; end
  def to_s; end
end

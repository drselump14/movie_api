# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `disposable` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Disposable; end

class Disposable::Composition < ::Disposable::Expose
  def initialize(models); end

  def [](name); end
  def each(&block); end

  class << self
    def accessors!(public_name, private_name, definition); end
  end
end

class Disposable::Expose
  include ::Disposable::Expose::Save

  def initialize(model); end

  class << self
    def from(schema); end

    private

    def accessors!(public_name, private_name, definition); end
    def process_definition!(definition); end
  end
end

module Disposable::Expose::Save
  def save; end
end

class Disposable::Rescheme
  def from(source_class, options, &block); end

  private

  def build_definition!(options, source_dfn, representer, &block); end
  def build_representer(options); end
  def evaluate_block!(options, definition); end
  def exclude!(options, dfn_options); end
  def from_inline!(options, dfn, new_options, representer, &block); end
  def from_scalar!(options, dfn, new_options, representer); end

  class << self
    def from(*args, &block); end
  end
end

class Disposable::Twin
  extend ::Uber::Delegates
  include ::Disposable::Twin::Accessors
  include ::Disposable::Twin::ModelReaders
  extend ::Declarative::Schema
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Declarative::Heritage::Inherited
  extend ::Disposable::Twin::Property::Unnest
  include ::Disposable::Twin::Setup

  def schema; end

  class << self
    def collection(name, options = T.unsafe(nil), &block); end
    def default_nested_class; end
    def definition_class; end
    def from_collection(collection); end
    def inherited(subclass); end
    def property(name, options = T.unsafe(nil), &block); end

    private

    def create_accessors(name, definition); end
  end
end

module Disposable::Twin::Accessors
  private

  def build_collection(dfn, *args); end
  def build_for(dfn, *args); end
  def build_twin(dfn, *args); end
  def field_read(name); end
  def field_write(name, value); end
  def write_property(name, value, dfn); end
end

module Disposable::Twin::Builder
  include ::Declarative::Builder

  class << self
    def included(base); end
  end
end

module Disposable::Twin::Changed
  def initialize(model, *args); end

  def changed; end
  def changed?(*args); end

  private

  def _changed; end
  def _find_changed_twins!(changes); end
  def write_property(name, value, dfn); end
end

class Disposable::Twin::Changed::Changes < ::Hash
  def changed?(name = T.unsafe(nil)); end
end

class Disposable::Twin::Collection < ::Array
  include ::Disposable::Twin::Collection::Changed

  def initialize(twinner, items); end

  def <<(model); end
  def added; end
  def append(model); end
  def delete(twin); end
  def deleted; end
  def destroy(twin); end
  def destroyed; end
  def find_by(options); end
  def insert(index, model); end
  def original; end
  def save; end

  private

  def destroy!; end
  def to_destroy; end

  class << self
    def for_models(twinner, models, *options); end
  end
end

module Disposable::Twin::Collection::Changed
  def changed?; end
end

module Disposable::Twin::Collection::Semantics
  def save; end
end

module Disposable::Twin::Composition
  include ::Disposable::Twin::Expose::Initialize

  mixes_in_class_methods ::Disposable::Twin::Composition::ClassMethods

  def to_nested_hash(*_arg0); end

  private

  def save_model; end

  class << self
    def included(base); end
  end
end

module Disposable::Twin::Composition::ClassMethods
  def expose_class; end
end

module Disposable::Twin::Default
  mixes_in_class_methods ::Disposable::Twin::Default::ClassMethods

  def default_for(dfn, options); end
  def setup_value_for(dfn, options); end

  class << self
    def included(includer); end
  end
end

module Disposable::Twin::Default::ClassMethods
  private

  def build_definition(name, options = T.unsafe(nil), &block); end
end

class Disposable::Twin::Definition < ::Declarative::Definitions::Definition
  def getter; end
  def setter; end
end

class Disposable::Twin::Definition::Each < ::SimpleDelegator
  def each(options = T.unsafe(nil)); end
end

Disposable::Twin::Definition::Filter = T.let(T.unsafe(nil), Proc)

module Disposable::Twin::Expose
  include ::Disposable::Twin::Expose::Initialize

  mixes_in_class_methods ::Disposable::Twin::Expose::ClassMethods

  class << self
    def included(base); end
  end
end

module Disposable::Twin::Expose::ClassMethods
  def expose_class; end
end

module Disposable::Twin::Expose::Initialize
  def mapper_for(*args); end
end

Disposable::Twin::INVALID_PROPERTY_NAMES = T.let(T.unsafe(nil), Array)
class Disposable::Twin::InvalidPropertyNameError < ::StandardError; end

module Disposable::Twin::ModelReaders
  def mapper; end
  def model; end
end

module Disposable::Twin::Persisted
  def created?; end
  def save!(*_arg0); end

  class << self
    def included(includer); end
  end
end

module Disposable::Twin::Property; end

module Disposable::Twin::Property::Unnest
  include ::Uber::Delegates

  def unnest(name, options); end

  class << self
    def included(includer); end
  end
end

class Disposable::Twin::PropertyProcessor
  def initialize(definition, twin, value = T.unsafe(nil)); end

  def call(&block); end

  private

  def collection!; end
  def property!; end
end

module Disposable::Twin::Save
  def save(options = T.unsafe(nil), &block); end
  def save!(options = T.unsafe(nil)); end
  def save_model; end
end

module Disposable::Twin::Setup
  def initialize(model, options = T.unsafe(nil)); end

  private

  def mapper_for(model); end
  def read_value_for(dfn, options); end
  def setup_properties!(options); end
  def setup_property!(dfn, options); end
  def setup_value_for(dfn, options); end
  def setup_write!(dfn, value); end
end

module Disposable::Twin::Setup::SkipSetter
  def setup_write!(dfn, value); end
end

module Disposable::Twin::Sync
  include ::Disposable::Twin::Sync::ToNestedHash
  include ::Disposable::Twin::Sync::SyncOptions
  include ::Disposable::Twin::Sync::Writeable

  mixes_in_class_methods ::Disposable::Twin::Sync::ToNestedHash::ClassMethods

  def sync(options = T.unsafe(nil)); end
  def sync!(options); end
  def sync_models(options = T.unsafe(nil)); end

  private

  def sync_read(definition); end

  class << self
    def hash_representer(twin_class, &block); end
    def included(includer); end
  end
end

class Disposable::Twin::Sync::Options < ::Hash
  def exclude!(names); end
  def excludes; end
end

module Disposable::Twin::Sync::SkipGetter
  def nested_hash_source; end
  def sync_read(dfn); end
end

module Disposable::Twin::Sync::SkipUnchanged
  include ::Disposable::Twin::Changed

  def sync_options(options); end

  class << self
    def included(base); end
  end
end

module Disposable::Twin::Sync::SyncOptions
  def sync_options(options); end
end

module Disposable::Twin::Sync::ToNestedHash
  def nested_hash_source; end
  def to_nested_hash(*_arg0); end
end

module Disposable::Twin::Sync::ToNestedHash::ClassMethods
  def build_nested_hash_representer; end
  def nested_hash_representer; end
end

module Disposable::Twin::Sync::Writeable
  def sync_options(options); end
end

class Disposable::Twin::Twinner
  def initialize(twin, dfn); end

  def call(*args); end
end

Disposable::VERSION = T.let(T.unsafe(nil), String)

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `transproc` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Transproc; end

module Transproc::ArrayTransformations
  extend ::Transproc::Registry

  class << self
    def add_keys(array, keys); end
    def combine(array, mappings); end
    def extract_key(array, key); end
    def group(array, key, keys); end
    def insert_key(array, key); end
    def map_array(array, fn); end
    def ungroup(array, key, keys); end
    def wrap(array, key, keys); end
  end
end

class Transproc::ArrayTransformations::Combine
  class << self
    def combine(array, mappings); end

    private

    def add_groups_to_element(element, groups, mappings); end
    def element_candidates(element, candidates, keys); end
    def element_candidates_key(element, keys); end
    def group_candidates(candidates, mapping); end
    def group_candidates_by_keys(candidates, keys); end
    def group_nodes(nodes, mappings); end
  end
end

Transproc::ArrayTransformations::Combine::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

module Transproc::ClassTransformations
  extend ::Transproc::Registry

  class << self
    def constructor_inject(*args, klass); end
    def set_ivars(ivar_hash, klass); end
  end
end

module Transproc::Coercions
  extend ::Transproc::Registry

  class << self
    def identity(value = T.unsafe(nil)); end
    def to_boolean(value); end
    def to_date(value); end
    def to_datetime(value); end
    def to_decimal(value); end
    def to_float(value); end
    def to_integer(value); end
    def to_string(value); end
    def to_symbol(value); end
    def to_time(value); end
    def to_tuples(value); end
  end
end

Transproc::Coercions::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)
Transproc::Coercions::FALSE_VALUES = T.let(T.unsafe(nil), Array)
Transproc::Coercions::TRUE_VALUES = T.let(T.unsafe(nil), Array)

class Transproc::Compiler
  def initialize(registry, transformer = T.unsafe(nil)); end

  def call(ast); end
  def registry; end
  def transformer; end
  def visit(node); end
  def visit_arg(arg); end
  def visit_fn(node); end
  def visit_t(node); end
end

class Transproc::Compiler::InvalidFunctionNameError < ::StandardError; end

module Transproc::Composer
  def compose(default = T.unsafe(nil)); end
end

class Transproc::Composer::Factory
  def initialize(default = T.unsafe(nil)); end

  def <<(other); end
  def default; end
  def fns; end
  def t(*args, &block); end
  def to_fn; end
end

class Transproc::Composite
  def initialize(left, right); end

  def +(other); end
  def >>(other); end
  def [](value); end
  def call(value); end
  def compose(other); end
  def left; end
  def right; end
  def to_ast; end
end

module Transproc::Conditional
  extend ::Transproc::Registry

  class << self
    def guard(value, predicate, fn); end
    def is(value, type, fn); end
    def not(value, fn); end
  end
end

module Transproc::Deprecations
  class << self
    def announce(name, msg); end
  end
end

class Transproc::Error < ::StandardError; end

class Transproc::Function
  def initialize(fn, options = T.unsafe(nil)); end

  def +(other); end
  def ==(other); end
  def >>(other); end
  def [](*value); end
  def args; end
  def call(*value); end
  def compose(other); end
  def eql?(other); end
  def fn; end
  def name; end
  def to_ast; end
  def to_proc; end
  def with(*args); end
end

class Transproc::FunctionAlreadyRegisteredError < ::Transproc::Error; end

class Transproc::FunctionNotFoundError < ::Transproc::Error
  def initialize(function, source = T.unsafe(nil)); end
end

module Transproc::Functions
  def method_added(meth); end

  class << self
    def extended(mod); end
  end
end

module Transproc::HashTransformations
  extend ::Transproc::Registry

  class << self
    def accept_keys(hash, keys); end
    def copy_keys(source_hash, mapping); end
    def deep_merge(hash, other); end
    def deep_stringify_keys(hash); end
    def deep_symbolize_keys(hash); end
    def eval_values(hash, args, filters = T.unsafe(nil)); end
    def fold(hash, key, tuple_key); end
    def map_keys(source_hash, fn); end
    def map_value(hash, key, fn); end
    def map_values(source_hash, fn); end
    def nest(hash, root, keys); end
    def reject_keys(hash, keys); end
    def rename_keys(source_hash, mapping); end
    def split(hash, key, keys); end
    def stringify_keys(hash); end
    def symbolize_keys(hash); end
    def unwrap(source_hash, root, selected = T.unsafe(nil), options = T.unsafe(nil)); end
  end
end

Transproc::HashTransformations::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

module Transproc::ProcTransformations
  extend ::Transproc::Registry

  class << self
    def bind(value, binding, fn); end
  end
end

module Transproc::Recursion
  extend ::Transproc::Registry

  class << self
    def array_recursion(value, fn); end
    def hash_recursion(value, fn); end
    def recursion(value, fn); end
  end
end

Transproc::Recursion::IF_ARRAY = T.let(T.unsafe(nil), Proc)
Transproc::Recursion::IF_ENUMERABLE = T.let(T.unsafe(nil), Proc)
Transproc::Recursion::IF_HASH = T.let(T.unsafe(nil), Proc)

module Transproc::Registry
  def [](fn, *args); end
  def contain?(key); end
  def fetch(fn); end
  def import(*args); end
  def register(name, fn = T.unsafe(nil), &block); end
  def store; end
  def t(fn, *args); end
  def uses(*args); end

  private

  def already_wrapped?(func); end
end

class Transproc::Store
  def initialize(methods = T.unsafe(nil)); end

  def contain?(key); end
  def fetch(key); end
  def import(*args); end
  def methods; end
  def register(name, fn = T.unsafe(nil), &block); end

  protected

  def import_all(source); end
  def import_method(source, name, new_name = T.unsafe(nil)); end
  def import_methods(source, names); end
end

class Transproc::Transformer
  extend ::Transproc::Transformer::ClassInterface
  extend ::Transproc::Transformer::Deprecated::ClassInterface

  def call(input); end
  def transproc; end
end

module Transproc::Transformer::ClassInterface
  def [](container); end
  def container(container = T.unsafe(nil)); end
  def define!(&block); end
  def dsl; end
  def import(*args); end
  def inherited(subclass); end
  def new(*_arg0); end
  def t(fn, *args); end
end

class Transproc::Transformer::DSL
  def initialize(container, ast: T.unsafe(nil), &block); end

  def ast; end
  def call(transformer); end
  def container; end
  def dup; end

  private

  def method_missing(meth, *args, &block); end
  def node(&block); end
  def respond_to_missing?(method, _include_private = T.unsafe(nil)); end
end

module Transproc::Transformer::Deprecated; end

module Transproc::Transformer::Deprecated::ClassInterface
  def build(&block); end
  def define(&block); end
  def inherited(subclass); end
  def method_missing(method, *args, &block); end
  def new(*_arg0); end
  def transproc; end

  private

  def respond_to_missing?(method, _include_private = T.unsafe(nil)); end
  def transformations; end
end

Transproc::Undefined = T.let(T.unsafe(nil), Object)
Transproc::VERSION = T.let(T.unsafe(nil), String)

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hanami-view` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Hanami
  class << self
    def app; end
    def app?(app); end
    def boot; end
    def code_reloading?; end
    def configuration; end
    def configure(&blk); end
    def env; end
    def env?(*names); end
    def environment; end
    def logger; end
    def plugin(&blk); end
    def plugins; end
    def public_directory; end
    def root; end
  end
end

Hanami::DEFAULT_PUBLIC_DIRECTORY = T.let(T.unsafe(nil), String)

module Hanami::Layout
  def initialize(scope, rendered); end

  def local(key); end
  def render; end

  protected

  def template; end

  class << self
    def included(base); end
  end
end

module Hanami::Layout::ClassMethods
  def registry; end
  def suffix; end
  def template; end

  protected

  def load!; end

  private

  def load_registry!; end
end

Hanami::Layout::ClassMethods::SUFFIX = T.let(T.unsafe(nil), String)

module Hanami::Presenter
  include ::Hanami::Utils::ClassAttribute
  include ::Hanami::View::Escape::InstanceMethods
  include ::Hanami::View::Escape::Presentable

  class << self
    def included(base); end
  end
end

Hanami::VERSION = T.let(T.unsafe(nil), String)

module Hanami::View
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Utils::ClassAttribute::ClassMethods
  include ::Hanami::View::Rendering::InstanceMethods
  include ::Hanami::Utils::ClassAttribute
  include ::Hanami::View::Escape::InstanceMethods

  mixes_in_class_methods ::Hanami::Utils::ClassAttribute::ClassMethods

  class << self
    def configuration; end
    def configuration=(_arg0); end
    def configure(&blk); end
    def dupe; end
    def duplicate(mod, views = T.unsafe(nil), &blk); end
    def included(base); end
    def load!; end
  end
end

class Hanami::View::Configuration
  def initialize; end

  def add_layout(layout); end
  def add_partial(partial); end
  def add_view(view); end
  def copy!(base); end
  def default_encoding(value = T.unsafe(nil)); end
  def duplicate; end
  def find_partial(relative_partial_path, template_name, format); end
  def layout(value = T.unsafe(nil)); end
  def layouts; end
  def load!; end
  def load_partials!; end
  def load_paths; end
  def modules; end
  def namespace(value = T.unsafe(nil)); end
  def partials; end
  def prepare(&blk); end
  def reset!; end
  def root(value = T.unsafe(nil)); end
  def unload!; end
  def views; end

  protected

  def default_encoding=(_arg0); end
  def layout=(_arg0); end
  def load_paths=(_arg0); end
  def modules=(_arg0); end
  def namespace=(_arg0); end
  def root=(_arg0); end

  class << self
    def for(base); end
  end
end

Hanami::View::Configuration::DEFAULT_ENCODING = T.let(T.unsafe(nil), Encoding)
Hanami::View::Configuration::DEFAULT_ROOT = T.let(T.unsafe(nil), String)

module Hanami::View::Dsl
  def format(value = T.unsafe(nil)); end
  def layout(value = T.unsafe(nil)); end
  def root(value = T.unsafe(nil)); end
  def template(value = T.unsafe(nil)); end

  protected

  def load!; end
end

class Hanami::View::Error < ::StandardError; end

module Hanami::View::Escape
  def method_added(method_name); end

  class << self
    def extended(base); end
    def html(input); end
  end
end

module Hanami::View::Escape::InstanceMethods
  private

  def _escape(object); end
  def _raw(string); end
end

module Hanami::View::Escape::Presentable
  include ::Hanami::Utils::ClassAttribute
  include ::Hanami::View::Escape::InstanceMethods

  mixes_in_class_methods ::Hanami::View::Escape

  def initialize(object); end

  protected

  def method_missing(m, *args, &blk); end

  private

  def respond_to_missing?(m, include_private = T.unsafe(nil)); end

  class << self
    def included(base); end
  end
end

class Hanami::View::Escape::Presenter
  include ::Hanami::View::Escape::Presentable
  extend ::Hanami::View::Escape
end

module Hanami::View::Inheritable
  def inherited(base); end
  def subclasses; end

  protected

  def load!; end
  def views; end
end

class Hanami::View::MissingFormatError < ::Hanami::View::Error; end

class Hanami::View::MissingTemplateError < ::Hanami::View::Error
  def initialize(template, format); end
end

class Hanami::View::MissingTemplateLayoutError < ::Hanami::View::Error
  def initialize(template); end
end

module Hanami::View::Rendering
  def render(context); end

  protected

  def load!; end

  private

  def load_registry!; end
  def registry; end

  class << self
    def extended(base); end
  end
end

module Hanami::View::Rendering::InstanceMethods
  def initialize(template, **locals); end

  def local(key); end
  def render; end

  protected

  def layout; end
  def locals; end
  def method_missing(m, *_arg1); end
  def rendered; end
  def template; end
end

Hanami::View::Rendering::KNOWN_RENDER_TYPES = T.let(T.unsafe(nil), Array)

class Hanami::View::Rendering::LayoutFinder
  def initialize(view); end

  def find; end

  class << self
    def find(layout, namespace = T.unsafe(nil)); end
  end
end

Hanami::View::Rendering::LayoutFinder::SUFFIX = T.let(T.unsafe(nil), String)

class Hanami::View::Rendering::LayoutRegistry
  def initialize(view); end

  def resolve(context); end

  protected

  def format(context); end
  def prepare!; end
  def templates; end
end

class Hanami::View::Rendering::LayoutScope < ::Hanami::Utils::BasicObject
  def initialize(layout, scope); end

  def format; end
  def local(key); end
  def locals; end
  def render(options, &block); end
  def respond_to?(m, include_all = T.unsafe(nil)); end
  def view; end

  protected

  def method_missing(m, *args, &blk); end
  def renderer(options); end

  private

  def __inspect; end
  def _options(options); end
  def layout; end
  def respond_to_missing?(m, include_all); end
end

class Hanami::View::Rendering::NullLayout
  def initialize(scope, rendered); end

  def render; end
end

class Hanami::View::Rendering::NullLocal < ::Hanami::Utils::BasicObject
  def initialize(local); end

  def all?; end
  def any?; end
  def empty?; end
  def method_missing(m, *_arg1); end
  def nil?; end
  def to_s; end
  def to_str; end

  private

  def __inspect; end
  def respond_to_missing?(method_name, include_all); end
end

Hanami::View::Rendering::NullLocal::TO_STR = T.let(T.unsafe(nil), String)

class Hanami::View::Rendering::NullTemplate
  def render(scope, locals = T.unsafe(nil)); end
end

class Hanami::View::Rendering::NullView
  def render; end
end

class Hanami::View::Rendering::Options
  class << self
    def build(options, locals, format); end
  end
end

class Hanami::View::Rendering::Partial < ::Hanami::View::Rendering::Template
  protected

  def template; end
end

class Hanami::View::Rendering::PartialFile
  def initialize(key, format, template); end

  def format; end
  def key; end
  def template; end
end

class Hanami::View::Rendering::PartialFinder < ::Hanami::View::Rendering::TemplateFinder
  def find; end

  protected

  def partial_name; end
  def prefix; end
  def relative_partial_path; end
  def template_name; end
  def view_template_dir; end
end

Hanami::View::Rendering::PartialFinder::PREFIX = T.let(T.unsafe(nil), String)

class Hanami::View::Rendering::PartialTemplatesFinder
  def initialize(configuration); end

  def configuration; end
  def find; end

  private

  def _find_partials(path); end
end

Hanami::View::Rendering::PartialTemplatesFinder::PARTIAL_PARTS_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::View::Rendering::PartialTemplatesFinder::PARTIAL_PATTERN = T.let(T.unsafe(nil), String)

class Hanami::View::Rendering::Registry < ::Hanami::View::Rendering::LayoutRegistry
  def resolve(context); end

  private

  def prepare!; end
  def prepare_templates!; end
  def prepare_views!; end
  def template_for(view); end
  def view_for(template); end
  def views; end
end

Hanami::View::Rendering::Registry::DEFAULT_FORMAT = T.let(T.unsafe(nil), Symbol)

class Hanami::View::Rendering::Scope < ::Hanami::View::Rendering::LayoutScope
  def initialize(view, locals = T.unsafe(nil)); end

  def format; end
  def inspect; end

  protected

  def method_missing(m, *args, &block); end

  private

  def _options(options); end
  def layout; end
  def respond_to_missing?(m, include_all); end
end

class Hanami::View::Rendering::Subscope < ::Hanami::View::Rendering::Scope
  protected

  def method_missing(m, *args, &block); end

  private

  def _options(options); end
  def respond_to_missing?(m, _include_all); end
end

class Hanami::View::Rendering::Template
  def initialize(view, options); end

  def render(&block); end

  protected

  def raise_missing_template_error; end
  def scope; end
  def template; end
end

class Hanami::View::Rendering::TemplateFinder < ::Hanami::View::Rendering::TemplatesFinder
  def initialize(view, options); end

  def find; end

  protected

  def format; end
  def template_name; end
end

class Hanami::View::Rendering::TemplateName
  def initialize(name, namespace); end

  def to_s; end

  private

  def compile!(namespace); end
  def replace!(token); end
  def tokens(namespace); end
end

Hanami::View::Rendering::TemplateName::NAMESPACE_SEPARATOR = T.let(T.unsafe(nil), String)

class Hanami::View::Rendering::TemplatesFinder
  def initialize(view); end

  def find; end

  protected

  def _find(lookup = T.unsafe(nil)); end
  def engines; end
  def format; end
  def recursive; end
  def root; end
  def search_path; end
  def separator; end
  def template_name; end
  def templates_path(*parts); end
end

Hanami::View::Rendering::TemplatesFinder::ENGINES = T.let(T.unsafe(nil), String)
Hanami::View::Rendering::TemplatesFinder::FORMAT = T.let(T.unsafe(nil), String)
Hanami::View::Rendering::TemplatesFinder::RECURSIVE = T.let(T.unsafe(nil), String)

class Hanami::View::Rendering::ViewFinder
  def initialize(view); end

  def find(template); end
end

class Hanami::View::Template
  def initialize(template, encoding = T.unsafe(nil)); end

  def format; end
  def render(scope, &blk); end

  private

  def slim?(template); end
end

class Hanami::View::UnknownRenderTypeError < ::Hanami::View::Error
  def initialize(known_types, supplied_options); end
end

Hanami::View::VERSION = T.let(T.unsafe(nil), String)

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-configurable` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Dry
  class << self
    def AutoInject(container, options = T.unsafe(nil)); end
    def Equalizer(*keys, **options); end
  end
end

module Dry::Configurable
  include ::Dry::Core::Constants
  include ::Dry::Configurable::InstanceMethods

  mixes_in_class_methods ::Dry::Configurable::ClassMethods

  class << self
    def extended(klass); end
    def included(klass); end
  end
end

class Dry::Configurable::AlreadyIncluded < ::Dry::Configurable::Error; end

module Dry::Configurable::ClassMethods
  include ::Dry::Configurable::Methods

  def __config_dsl__; end
  def __config_reader__; end
  def _settings; end
  def config; end
  def inherited(klass); end
  def setting(*args, &block); end
  def settings; end
end

class Dry::Configurable::Compiler
  def call(ast); end
  def visit(node); end
  def visit_constructor(node); end
  def visit_nested(node); end
  def visit_setting(node); end
end

class Dry::Configurable::Config
  include ::Dry::Core::Equalizer::Methods

  def initialize(settings); end

  def [](name); end
  def []=(name, value); end
  def _resolved; end
  def _settings; end
  def finalize!; end
  def pristine; end
  def to_h; end
  def to_hash; end
  def update(values); end
  def values; end

  private

  def initialize_copy(source); end
  def method_missing(meth, *args); end
  def resolve(meth); end
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

class Dry::Configurable::DSL
  def initialize(&block); end

  def ast; end
  def compiler; end
  def setting(name, *args, &block); end
end

class Dry::Configurable::DSL::Args
  def initialize(args); end

  def args; end
  def default; end
  def ensure_valid_options; end
  def options; end
  def opts; end
  def size; end
  def to_ary; end
end

Dry::Configurable::DSL::VALID_NAME = T.let(T.unsafe(nil), Regexp)
Dry::Configurable::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Configurable::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Configurable::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Configurable::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Configurable::EMPTY_STRING = T.let(T.unsafe(nil), String)
class Dry::Configurable::Error < ::StandardError; end
class Dry::Configurable::FrozenConfig < ::Dry::Configurable::Error; end
Dry::Configurable::IDENTITY = T.let(T.unsafe(nil), Proc)

module Dry::Configurable::Initializer
  def initialize(*_arg0); end
end

module Dry::Configurable::InstanceMethods
  include ::Dry::Configurable::Methods

  def config; end
  def finalize!; end

  private

  def initialize_copy(source); end
end

module Dry::Configurable::Methods
  def configure(&block); end
  def finalize!; end
end

Dry::Configurable::Self = T.let(T.unsafe(nil), Proc)

class Dry::Configurable::Setting
  include ::Dry::Core::Equalizer::Methods

  def initialize(name, input: T.unsafe(nil), default: T.unsafe(nil), **options); end

  def cloneable?; end
  def constructor; end
  def default; end
  def evaluated?; end
  def input; end
  def input_defined?; end
  def name; end
  def nested(settings); end
  def options; end
  def pristine; end
  def reader?; end
  def value; end
  def with(new_opts); end
  def writer?(meth); end
  def writer_name; end

  private

  def evaluate; end
  def initialize_copy(source); end

  class << self
    def cloneable_value?(value); end
  end
end

Dry::Configurable::Setting::CLONEABLE_VALUE_TYPES = T.let(T.unsafe(nil), Array)
Dry::Configurable::Setting::DEFAULT_CONSTRUCTOR = T.let(T.unsafe(nil), Proc)

class Dry::Configurable::Setting::Nested < ::Dry::Configurable::Setting
  def constructor; end
  def pristine; end
end

Dry::Configurable::Setting::Nested::CONSTRUCTOR = T.let(T.unsafe(nil), Method)
Dry::Configurable::Setting::OPTIONS = T.let(T.unsafe(nil), Array)

class Dry::Configurable::Settings
  include ::Dry::Core::Equalizer::Methods
  include ::Enumerable

  def initialize(elements = T.unsafe(nil)); end

  def <<(setting); end
  def [](name); end
  def each(&block); end
  def elements; end
  def key?(name); end
  def keys; end
  def pristine; end

  private

  def initialize_copy(source); end
  def initialize_elements(elements); end
end

Dry::Configurable::Undefined = T.let(T.unsafe(nil), Object)

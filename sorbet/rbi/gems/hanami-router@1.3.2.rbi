# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hanami-router` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Hanami
  class << self
    def app; end
    def app?(app); end
    def boot; end
    def code_reloading?; end
    def configuration; end
    def configure(&blk); end
    def env; end
    def env?(*names); end
    def environment; end
    def logger; end
    def plugin(&blk); end
    def plugins; end
    def public_directory; end
    def root; end
  end
end

Hanami::DEFAULT_PUBLIC_DIRECTORY = T.let(T.unsafe(nil), String)

class Hanami::Router
  def initialize(options = T.unsafe(nil), &blk); end

  def call(env); end
  def define(&blk); end
  def defined?; end
  def delete(path, options = T.unsafe(nil), &blk); end
  def get(path, options = T.unsafe(nil), &blk); end
  def inspector; end
  def link(path, options = T.unsafe(nil), &blk); end
  def mount(app, options); end
  def namespace(namespace, &blk); end
  def options(path, options = T.unsafe(nil), &blk); end
  def patch(path, options = T.unsafe(nil), &blk); end
  def path(route, *args); end
  def post(path, options = T.unsafe(nil), &blk); end
  def put(path, options = T.unsafe(nil), &blk); end
  def recognize(env, options = T.unsafe(nil), params = T.unsafe(nil)); end
  def redirect(path, options = T.unsafe(nil), &endpoint); end
  def resource(name, options = T.unsafe(nil), &blk); end
  def resources(name, options = T.unsafe(nil), &blk); end
  def root(options = T.unsafe(nil), &blk); end
  def routes; end
  def trace(path, options = T.unsafe(nil), &blk); end
  def unlink(path, options = T.unsafe(nil), &blk); end
  def url(route, *args); end

  protected

  def env_for(env, options = T.unsafe(nil), params = T.unsafe(nil)); end

  class << self
    def define(&blk); end
  end
end

class Hanami::Router::NotRoutableEndpointError < ::Hanami::Routing::Error
  def initialize(env); end
end

Hanami::Router::NotRoutableEndpointError::PATH_INFO = T.let(T.unsafe(nil), String)
Hanami::Router::NotRoutableEndpointError::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Hanami::Router::ROOT_PATH = T.let(T.unsafe(nil), String)
module Hanami::Routing; end

class Hanami::Routing::ClassEndpoint < ::Hanami::Routing::Endpoint
  def call(env); end
end

class Hanami::Routing::Endpoint < ::SimpleDelegator
  def destination_path; end
  def inspect; end
  def redirect?; end
  def routable?; end
end

class Hanami::Routing::EndpointNotFound < ::Hanami::Routing::Error; end

class Hanami::Routing::EndpointResolver
  def initialize(options = T.unsafe(nil)); end

  def action_separator; end
  def find(options); end
  def resolve(options, &endpoint); end

  protected

  def classify(string); end
  def constantize(string); end
  def default; end

  private

  def resolve_action(string); end
  def resolve_callable(callable); end
  def resolve_matchable(matchable); end
end

Hanami::Routing::EndpointResolver::ACTION_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Routing::EndpointResolver::DEFAULT_RESPONSE = T.let(T.unsafe(nil), Array)
Hanami::Routing::EndpointResolver::NAMING_PATTERN = T.let(T.unsafe(nil), String)
class Hanami::Routing::Error < ::StandardError; end

class Hanami::Routing::ForceSsl
  def initialize(active, options = T.unsafe(nil)); end

  def call(env); end
  def force?(env); end

  private

  def _redefine_call; end
  def full_url(env); end
  def host; end
  def port; end
  def redirect_code(env); end
  def scheme(env); end
  def ssl?(env); end
end

Hanami::Routing::ForceSsl::DEFAULT_HTTP_PORT = T.let(T.unsafe(nil), Integer)
Hanami::Routing::ForceSsl::DEFAULT_SSL_PORT = T.let(T.unsafe(nil), Integer)
Hanami::Routing::ForceSsl::EMPTY_BODY = T.let(T.unsafe(nil), Array)
Hanami::Routing::ForceSsl::HTTPS = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::HTTP_X_FORWARDED_PROTO_SEPARATOR = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::IDEMPOTENT_METHODS = T.let(T.unsafe(nil), Array)
Hanami::Routing::ForceSsl::LOCATION_HEADER = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::MOVED_PERMANENTLY_HTTP_CODE = T.let(T.unsafe(nil), Integer)
Hanami::Routing::ForceSsl::ON = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::SSL_SCHEME = T.let(T.unsafe(nil), String)
Hanami::Routing::ForceSsl::TEMPORARY_REDIRECT_HTTP_CODE = T.let(T.unsafe(nil), Integer)

class Hanami::Routing::HttpRouter < ::HttpRouter
  def initialize(options = T.unsafe(nil), &blk); end

  def action_separator; end
  def find(options); end
  def mount(app, options); end
  def namespace; end
  def no_response(request, env); end
  def options(path, options = T.unsafe(nil), &blk); end
  def pass_on_response(response); end
  def prefix; end
  def raw_call(env, &blk); end
  def raw_path(route, *args); end
  def raw_url(route, *args); end
  def reset!; end
  def rewrite_partial_path_info(env, request); end

  private

  def _custom_path(uri_string); end
  def _rescue_url_recognition; end
  def add_with_request_method(path, method, opts = T.unsafe(nil), &app); end
end

Hanami::Routing::HttpRouter::DEFAULT_PATH_INFO = T.let(T.unsafe(nil), String)
Hanami::Routing::HttpRouter::PATH_INFO = T.let(T.unsafe(nil), String)
Hanami::Routing::HttpRouter::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Hanami::Routing::HttpRouter::URL_SEPARATOR = T.let(T.unsafe(nil), String)
class Hanami::Routing::InvalidRouteException < ::Hanami::Routing::Error; end

class Hanami::Routing::LazyEndpoint < ::Hanami::Routing::Endpoint
  def initialize(name, namespace); end

  def call(env); end
  def inspect; end

  private

  def klass; end
  def obj; end
end

class Hanami::Routing::Namespace < ::SimpleDelegator
  def initialize(router, name, &blk); end

  def delete(path, options = T.unsafe(nil), &endpoint); end
  def get(path, options = T.unsafe(nil), &endpoint); end
  def mount(app, options); end
  def namespace(name, &blk); end
  def options(path, options = T.unsafe(nil), &endpoint); end
  def patch(path, options = T.unsafe(nil), &endpoint); end
  def post(path, options = T.unsafe(nil), &endpoint); end
  def put(path, options = T.unsafe(nil), &endpoint); end
  def redirect(path, options = T.unsafe(nil), &endpoint); end
  def resource(name, options = T.unsafe(nil)); end
  def resources(name, options = T.unsafe(nil)); end
  def trace(path, options = T.unsafe(nil), &endpoint); end
end

class Hanami::Routing::Parsers
  def initialize(parsers); end

  def call(env); end

  private

  def _parse(env, body); end
  def _redefine_call; end
  def _symbolize(body); end
  def content_type(env); end
  def media_type(env); end
  def prepare(args); end
end

Hanami::Routing::Parsers::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Hanami::Routing::Parsers::FALLBACK_KEY = T.let(T.unsafe(nil), String)
Hanami::Routing::Parsers::MEDIA_TYPE_MATCHER = T.let(T.unsafe(nil), Regexp)
Hanami::Routing::Parsers::RACK_INPUT = T.let(T.unsafe(nil), String)
Hanami::Routing::Parsers::ROUTER_PARAMS = T.let(T.unsafe(nil), String)
Hanami::Routing::Parsers::ROUTER_PARSED_BODY = T.let(T.unsafe(nil), String)
module Hanami::Routing::Parsing; end
class Hanami::Routing::Parsing::BodyParsingError < ::Hanami::Routing::Error; end

class Hanami::Routing::Parsing::Parser
  def mime_types; end
  def parse(body); end

  class << self
    def for(parser); end
    def require_parser(parser); end
  end
end

class Hanami::Routing::Parsing::UnknownParserError < ::Hanami::Routing::Error
  def initialize(parser); end
end

class Hanami::Routing::RedirectEndpoint < ::Hanami::Routing::Endpoint
  def initialize(destination_path, destination); end

  def destination_path; end
  def redirect?; end
end

class Hanami::Routing::Resource
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Utils::ClassAttribute::ClassMethods

  def initialize(router, name, options = T.unsafe(nil), parent = T.unsafe(nil), &blk); end

  def parent; end
  def resource(name, options = T.unsafe(nil), &blk); end
  def resources(name, options = T.unsafe(nil), &blk); end
  def wildcard_param(route_param = T.unsafe(nil)); end

  private

  def _resource(klass, name, options, &blk); end
  def collection(&blk); end
  def generate(&blk); end
  def member(&blk); end

  class << self
    def action; end
    def action=(_arg0); end
    def actions; end
    def actions=(_arg0); end
    def collection; end
    def collection=(_arg0); end
    def member; end
    def member=(_arg0); end
  end
end

class Hanami::Routing::Resource::Action
  include ::Hanami::Utils::ClassAttribute
  extend ::Hanami::Utils::ClassAttribute::ClassMethods

  def initialize(router, options = T.unsafe(nil), resource = T.unsafe(nil), &blk); end

  def generate(&blk); end
  def namespace; end
  def resource_name; end

  private

  def _nested_rest_path; end
  def _singularized_as; end
  def action_name; end
  def as; end
  def controller_name; end
  def endpoint; end
  def path; end
  def rest_path; end
  def separator; end
  def verb; end

  class << self
    def class_for(action); end
    def generate(router, action, options = T.unsafe(nil), resource = T.unsafe(nil)); end
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

Hanami::Routing::Resource::Action::NESTED_ROUTES_SEPARATOR = T.let(T.unsafe(nil), String)

class Hanami::Routing::Resource::CollectionAction < ::Hanami::Routing::Resource::Action
  def generate(&blk); end

  protected

  def method_missing(m, *args); end

  private

  def as(action_name); end
  def endpoint(action_name); end
  def path(action_name); end

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resource::Create < ::Hanami::Routing::Resource::Action
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

module Hanami::Routing::Resource::DefaultMemberAction
  private

  def as; end
  def path; end
end

class Hanami::Routing::Resource::Destroy < ::Hanami::Routing::Resource::Action
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resource::Edit < ::Hanami::Routing::Resource::Action
  include ::Hanami::Routing::Resource::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resource::MemberAction < ::Hanami::Routing::Resource::CollectionAction
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

Hanami::Routing::Resource::NESTED_ROUTES_SEPARATOR = T.let(T.unsafe(nil), String)

class Hanami::Routing::Resource::Nested
  def initialize(resource_name, resource); end

  def to_path; end

  private

  def _calculate(param_wildcard, resource = T.unsafe(nil)); end
end

Hanami::Routing::Resource::Nested::SEPARATOR = T.let(T.unsafe(nil), String)

class Hanami::Routing::Resource::New < ::Hanami::Routing::Resource::Action
  include ::Hanami::Routing::Resource::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resource::Options
  def initialize(actions, options = T.unsafe(nil)); end

  def [](key); end
  def actions; end
  def merge(hash); end
end

class Hanami::Routing::Resource::Show < ::Hanami::Routing::Resource::Action
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resource::Update < ::Hanami::Routing::Resource::Action
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resources < ::Hanami::Routing::Resource
  def wildcard_param(route_param = T.unsafe(nil)); end

  class << self
    def action; end
    def action=(_arg0); end
    def actions; end
    def actions=(_arg0); end
    def collection; end
    def collection=(_arg0); end
    def member; end
    def member=(_arg0); end
  end
end

class Hanami::Routing::Resources::Action < ::Hanami::Routing::Resource::Action
  class << self
    def identifier; end
    def identifier=(_arg0); end
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resources::CollectionAction < ::Hanami::Routing::Resource::CollectionAction
  def as(action_name); end

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resources::Create < ::Hanami::Routing::Resource::Create
  include ::Hanami::Routing::Resources::PluralizedAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

module Hanami::Routing::Resources::DefaultMemberAction
  private

  def path; end
end

class Hanami::Routing::Resources::Destroy < ::Hanami::Routing::Resource::Destroy
  include ::Hanami::Routing::Resources::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resources::Edit < ::Hanami::Routing::Resource::Edit
  include ::Hanami::Routing::Resources::DefaultMemberAction

  private

  def path; end

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resources::Index < ::Hanami::Routing::Resources::Action
  include ::Hanami::Routing::Resources::PluralizedAction

  class << self
    def identifier; end
    def identifier=(_arg0); end
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resources::MemberAction < ::Hanami::Routing::Resource::MemberAction
  private

  def path(action_name); end

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resources::New < ::Hanami::Routing::Resource::New
  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

module Hanami::Routing::Resources::PluralizedAction
  private

  def as; end
end

class Hanami::Routing::Resources::Show < ::Hanami::Routing::Resource::Show
  include ::Hanami::Routing::Resources::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Resources::Update < ::Hanami::Routing::Resource::Update
  include ::Hanami::Routing::Resources::DefaultMemberAction

  class << self
    def named_route_separator; end
    def named_route_separator=(_arg0); end
    def namespace; end
    def namespace=(_arg0); end
    def verb; end
    def verb=(_arg0); end
  end
end

class Hanami::Routing::Route < ::HttpRouter::Route
  def initialize(*_arg0); end

  def generate(resolver, options = T.unsafe(nil), &endpoint); end
  def nested_router; end

  private

  def to=(dest = T.unsafe(nil), &blk); end
end

Hanami::VERSION = T.let(T.unsafe(nil), String)

class HttpRouter
  def initialize(*args, &blk); end

  def add(*args, &app); end
  def add_route(route); end
  def call(env, &callback); end
  def clone(klass = T.unsafe(nil)); end
  def compiling_call(env, &callback); end
  def compiling_path(route, *args); end
  def compiling_url(route, *args); end
  def compiling_url_ns(route, *args); end
  def default(app); end
  def default_app; end
  def default_app=(_arg0); end
  def default_host; end
  def default_host=(_arg0); end
  def default_port; end
  def default_port=(_arg0); end
  def default_scheme; end
  def default_scheme=(_arg0); end
  def delete(path, opts = T.unsafe(nil), &app); end
  def extend_route(&blk); end
  def get(path, opts = T.unsafe(nil), &app); end
  def head(path, opts = T.unsafe(nil), &app); end
  def ignore_trailing_slash?; end
  def inspect; end
  def link(path, opts = T.unsafe(nil), &app); end
  def named_routes; end
  def no_response(request, env); end
  def nodes; end
  def options(path, opts = T.unsafe(nil), &app); end
  def pass_on_response(response); end
  def patch(path, opts = T.unsafe(nil), &app); end
  def path(route, *args); end
  def post(path, opts = T.unsafe(nil), &app); end
  def process_destination_path(path, env); end
  def put(path, opts = T.unsafe(nil), &app); end
  def raw_call(env, &blk); end
  def raw_path(route, *args); end
  def raw_url(route, *args); end
  def raw_url_ns(route, *args); end
  def recognize(env, &callback); end
  def redirect_trailing_slash?; end
  def reset!; end
  def rewrite_partial_path_info(env, request); end
  def rewrite_path_info(env, request); end
  def root; end
  def route_class; end
  def route_class=(_arg0); end
  def routes; end
  def to_s; end
  def trace(path, opts = T.unsafe(nil), &app); end
  def uncompile; end
  def unlink(path, opts = T.unsafe(nil), &app); end
  def url(route, *args); end
  def url_mount; end
  def url_mount=(_arg0); end
  def url_ns(route, *args); end

  private

  def add_with_request_method(path, method, opts = T.unsafe(nil), &app); end
  def compile; end
end

class HttpRouter::AmbiguousVariableException < ::RuntimeError; end
class HttpRouter::InvalidRequestValueError < ::RuntimeError; end
class HttpRouter::InvalidRouteException < ::RuntimeError; end
class HttpRouter::LeftOverOptions < ::RuntimeError; end
class HttpRouter::MissingParameterException < ::RuntimeError; end

class HttpRouter::Node
  def initialize(router, parent, matchers = T.unsafe(nil)); end

  def add_destination(route, path, param_names = T.unsafe(nil)); end
  def add_free_match(regexp); end
  def add_glob; end
  def add_glob_regexp(matcher); end
  def add_host(hosts); end
  def add_lookup(part); end
  def add_match(regexp, matching_indicies = T.unsafe(nil), splitting_indicies = T.unsafe(nil)); end
  def add_request_method(rm); end
  def add_scheme(scheme); end
  def add_spanning_match(regexp, matching_indicies = T.unsafe(nil), splitting_indicies = T.unsafe(nil)); end
  def add_user_agent(uas); end
  def add_variable; end
  def depth; end
  def inspect; end
  def inspect_label; end
  def inspect_matchers_body; end
  def router; end
  def usable?(other); end

  private

  def add(matcher); end
  def inject_root_ivar(obj); end
  def inject_root_methods(code = T.unsafe(nil), &blk); end
  def root; end
  def to_code; end
  def use_named_captures?; end
end

class HttpRouter::Node::Path < ::HttpRouter::Node
  def initialize(router, parent, route, path, param_names = T.unsafe(nil)); end

  def duplicates; end
  def dynamic; end
  def dynamic?; end
  def hashify_params(params); end
  def inspect_label; end
  def param_names; end
  def path; end
  def route; end
  def to_code; end
  def usable?(other); end
end

class HttpRouter::RecognizeResponse < ::Struct
  def acceptable_methods; end
  def acceptable_methods=(_); end
  def matches; end
  def matches=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class HttpRouter::TooManyParametersException < ::RuntimeError; end

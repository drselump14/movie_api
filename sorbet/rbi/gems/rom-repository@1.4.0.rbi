# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rom-repository` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module ROM
  include ::Dry::Core::Constants
  extend ::ROM::Global

  class << self
    def container(*args, &block); end
  end
end

class ROM::AdapterLoadError < ::StandardError; end

class ROM::Changeset
  extend ::Dry::Core::ClassAttributes
  include ::ROM::Initializer::InstanceMethods
  include ::Dry::Core::Cache::Methods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::Dry::Core::Cache
  extend ::Dry::Core::Constants
  include ::Dry::Initializer::InstanceDSL

  def command; end
  def commit; end
  def inspect; end
  def new(relation, new_options = T.unsafe(nil)); end
  def with(new_options); end

  private

  def relation_identifier; end

  class << self
    def [](relation_name); end
  end
end

class ROM::Changeset::Associated
  include ::Dry::Initializer::InstanceDSL
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer

  def associate(other, name = T.unsafe(nil)); end
  def command; end
  def commit; end
  def relation; end

  class << self
    def infer_assoc_name(other); end
  end
end

class ROM::Changeset::Create < ::ROM::Changeset::Stateful
  def command; end
end

ROM::Changeset::DEFAULT_COMMAND_OPTS = T.let(T.unsafe(nil), Hash)

class ROM::Changeset::Delete < ::ROM::Changeset
  include ::ROM::Changeset::Restricted
end

class ROM::Changeset::Pipe < ::Transproc::Transformer
  include ::Dry::Initializer::InstanceDSL
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer

  def >>(other, use_for_diff: T.unsafe(nil)); end
  def [](name); end
  def bind(context); end
  def bind_processor(processor, context); end
  def call(data); end
  def compose(other, use_for_diff: T.unsafe(nil)); end
  def for_diff(data); end
  def new(processor, opts = T.unsafe(nil)); end
  def with(opts); end

  class << self
    def [](name); end
  end
end

module ROM::Changeset::PipeRegistry
  extend ::Transproc::Registry

  class << self
    def add_timestamps(data); end
    def touch(data); end
  end
end

module ROM::Changeset::Restricted
  def by_pk(pk, data = T.unsafe(nil)); end
  def command; end
end

class ROM::Changeset::Stateful < ::ROM::Changeset
  def associate(other, name = T.unsafe(nil)); end
  def command; end
  def commit; end
  def data(data); end
  def extend(*steps, use_for_diff: T.unsafe(nil), **opts, &block); end
  def inspect; end
  def map(*steps, &block); end
  def pipe; end
  def result; end
  def to_a; end
  def to_ary; end
  def to_h; end
  def to_hash; end

  private

  def method_missing(meth, *args, &block); end
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end

  class << self
    def default_pipe(context); end
    def extend(*_arg0, &block); end
    def inherited(klass); end
    def map(options = T.unsafe(nil), &block); end
    def pipes; end
  end
end

ROM::Changeset::Stateful::EMPTY_PIPE = T.let(T.unsafe(nil), ROM::Changeset::Pipe)

class ROM::Changeset::Update < ::ROM::Changeset::Stateful
  include ::ROM::Changeset::Restricted

  def clean?; end
  def commit; end
  def diff; end
  def diff?; end
  def original; end
end

class ROM::CommandError < ::StandardError; end
class ROM::DuplicateConfigurationError < ::StandardError; end
class ROM::DuplicateContainerError < ::StandardError; end
ROM::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ROM::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
ROM::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
ROM::EMPTY_SET = T.let(T.unsafe(nil), Set)
ROM::EMPTY_STRING = T.let(T.unsafe(nil), String)
class ROM::EnvAlreadyFinalizedError < ::StandardError; end
ROM::IDENTITY = T.let(T.unsafe(nil), Proc)
class ROM::InvalidOptionKeyError < ::StandardError; end
class ROM::InvalidOptionValueError < ::StandardError; end
class ROM::KeyMissing < ::ROM::CommandError; end
class ROM::MapperMisconfiguredError < ::StandardError; end
class ROM::MapperMissingError < ::StandardError; end
class ROM::MissingAdapterIdentifierError < ::StandardError; end
class ROM::NoRelationError < ::StandardError; end

class ROM::OpenStruct
  def initialize(attributes); end

  private

  def method_missing(meth, *args, &block); end
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

ROM::OpenStruct::IVAR = T.let(T.unsafe(nil), Proc)
class ROM::RelationAlreadyDefinedError < ::StandardError; end

class ROM::Repository
  include ::Dry::Initializer::InstanceDSL
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Repository::ClassInterface
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  def initialize(container, opts = T.unsafe(nil)); end

  def changeset(*args); end
  def command(*args, **opts, &block); end
  def command_compiler; end
  def inspect; end
  def mappers; end
  def relations; end
  def session(&block); end
  def transaction(&block); end

  private

  def commands; end
  def compile_command(*args, mapper: T.unsafe(nil), use: T.unsafe(nil), **opts); end
  def map_tuple(relation, tuple); end
end

ROM::Repository::CHANGESET_TYPES = T.let(T.unsafe(nil), Hash)

module ROM::Repository::ClassInterface
  def [](name); end
  def commands(*names, mapper: T.unsafe(nil), use: T.unsafe(nil), **opts); end
  def inherited(klass); end
  def relations(*names); end

  private

  def define_command_method(type, **opts); end
  def define_restricted_command_method(type, views, **opts); end
end

class ROM::Repository::CommandCompiler
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  def initialize(id, adapter, container, registry, plugins, options); end

  def adapter; end
  def container; end
  def id; end
  def options; end
  def plugins; end
  def registry; end
  def type; end
  def visit(ast, *args); end

  private

  def finalize_command_class(klass, relation); end
  def register_command(rel_name, type, meta, parent_relation = T.unsafe(nil)); end
  def result; end
  def setup_associates(klass, relation, meta, parent_relation); end
  def visit_attribute(*args); end
  def visit_header(node, *args); end
  def visit_relation(node, parent_relation = T.unsafe(nil)); end

  class << self
    def [](*args); end
    def registry; end
  end
end

class ROM::Repository::CommandProxy
  def initialize(command); end

  def >>(other); end
  def call(input); end
  def command; end
  def root; end
end

class ROM::Repository::HeaderBuilder
  def initialize(struct_namespace: T.unsafe(nil), **options); end

  def [](ast); end
  def call(ast); end
  def struct_builder; end

  private

  def visit(node); end
  def visit_attribute(attr); end
  def visit_header(node); end
  def visit_relation(node); end
end

class ROM::Repository::MapperBuilder
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  def initialize(options = T.unsafe(nil)); end

  def [](ast); end
  def call(ast); end
  def header_builder; end
end

class ROM::Repository::RelationProxy
  extend ::Dry::Core::Deprecations::Interface
  include ::ROM::Initializer::InstanceMethods
  include ::ROM::Relation::Materializable
  include ::ROM::Repository::RelationProxy::Combine
  include ::ROM::Repository::RelationProxy::Wrap
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  include ::Dry::Initializer::InstanceDSL

  def adapter; end
  def as(*names, **opts); end
  def call(*args); end
  def combine?; end
  def combine_children(*args, &block); end
  def combine_parents(*args, &block); end
  def composite?; end
  def inspect; end
  def map_to(model); end
  def map_with(*names, **opts); end
  def mapper; end
  def name; end
  def node(name, &block); end
  def to_ast; end
  def with(new_options); end
  def wrap_parent(*args, &block); end

  private

  def __new__(relation, new_options = T.unsafe(nil)); end
  def base_name; end
  def combine_children_without_deprecation(options); end
  def combine_parents_without_deprecation(options); end
  def method_missing(meth, *args, &block); end
  def nodes; end
  def nodes_ast; end
  def respond_to_missing?(meth, _include_private = T.unsafe(nil)); end
  def schema; end
  def wrap_parent_without_deprecation(options); end
  def wraps; end
  def wraps_ast; end
end

module ROM::Repository::RelationProxy::Combine
  def combine(*args); end
  def combine_children(options); end
  def combine_parents(options); end
  def combined(name, keys, type); end

  protected

  def combine_from_assoc(name, other, &fallback); end
  def combine_from_assoc_with_fallback(name, other, keys); end
  def combine_keys(source, target, type); end
  def combine_method(other, keys); end
  def combine_opts_for_assoc(name, opts = T.unsafe(nil)); end
  def combine_opts_from_relations(*relations); end
  def combine_tuple_key(result); end
  def infer_combine_keys(source, target, type); end
end

ROM::Repository::RelationProxy::RelationRegistryType = T.let(T.unsafe(nil), Dry::Types::Constrained)

module ROM::Repository::RelationProxy::Wrap
  def wrap(*names, **options); end
  def wrap_parent(options); end
  def wrapped(name, keys, wrap_from_assoc = T.unsafe(nil)); end
  def wraps_from_names(names); end
  def wraps_from_options(options); end
end

class ROM::Repository::Root < ::ROM::Repository
  def initialize(container, opts = T.unsafe(nil)); end

  def aggregate(*args); end
  def changeset(*args); end
  def root; end

  class << self
    def inherited(klass); end
  end
end

class ROM::Repository::StructBuilder
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  def initialize(namespace = T.unsafe(nil)); end

  def [](*args); end
  def call(*args); end
  def namespace; end

  private

  def build_class(name, parent, &block); end
  def class_name(name); end
  def visit(ast); end
  def visit_attribute(attr); end
  def visit_header(node); end
  def visit_relation(node); end
end

ROM::Self = T.let(T.unsafe(nil), Proc)

class ROM::Session
  include ::Dry::Core::Equalizer::Methods

  def initialize(repo); end

  def add(changeset); end
  def commit!; end
  def failure?; end
  def pending?; end
  def queue; end
  def repo; end
  def status; end
  def success?; end

  private

  def initialize_queue!; end
end

class ROM::Struct < ::Dry::Struct
  include ::Dry::Equalizer::Methods

  def fetch(name); end
  def to_s; end

  private

  def method_missing(method, *_arg1); end
  def respond_to_missing?(*_arg0); end
end

class ROM::Struct::MissingAttribute < ::NameError; end
class ROM::TupleCountMismatchError < ::ROM::CommandError; end
ROM::Undefined = T.let(T.unsafe(nil), Object)
class ROM::UnknownPluginError < ::StandardError; end
class ROM::UnsupportedRelationError < ::StandardError; end
ROM::VERSION = T.let(T.unsafe(nil), String)

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-validation` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Dry
  class << self
    def AutoInject(container, options = T.unsafe(nil)); end
    def Equalizer(*keys, **options); end
  end
end

module Dry::Validation
  include ::Dry::Core::Constants
  extend ::Dry::Core::Extensions

  class << self
    def Form(base = T.unsafe(nil), **options, &block); end
    def JSON(base = T.unsafe(nil), **options, &block); end
    def Schema(base = T.unsafe(nil), **options, &block); end
    def messages_paths; end
  end
end

class Dry::Validation::ApplyChecks < ::Dry::Validation::ApplyRules
  def call(input, result); end
end

class Dry::Validation::ApplyInputRule
  def initialize(rule); end

  def call(input, result); end
  def rule; end
end

class Dry::Validation::ApplyRules
  def initialize(rules); end

  def call(input, result); end
  def rules; end
end

class Dry::Validation::BuildErrors
  def call(result); end
end

module Dry::Validation::Deprecations
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  def logger; end
  def warn(msg); end

  class << self
    def format(msg, caller); end
  end
end

Dry::Validation::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Validation::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Validation::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Validation::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Validation::EMPTY_STRING = T.let(T.unsafe(nil), String)

class Dry::Validation::Executor
  def initialize(final); end

  def call(input, result = T.unsafe(nil)); end
  def final; end
  def steps; end

  class << self
    def new(&block); end
  end
end

class Dry::Validation::Guard
  def initialize(rule, deps); end

  def call(input, results); end
  def deps; end
  def rule; end
  def with(options); end

  private

  def deps_valid?(results); end
end

class Dry::Validation::Hint < ::Dry::Validation::Message
  def hint?; end

  class << self
    def [](predicate, path, text, options); end
  end
end

Dry::Validation::IDENTITY = T.let(T.unsafe(nil), Proc)

class Dry::Validation::InputProcessorCompiler
  def initialize; end

  def call(ast); end
  def constructor(type); end
  def schema_ast(ast); end
  def type(predicate, args); end
  def type_compiler; end
  def visit(node, *args); end
  def visit_and(node, first = T.unsafe(nil)); end
  def visit_each(node, *args); end
  def visit_implication(node, *args); end
  def visit_key(node, *args); end
  def visit_not(node, *args); end
  def visit_or(node, *args); end
  def visit_predicate(node, *_arg1); end
  def visit_rule(node, *args); end
  def visit_schema(schema, *args); end
  def visit_set(node, *_arg1); end
  def visit_type(type, *args); end
  def visit_val(node, *args); end
end

Dry::Validation::InputProcessorCompiler::DEFAULT_TYPE_NODE = T.let(T.unsafe(nil), Array)

class Dry::Validation::InputProcessorCompiler::Form < ::Dry::Validation::InputProcessorCompiler
  def array_node(members); end
  def hash_node(schema); end
  def identifier; end
end

Dry::Validation::InputProcessorCompiler::Form::CONST_MAP = T.let(T.unsafe(nil), Hash)
Dry::Validation::InputProcessorCompiler::Form::PREDICATE_MAP = T.let(T.unsafe(nil), Hash)

class Dry::Validation::InputProcessorCompiler::JSON < ::Dry::Validation::InputProcessorCompiler
  def array_node(members); end
  def hash_node(schema); end
  def identifier; end
end

Dry::Validation::InputProcessorCompiler::JSON::CONST_MAP = T.let(T.unsafe(nil), Hash)
Dry::Validation::InputProcessorCompiler::JSON::PREDICATE_MAP = T.let(T.unsafe(nil), Hash)

class Dry::Validation::InputProcessorCompiler::Sanitizer < ::Dry::Validation::InputProcessorCompiler
  def array_node(members); end
  def hash_node(schema); end
  def identifier; end
end

Dry::Validation::InputProcessorCompiler::Sanitizer::CONST_MAP = T.let(T.unsafe(nil), Hash)
Dry::Validation::InputProcessorCompiler::Sanitizer::PREDICATE_MAP = T.let(T.unsafe(nil), Hash)
class Dry::Validation::InvalidSchemaError < ::StandardError; end

class Dry::Validation::Message
  include ::Dry::Core::Equalizer::Methods

  def initialize(predicate, path, text, options); end

  def args; end
  def eql?(other); end
  def hint?; end
  def options; end
  def path; end
  def predicate; end
  def root?; end
  def rule; end
  def signature; end
  def text; end
  def to_s; end

  class << self
    def [](predicate, path, text, options); end
  end
end

class Dry::Validation::Message::Check < ::Dry::Validation::Message
  def initialize(*args); end
end

class Dry::Validation::Message::Or
  def initialize(left, right, messages); end

  def hint?; end
  def left; end
  def messages; end
  def path; end
  def right; end
  def root?; end
  def to_s; end
end

class Dry::Validation::MessageCompiler
  def initialize(messages, options = T.unsafe(nil)); end

  def call(ast); end
  def default_lookup_options; end
  def full?; end
  def hints?; end
  def locale; end
  def lookup_options(arg_vals: T.unsafe(nil), input: T.unsafe(nil)); end
  def message_text(rule, template, tokens, opts); end
  def message_tokens(args); end
  def messages; end
  def options; end
  def visit(node, *args); end
  def visit_and(node, opts = T.unsafe(nil)); end
  def visit_check(node, opts = T.unsafe(nil)); end
  def visit_each(node, opts = T.unsafe(nil)); end
  def visit_failure(node, opts = T.unsafe(nil)); end
  def visit_hint(node, opts = T.unsafe(nil)); end
  def visit_implication(node, *args); end
  def visit_key(node, opts = T.unsafe(nil)); end
  def visit_not(node, opts = T.unsafe(nil)); end
  def visit_or(node, opts = T.unsafe(nil)); end
  def visit_predicate(node, base_opts = T.unsafe(nil)); end
  def visit_rule(node, opts = T.unsafe(nil)); end
  def visit_schema(node, opts = T.unsafe(nil)); end
  def visit_set(node, opts = T.unsafe(nil)); end
  def visit_type(node, opts = T.unsafe(nil)); end
  def visit_xor(node, opts = T.unsafe(nil)); end
  def with(new_options); end
end

Dry::Validation::MessageCompiler::EMPTY_OPTS = T.let(T.unsafe(nil), Dry::Validation::MessageCompiler::VisitorOpts)
Dry::Validation::MessageCompiler::LIST_SEPARATOR = T.let(T.unsafe(nil), String)

class Dry::Validation::MessageCompiler::VisitorOpts < ::Hash
  def call(other); end
  def path; end
  def path?; end
  def rule; end
  def with_rule(new_rule, **other); end

  class << self
    def new; end
  end
end

class Dry::Validation::MessageSet
  include ::Enumerable

  def initialize(messages, options = T.unsafe(nil)); end

  def dump; end
  def each(&block); end
  def empty?; end
  def failures; end
  def failures?; end
  def hints; end
  def messages; end
  def options; end
  def paths; end
  def placeholders; end
  def root?; end
  def to_a; end
  def to_h; end
  def to_hash; end

  private

  def hint_groups; end
  def hints_map; end
  def initialize_hints!; end
  def initialize_placeholders!; end
  def messages_map; end

  class << self
    def [](messages, options = T.unsafe(nil)); end
  end
end

Dry::Validation::MessageSet::HINT_EXCLUSION = T.let(T.unsafe(nil), Array)

module Dry::Validation::Messages
  class << self
    def default; end
  end
end

class Dry::Validation::Messages::Abstract
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  def initialize; end

  def [](*args); end
  def cache; end
  def call(*args); end
  def config; end
  def default_locale; end
  def hash; end
  def lookup(predicate, options = T.unsafe(nil)); end
  def lookup_paths(tokens); end
  def namespaced(namespace); end
  def root; end
  def rule(name, options = T.unsafe(nil)); end

  class << self
    def cache; end
  end
end

Dry::Validation::Messages::Abstract::DEFAULT_PATH = T.let(T.unsafe(nil), Pathname)

class Dry::Validation::Messages::Namespaced < ::Dry::Validation::Messages::Abstract
  def initialize(namespace, messages); end

  def default_locale; end
  def get(key, options = T.unsafe(nil)); end
  def key?(key, *args); end
  def lookup_paths(tokens); end
  def messages; end
  def namespace; end
  def root; end
end

class Dry::Validation::Messages::YAML < ::Dry::Validation::Messages::Abstract
  def initialize(data); end

  def data; end
  def get(key, options = T.unsafe(nil)); end
  def key?(key, options = T.unsafe(nil)); end
  def merge(overrides); end

  class << self
    def flat_hash(h, f = T.unsafe(nil), g = T.unsafe(nil)); end
    def load(paths = T.unsafe(nil)); end
    def load_file(path); end
  end
end

class Dry::Validation::MissingMessageError < ::StandardError; end

class Dry::Validation::PredicateRegistry
  def initialize(external, predicates = T.unsafe(nil)); end

  def [](name); end
  def arg_list(name, *values); end
  def ensure_valid_predicate(name, args_or_arity, schema = T.unsafe(nil)); end
  def external; end
  def key?(name); end
  def new(klass); end
  def predicates; end

  private

  def raise_invalid_arity_error(name); end
  def raise_unknown_predicate_error(name); end

  class << self
    def [](klass, predicates); end
  end
end

class Dry::Validation::PredicateRegistry::Bound < ::Dry::Validation::PredicateRegistry
  def initialize(*args); end

  def schema; end
end

class Dry::Validation::PredicateRegistry::Unbound < ::Dry::Validation::PredicateRegistry
  def bind(schema); end
  def update(other); end
end

class Dry::Validation::ProcessInput
  def initialize(processor); end

  def call(input, *_arg1); end
  def processor; end
end

class Dry::Validation::Result
  include ::Dry::Core::Equalizer::Methods
  include ::Enumerable

  def initialize(output, results, message_compiler, path); end

  def [](name); end
  def ast(*_arg0); end
  def each(&block); end
  def errors(options = T.unsafe(nil)); end
  def failure?; end
  def hints(options = T.unsafe(nil)); end
  def message_compiler; end
  def message_set(options = T.unsafe(nil)); end
  def messages(options = T.unsafe(nil)); end
  def name; end
  def output; end
  def path; end
  def results; end
  def success?; end
  def to_ast; end
  def to_h; end
  def to_hash; end

  private

  def result_ast; end
  def type; end
end

class Dry::Validation::Schema
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods
  extend ::Dry::Validation::TypeSpecs

  def initialize(rules, options); end

  def arity; end
  def ast(*_arg0); end
  def call(input); end
  def checks; end
  def config; end
  def curry(*curry_args); end
  def executor; end
  def input_processor; end
  def input_rule; end
  def message_compiler; end
  def options; end
  def predicates; end
  def rule_compiler; end
  def rules; end
  def to_ast(*_arg0); end
  def to_proc; end
  def type_map; end
  def with(new_options); end

  private

  def initialize_checks(checks); end
  def initialize_options(options); end
  def initialize_rules(rules); end

  class << self
    def clone; end
    def create_class(target, other = T.unsafe(nil), &block); end
    def default_messages; end
    def default_options; end
    def define(options = T.unsafe(nil), &block); end
    def define!(options = T.unsafe(nil), &block); end
    def inherited(klass); end
    def input_processor; end
    def input_processor_ast(type); end
    def input_processor_compiler; end
    def message_compiler; end
    def messages; end
    def new(rules = T.unsafe(nil), **options); end
    def option(name, default = T.unsafe(nil)); end
    def options; end
    def predicates(predicate_set = T.unsafe(nil)); end
    def registry; end
    def rule_ast; end
    def rules; end
    def set_registry!; end
    def to_ast; end
    def type_map; end
  end
end

class Dry::Validation::Schema::Check < ::Dry::Validation::Schema::Value
  def class; end
  def schema(other = T.unsafe(nil), &block); end

  private

  def method_missing(meth, *meth_args); end
end

class Dry::Validation::Schema::DSL < ::BasicObject
  include ::Dry::Validation::Deprecations

  def initialize(options = T.unsafe(nil)); end

  def add_check(check); end
  def add_rule(rule); end
  def checks; end
  def inspect; end
  def name; end
  def not; end
  def optional(name, type_spec = T.unsafe(nil), &block); end
  def options; end
  def parent; end
  def path; end
  def predicate(name, args = T.unsafe(nil)); end
  def predicate?(meth); end
  def registry; end
  def rule_ast; end
  def rules; end
  def to_ast; end
  def to_rule; end
  def to_s; end
  def with(new_options); end

  private

  def create_rule(node, name = T.unsafe(nil)); end
  def define(name, key_class, op = T.unsafe(nil), &block); end

  class << self
    def [](name, options = T.unsafe(nil)); end
  end
end

class Dry::Validation::Schema::Form < ::Dry::Validation::Schema
  class << self
    def configure(klass = T.unsafe(nil), &block); end
    def method_added(name); end
  end
end

class Dry::Validation::Schema::JSON < ::Dry::Validation::Schema
  class << self
    def configure(klass = T.unsafe(nil), &block); end
    def method_added(name); end
  end
end

class Dry::Validation::Schema::Key < ::Dry::Validation::Schema::DSL
  def class; end
  def each(*predicates, &block); end
  def hash?(&block); end
  def parent; end
  def schema(other = T.unsafe(nil), &block); end
  def to_ast; end
  def type; end
  def value; end

  private

  def method_missing(meth, *args, &block); end

  class << self
    def type; end
  end
end

Dry::Validation::Schema::NOOP_INPUT_PROCESSOR = T.let(T.unsafe(nil), Proc)

class Dry::Validation::Schema::Rule < ::BasicObject
  include ::Dry::Validation::Deprecations

  def initialize(node, options = T.unsafe(nil)); end

  def &(other); end
  def >(other); end
  def ^(other); end
  def add_rule(rule); end
  def and(other); end
  def checks; end
  def class; end
  def deps; end
  def each(*predicates, &block); end
  def filled(*predicates, &block); end
  def infer_predicates(predicates, macro = T.unsafe(nil)); end
  def inspect; end
  def maybe(*predicates, &block); end
  def name; end
  def node; end
  def not; end
  def options; end
  def or(other); end
  def registry; end
  def required(*predicates); end
  def rule_ast; end
  def rules; end
  def schema(other = T.unsafe(nil), &block); end
  def schema?; end
  def target; end
  def then(other); end
  def to_ast; end
  def to_rule; end
  def to_s; end
  def type; end
  def type_map; end
  def type_map?; end
  def value(*predicates, &block); end
  def with(new_options); end
  def xor(other); end
  def |(other); end

  private

  def key(predicate, args = T.unsafe(nil)); end
  def method_missing(meth, *args, &block); end
  def new(node); end
end

Dry::Validation::Schema::Rule::INVALID_PREDICATES = T.let(T.unsafe(nil), Hash)

class Dry::Validation::Schema::Value < ::Dry::Validation::Schema::DSL
  def initialize(options = T.unsafe(nil)); end

  def check(name, options = T.unsafe(nil)); end
  def class; end
  def configure(&block); end
  def confirmation; end
  def dyn_arg?(name); end
  def each(*predicates, &block); end
  def infer_predicates(predicates, infer_on = T.unsafe(nil)); end
  def input(*predicates); end
  def key(name, &block); end
  def key?(name); end
  def new; end
  def node(input, *args); end
  def predicates(mod); end
  def required(name, type_spec = T.unsafe(nil), &block); end
  def respond_to?(name); end
  def root?; end
  def rule(id = T.unsafe(nil), **options, &block); end
  def schema(other = T.unsafe(nil), &block); end
  def schema?; end
  def schema_class; end
  def type; end
  def type_map; end
  def type_map?; end
  def validate(**opts, &block); end
  def value(path, opts = T.unsafe(nil)); end
  def when(*predicates, &block); end

  private

  def method_missing(meth, *args, &block); end
end

class Dry::Validation::SchemaCompiler < ::Dry::Logic::RuleCompiler
  def initialize(*args, options); end

  def options; end
  def schema; end
  def visit_custom(node); end
  def visit_guard(node); end
  def visit_predicate(node); end
  def visit_rule(node); end
  def visit_schema(klass); end
  def visit_type(type); end
end

Dry::Validation::Self = T.let(T.unsafe(nil), Proc)

module Dry::Validation::TypeSpecs
  def build_array_type(spec, category); end
  def build_hash_type(spec = T.unsafe(nil)); end
  def build_sum_type(spec, category); end
  def build_type_map(type_specs, category = T.unsafe(nil)); end
  def lookup_type(name, category); end
  def resolve_spec(spec, category); end

  class << self
    def extended(klass); end
  end
end

Dry::Validation::Undefined = T.let(T.unsafe(nil), Object)
Dry::Validation::VERSION = T.let(T.unsafe(nil), String)

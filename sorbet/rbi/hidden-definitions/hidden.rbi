# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(obj); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format=T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
end

class ActiveSupport::Deprecation
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*args, &block); end

  def acts_like_string?(*args, &block); end

  def capitalize(); end

  def capitalize!(*args); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def swapcase(); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
  def self.consumes?(string); end
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def downcase(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def pack_graphemes(unpacked); end

  def reorder_characters(codepoints); end

  def swapcase(string); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def unpack_graphemes(string); end

  def upcase(string); end
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class ActiveSupport::Multibyte::Unicode::Codepoint
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
end

module ActiveSupport
  def self.escape_html_entities_in_json(*args, &block); end

  def self.escape_html_entities_in_json=(arg); end

  def self.json_encoder(*args, &block); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(obj); end

  def self.time_precision(*args, &block); end

  def self.time_precision=(arg); end

  def self.use_standard_json_time_format(*args, &block); end

  def self.use_standard_json_time_format=(arg); end
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::Template
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::URI
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

module Anyway
  VERSION = ::T.let(nil, ::T.untyped)
end

module Anyway::AutoCast
  ARRAY_RXP = ::T.let(nil, ::T.untyped)
end

module Anyway::AutoCast
  def self.call(val); end
end

class Anyway::Config
  include ::Anyway::OptparseConfig
  include ::Anyway::DynamicConfig
  def clear(); end

  def config_name(); end

  def deconstruct_keys(keys); end

  def dig(*keys); end

  def env_prefix(); end

  def initialize(overrides=T.unsafe(nil)); end

  def load(overrides=T.unsafe(nil)); end

  def load_from_sources(base_config, **options); end

  def reload(overrides=T.unsafe(nil)); end

  def resolve_config_path(name, env_prefix); end

  def to_h(); end

  def to_source_trace(); end
  PARAM_NAME = ::T.let(nil, ::T.untyped)
  RESERVED_NAMES = ::T.let(nil, ::T.untyped)
end

class Anyway::Config::BlockCallback
  def apply_to(config); end

  def block(); end

  def initialize(block); end
end

class Anyway::Config::BlockCallback
end

class Anyway::Config::Error
end

class Anyway::Config::Error
end

class Anyway::Config::NamedCallback
  def apply_to(config); end

  def initialize(name); end

  def name(); end
end

class Anyway::Config::NamedCallback
end

class Anyway::Config::ValidationError
end

class Anyway::Config::ValidationError
end

class Anyway::Config
  extend ::Anyway::OptparseConfig::ClassMethods
  extend ::Anyway::DynamicConfig::ClassMethods
  def self.attr_config(*args, **hargs); end

  def self.config_attributes(); end

  def self.config_name(val=T.unsafe(nil)); end

  def self.defaults(); end

  def self.env_prefix(val=T.unsafe(nil)); end

  def self.explicit_config_name(); end

  def self.explicit_config_name?(); end

  def self.load_callbacks(); end

  def self.new_empty_config(); end

  def self.on_load(*names, &block); end

  def self.required(*names); end

  def self.required_attributes(); end
end

module Anyway::DynamicConfig
end

module Anyway::DynamicConfig::ClassMethods
  def for(name, **options); end
end

module Anyway::DynamicConfig::ClassMethods
end

module Anyway::DynamicConfig
  def self.included(base); end
end

class Anyway::Env
  include ::Anyway::Tracing
  def clear(); end

  def data(); end

  def fetch(prefix); end

  def fetch_with_trace(prefix); end

  def initialize(type_cast: T.unsafe(nil)); end

  def traces(); end

  def type_cast(); end
end

class Anyway::Env
end

module Anyway::Ext
end

module Anyway::Ext::DeepDup
end

module Anyway::Ext::DeepDup
end

module Anyway::Ext::DeepFreeze
end

module Anyway::Ext::DeepFreeze
end

module Anyway::Ext::Hash
end

module Anyway::Ext::Hash
end

module Anyway::Ext
end

module Anyway::Loaders
end

class Anyway::Loaders::Base
  include ::Anyway::Tracing
  def initialize(local:); end

  def use_local?(); end
end

class Anyway::Loaders::Base
  def self.call(local: T.unsafe(nil), **opts); end
end

class Anyway::Loaders::Env
  def call(env_prefix:, **_options); end
end

class Anyway::Loaders::Env
end

class Anyway::Loaders::Registry
  def append(id, handler=T.unsafe(nil), &block); end

  def delete(id); end

  def each(&block); end

  def insert_after(another_id, id, handler=T.unsafe(nil), &block); end

  def insert_before(another_id, id, handler=T.unsafe(nil), &block); end

  def override(id, handler); end

  def prepend(id, handler=T.unsafe(nil), &block); end

  def registry(); end
end

class Anyway::Loaders::Registry
end

class Anyway::Loaders::YAML
  def call(config_path:, **_options); end
end

class Anyway::Loaders::YAML
end

module Anyway::Loaders
end

class Anyway::OptionParserBuilder
end

class Anyway::OptionParserBuilder
  def self.call(options); end
end

module Anyway::OptparseConfig
  def option_parser(); end

  def parse_options!(options); end
end

module Anyway::OptparseConfig::ClassMethods
  def describe_options(**hargs); end

  def extend_options(&block); end

  def flag_options(*args); end

  def ignore_options(*args); end

  def option_parser_descriptors(); end

  def option_parser_extensions(); end

  def option_parser_options(); end
end

module Anyway::OptparseConfig::ClassMethods
end

module Anyway::OptparseConfig
  def self.included(base); end
end

class Anyway::Settings
end

class Anyway::Settings::Future
  def use(*names); end
end

class Anyway::Settings::Future
  def self.setting(name, default_value); end

  def self.settings(); end
end

class Anyway::Settings
  def self.default_config_path(); end

  def self.default_config_path=(val); end

  def self.future(); end

  def self.tracing_enabled(); end

  def self.tracing_enabled=(tracing_enabled); end

  def self.use_local_files(); end

  def self.use_local_files=(use_local_files); end
end

module Anyway::Tracing
end

class Anyway::Tracing::Trace
  def clear(); end

  def dig(*_, &_1); end

  def initialize(type=T.unsafe(nil), value=T.unsafe(nil), **source); end

  def keep_if(*_, &_1); end

  def merge!(another_trace); end

  def merge_values(hash, **opts); end

  def record_value(val, *path, **opts); end

  def source(); end

  def to_h(); end

  def trace?(); end

  def type(); end

  def value(); end
  UNDEF = ::T.let(nil, ::T.untyped)
end

class Anyway::Tracing::Trace
end

module Anyway::Tracing
  def self.capture(); end

  def self.current_trace(); end

  def self.current_trace_source(); end

  def self.source_stack(); end

  def self.trace!(type, *path, **opts); end

  def self.trace_stack(); end

  def self.tracing?(); end

  def self.with_trace_source(src); end
end

module Anyway::Utils
end

module Anyway::Utils
  def self.deep_merge!(source, other); end
end

module Anyway
  def self.env(); end

  def self.loaders(); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def abbrev(pattern=T.unsafe(nil)); end

  def deconstruct(); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end
end

class Array
  def self.parse(string); end

  def self.try_convert(_); end
end

module Backport
  VERSION = ::T.let(nil, ::T.untyped)
end

class Backport::Adapter
  def close(); end

  def closed?(); end

  def closing(); end

  def initialize(output, remote=T.unsafe(nil)); end

  def opening(); end

  def receiving(data); end

  def remote(); end

  def write(data); end

  def write_line(data); end
end

class Backport::Adapter
end

class Backport::Client
  include ::Observable
  def adapter(); end

  def initialize(input, output, adapter, remote=T.unsafe(nil)); end

  def run(); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Backport::Client
end

class Backport::Machine
  def prepare(server); end

  def run(); end

  def servers(); end

  def stop(); end

  def stopped?(); end

  def update(server); end
end

class Backport::Machine
end

module Backport::Server
end

class Backport::Server::Base
  include ::Observable
  def start(); end

  def started?(); end

  def starting(); end

  def stop(); end

  def stopped?(); end

  def stopping(); end

  def tick(); end
end

class Backport::Server::Base
end

module Backport::Server::Connectable
  def clients(); end

  def starting(); end

  def stopping(); end
end

module Backport::Server::Connectable
end

class Backport::Server::Interval
  def initialize(period, &block); end
end

class Backport::Server::Interval
end

class Backport::Server::Stdio
  include ::Backport::Server::Connectable
  def initialize(input: T.unsafe(nil), output: T.unsafe(nil), adapter: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Stdio
end

class Backport::Server::Tcpip
  include ::Backport::Server::Connectable
  def accept(); end

  def initialize(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil), socket_class: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Tcpip
end

module Backport::Server
end

BasicObject::BasicObject = BasicObject

module BetterErrors
  VERSION = ::T.let(nil, ::T.untyped)
end

class BetterErrors::CodeFormatter
  FILE_TYPES = ::T.let(nil, ::T.untyped)
end

class BetterErrors::Editor
  KNOWN_EDITORS = ::T.let(nil, ::T.untyped)
end

class BetterErrors::Middleware
  ALLOWED_IPS = ::T.let(nil, ::T.untyped)
  CSRF_TOKEN_COOKIE_NAME = ::T.let(nil, ::T.untyped)
end

module BetterErrors::REPL
  PROVIDERS = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module BigDecimal::Deprecation
  def new(*args, **kwargs); end
end

module BigDecimal::Deprecation
end

class BigDecimal
  extend ::BigDecimal::Deprecation
  def self.inherited(subclass); end

  def self.interpret_loosely(_); end

  def self.new(*_); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def dependencies_for(groups); end

  def disable_multisource?(); end

  def most_specific_locked_platform(); end

  def requested_dependencies(); end
end

class Bundler::DepProxy
  def clone(); end
end

class Bundler::DepProxy
  def self.get_proxy(dep, platform); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Dsl
  def check_primary_source_safety(); end
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_checksum(built_gem_path=T.unsafe(nil)); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def current_branch(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::LazySpecification
  def eql?(other); end

  def platform_string(); end
end

module Bundler::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def results_for(dependency, base); end

  def source_for(name); end
end

class Bundler::Resolver::SpecGroup
  def activated_platforms(); end

  def activated_platforms=(activated_platforms); end

  def sorted_activated_platforms(); end
end

class Bundler::Resolver::SpecGroup
  def self.create_for(specs, all_platforms, specific_platform); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def load_env_plugins(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def local!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def glob(); end

  def local?(); end
end

class Bundler::Source::Rubygems
  def dependency_api_available?(); end

  def disable_multisource?(); end
end

class Bundler::Source::RubygemsAggregate
  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def global_path_source(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(); end

  def merged_gem_lockfile_sections?(); end

  def no_aggregate_global_source?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::StubSpecification
  def default_gem?(); end

  def extensions(); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def are_colors_supported?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

module Byebug
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
end

class Byebug::FullpathSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::WidthSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module Capybara
  VERSION = ::T.let(nil, ::T.untyped)
end

class Capybara::Ambiguous
end

class Capybara::Ambiguous
end

class Capybara::CapybaraError
end

class Capybara::CapybaraError
end

class Capybara::Config
  def allow_gumbo(); end

  def allow_gumbo=(allow_gumbo); end

  def always_include_port(*args, &block); end

  def always_include_port=(*args, &block); end

  def app(); end

  def app=(app); end

  def app_host(*args, &block); end

  def app_host=(*args, &block); end

  def asset_host(*args, &block); end

  def asset_host=(*args, &block); end

  def automatic_label_click(*args, &block); end

  def automatic_label_click=(*args, &block); end

  def automatic_reload(*args, &block); end

  def automatic_reload=(*args, &block); end

  def default_driver(); end

  def default_driver=(default_driver); end

  def default_host(*args, &block); end

  def default_host=(*args, &block); end

  def default_max_wait_time(*args, &block); end

  def default_max_wait_time=(*args, &block); end

  def default_normalize_ws(*args, &block); end

  def default_normalize_ws=(*args, &block); end

  def default_selector(*args, &block); end

  def default_selector=(*args, &block); end

  def default_set_options(*args, &block); end

  def default_set_options=(*args, &block); end

  def deprecate(method, alternate_method, once: T.unsafe(nil)); end

  def disable_animation(*args, &block); end

  def disable_animation=(*args, &block); end

  def enable_aria_label(*args, &block); end

  def enable_aria_label=(*args, &block); end

  def enable_aria_role(*args, &block); end

  def enable_aria_role=(*args, &block); end

  def exact(*args, &block); end

  def exact=(*args, &block); end

  def exact_text(*args, &block); end

  def exact_text=(*args, &block); end

  def ignore_hidden_elements(*args, &block); end

  def ignore_hidden_elements=(*args, &block); end

  def javascript_driver(); end

  def javascript_driver=(javascript_driver); end

  def match(*args, &block); end

  def match=(*args, &block); end

  def predicates_wait(*args, &block); end

  def predicates_wait=(*args, &block); end

  def raise_server_errors(*args, &block); end

  def raise_server_errors=(*args, &block); end

  def reuse_server(); end

  def reuse_server=(reuse_server); end

  def run_server(*args, &block); end

  def run_server=(*args, &block); end

  def save_path(*args, &block); end

  def save_path=(*args, &block); end

  def server(); end

  def server=(name); end

  def server_errors(*args, &block); end

  def server_errors=(*args, &block); end

  def server_host(*args, &block); end

  def server_host=(*args, &block); end

  def server_port(*args, &block); end

  def server_port=(*args, &block); end

  def session_options(); end

  def test_id(*args, &block); end

  def test_id=(*args, &block); end

  def threadsafe(); end

  def threadsafe=(bool); end

  def visible_text_only(*args, &block); end

  def visible_text_only=(*args, &block); end

  def w3c_click_offset(*args, &block); end

  def w3c_click_offset=(*args, &block); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::Config
  extend ::Forwardable
end

module Capybara::DSL
  def accept_alert(*_, &_1); end

  def accept_confirm(*_, &_1); end

  def accept_prompt(*_, &_1); end

  def all(*_, &_1); end

  def assert_all_of_selectors(*_, &_1); end

  def assert_any_of_selectors(*_, &_1); end

  def assert_current_path(*_, &_1); end

  def assert_no_current_path(*_, &_1); end

  def assert_no_selector(*_, &_1); end

  def assert_no_text(*_, &_1); end

  def assert_no_title(*_, &_1); end

  def assert_none_of_selectors(*_, &_1); end

  def assert_selector(*_, &_1); end

  def assert_text(*_, &_1); end

  def assert_title(*_, &_1); end

  def attach_file(*_, &_1); end

  def body(*_, &_1); end

  def check(*_, &_1); end

  def choose(*_, &_1); end

  def click_button(*_, &_1); end

  def click_link(*_, &_1); end

  def click_link_or_button(*_, &_1); end

  def click_on(*_, &_1); end

  def current_host(*_, &_1); end

  def current_path(*_, &_1); end

  def current_scope(*_, &_1); end

  def current_url(*_, &_1); end

  def current_window(*_, &_1); end

  def dismiss_confirm(*_, &_1); end

  def dismiss_prompt(*_, &_1); end

  def evaluate_script(*_, &_1); end

  def execute_script(*_, &_1); end

  def fill_in(*_, &_1); end

  def find(*_, &_1); end

  def find_all(*_, &_1); end

  def find_button(*_, &_1); end

  def find_by_id(*_, &_1); end

  def find_field(*_, &_1); end

  def find_link(*_, &_1); end

  def first(*_, &_1); end

  def go_back(*_, &_1); end

  def go_forward(*_, &_1); end

  def has_button?(*_, &_1); end

  def has_checked_field?(*_, &_1); end

  def has_content?(*_, &_1); end

  def has_css?(*_, &_1); end

  def has_current_path?(*_, &_1); end

  def has_field?(*_, &_1); end

  def has_link?(*_, &_1); end

  def has_no_button?(*_, &_1); end

  def has_no_checked_field?(*_, &_1); end

  def has_no_content?(*_, &_1); end

  def has_no_css?(*_, &_1); end

  def has_no_current_path?(*_, &_1); end

  def has_no_field?(*_, &_1); end

  def has_no_link?(*_, &_1); end

  def has_no_select?(*_, &_1); end

  def has_no_selector?(*_, &_1); end

  def has_no_table?(*_, &_1); end

  def has_no_text?(*_, &_1); end

  def has_no_title?(*_, &_1); end

  def has_no_unchecked_field?(*_, &_1); end

  def has_no_xpath?(*_, &_1); end

  def has_select?(*_, &_1); end

  def has_selector?(*_, &_1); end

  def has_table?(*_, &_1); end

  def has_text?(*_, &_1); end

  def has_title?(*_, &_1); end

  def has_unchecked_field?(*_, &_1); end

  def has_xpath?(*_, &_1); end

  def html(*_, &_1); end

  def open_new_window(*_, &_1); end

  def page(); end

  def query(*_, &_1); end

  def refresh(*_, &_1); end

  def refute_selector(*_, &_1); end

  def reset_session!(*_, &_1); end

  def response_headers(*_, &_1); end

  def save_and_open_page(*_, &_1); end

  def save_and_open_screenshot(*_, &_1); end

  def save_page(*_, &_1); end

  def save_screenshot(*_, &_1); end

  def scroll_by(*_, &_1); end

  def scroll_to(*_, &_1); end

  def select(*_, &_1); end

  def send_keys(*_, &_1); end

  def source(*_, &_1); end

  def status_code(*_, &_1); end

  def switch_to_frame(*_, &_1); end

  def switch_to_window(*_, &_1); end

  def text(*_, &_1); end

  def title(*_, &_1); end

  def uncheck(*_, &_1); end

  def unselect(*_, &_1); end

  def using_session(name_or_session, &block); end

  def using_wait_time(seconds, &block); end

  def visit(*_, &_1); end

  def window_opened_by(*_, &_1); end

  def windows(*_, &_1); end

  def within(*_, &_1); end

  def within_element(*_, &_1); end

  def within_fieldset(*_, &_1); end

  def within_frame(*_, &_1); end

  def within_table(*_, &_1); end

  def within_window(*_, &_1); end
end

module Capybara::DSL
  def self.extended(base); end

  def self.included(base); end
end

module Capybara::Driver
end

class Capybara::Driver::Base
  def accept_modal(type, **options, &blk); end

  def close_window(handle); end

  def current_url(); end

  def current_window_handle(); end

  def dismiss_modal(type, **options, &blk); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def find_css(query, **options); end

  def find_xpath(query, **options); end

  def frame_title(); end

  def frame_url(); end

  def fullscreen_window(handle); end

  def go_back(); end

  def go_forward(); end

  def html(); end

  def invalid_element_errors(); end

  def maximize_window(handle); end

  def needs_server?(); end

  def no_such_window_error(); end

  def open_new_window(); end

  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def response_headers(); end

  def save_screenshot(path, **options); end

  def send_keys(*_); end

  def session=(session); end

  def session_options(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(handle); end

  def visit(path); end

  def wait?(); end

  def window_handles(); end

  def window_size(handle); end
end

class Capybara::Driver::Base
end

class Capybara::Driver::Node
  def ==(other); end

  def [](name); end

  def all_text(); end

  def checked?(); end

  def click(keys=T.unsafe(nil), **options); end

  def disabled?(); end

  def double_click(keys=T.unsafe(nil), **options); end

  def drag_to(element, **options); end

  def driver(); end

  def drop(*args); end

  def hover(); end

  def initial_cache(); end

  def initialize(driver, native, initial_cache=T.unsafe(nil)); end

  def multiple?(); end

  def native(); end

  def obscured?(); end

  def path(); end

  def readonly?(); end

  def rect(); end

  def right_click(keys=T.unsafe(nil), **options); end

  def scroll_by(x, y); end

  def scroll_to(element, alignment, position=T.unsafe(nil)); end

  def select_option(); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def style(styles); end

  def tag_name(); end

  def trigger(event); end

  def unselect_option(); end

  def value(); end

  def visible?(); end

  def visible_text(); end
end

class Capybara::Driver::Node
end

module Capybara::Driver
end

class Capybara::DriverNotFoundError
end

class Capybara::DriverNotFoundError
end

class Capybara::ElementNotFound
end

class Capybara::ElementNotFound
end

class Capybara::ExpectationNotMet
end

class Capybara::ExpectationNotMet
end

class Capybara::FileNotFound
end

class Capybara::FileNotFound
end

class Capybara::FrozenInTime
end

class Capybara::FrozenInTime
end

module Capybara::Helpers
end

class Capybara::Helpers::Timer
  def expired?(); end

  def initialize(expire_in); end

  def stalled?(); end
end

class Capybara::Helpers::Timer
end

module Capybara::Helpers
  def self.declension(singular, plural, count); end

  def self.filter_backtrace(trace); end

  def self.inject_asset_host(html, host: T.unsafe(nil)); end

  def self.monotonic_time(); end

  def self.normalize_whitespace(text); end

  def self.timer(expire_in:); end

  def self.to_regexp(text, exact: T.unsafe(nil), all_whitespace: T.unsafe(nil), options: T.unsafe(nil)); end

  def self.warn(message, uplevel: T.unsafe(nil)); end
end

class Capybara::InfiniteRedirectError
end

class Capybara::InfiniteRedirectError
end

class Capybara::ModalNotFound
end

class Capybara::ModalNotFound
end

module Capybara::Node
end

module Capybara::Node::Actions
  def attach_file(locator=T.unsafe(nil), paths, make_visible: T.unsafe(nil), **options); end

  def check(locator=T.unsafe(nil), **options); end

  def choose(locator=T.unsafe(nil), **options); end

  def click_button(locator=T.unsafe(nil), **options); end

  def click_link(locator=T.unsafe(nil), **options); end

  def click_link_or_button(locator=T.unsafe(nil), **options); end

  def click_on(locator=T.unsafe(nil), **options); end

  def fill_in(locator=T.unsafe(nil), with:, currently_with: T.unsafe(nil), fill_options: T.unsafe(nil), **find_options); end

  def select(value=T.unsafe(nil), from: T.unsafe(nil), **options); end

  def uncheck(locator=T.unsafe(nil), **options); end

  def unselect(value=T.unsafe(nil), from: T.unsafe(nil), **options); end
  CAPTURE_FILE_ELEMENT_SCRIPT = ::T.let(nil, ::T.untyped)
  DATALIST_OPTIONS_SCRIPT = ::T.let(nil, ::T.untyped)
  RESET_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
  UPDATE_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

module Capybara::Node::Actions
end

class Capybara::Node::Base
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Actions
  include ::Capybara::Node::Matchers
  def base(); end

  def catch_error?(error, errors=T.unsafe(nil)); end

  def driver(); end

  def find_css(css, **options); end

  def find_xpath(xpath, **options); end

  def initialize(session, base); end

  def query_scope(); end

  def reload(); end

  def session(); end

  def session_options(); end

  def synchronize(seconds=T.unsafe(nil), errors: T.unsafe(nil)); end

  def to_capybara_node(); end
end

class Capybara::Node::Base
end

class Capybara::Node::Document
  include ::Capybara::Node::DocumentMatchers
  def evaluate_script(*args); end

  def execute_script(*args); end

  def scroll_to(*args, **options); end

  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end
end

class Capybara::Node::Document
end

module Capybara::Node::DocumentMatchers
  def assert_no_title(title, **options); end

  def assert_title(title, **options); end

  def has_no_title?(title, **options); end

  def has_title?(title, **options); end
end

module Capybara::Node::DocumentMatchers
end

class Capybara::Node::Element
  def [](attribute); end

  def allow_reload!(idx=T.unsafe(nil)); end

  def checked?(); end

  def click(*keys, **options); end

  def disabled?(); end

  def double_click(*keys, **options); end

  def drag_to(node, **options); end

  def drop(*args); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def flash(); end

  def hover(); end

  def initial_cache(); end

  def initialize(session, base, query_scope, query); end

  def multiple?(); end

  def native(); end

  def obscured?(); end

  def path(); end

  def readonly?(); end

  def rect(); end

  def right_click(*keys, **options); end

  def scroll_to(pos_or_el_or_x, y=T.unsafe(nil), align: T.unsafe(nil), offset: T.unsafe(nil)); end

  def select_option(wait: T.unsafe(nil)); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def style(*styles); end

  def tag_name(); end

  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def trigger(event); end

  def unselect_option(wait: T.unsafe(nil)); end

  def value(); end

  def visible?(); end
  STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Element
end

module Capybara::Node::Finders
  def all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  def ancestor(*args, **options, &optional_filter_block); end

  def find(*args, **options, &optional_filter_block); end

  def find_all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  def find_button(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_by_id(id, **options, &optional_filter_block); end

  def find_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_link(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def first(*args, **options, &optional_filter_block); end

  def sibling(*args, **options, &optional_filter_block); end
end

module Capybara::Node::Finders
end

module Capybara::Node::Matchers
  def ==(other); end

  def assert_all_of_selectors(*args, **options, &optional_filter_block); end

  def assert_ancestor(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, wait: T.unsafe(nil), **options, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_style(styles=T.unsafe(nil), **options); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  def assert_no_text(type_or_text, *args, **opts); end

  def assert_none_of_selectors(*args, **options, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_sibling(*args, &optional_filter_block); end

  def assert_style(styles=T.unsafe(nil), **options); end

  def assert_text(type_or_text, *args, **opts); end

  def has_ancestor?(*args, **options, &optional_filter_block); end

  def has_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_content?(*args, **options); end

  def has_css?(path, **options, &optional_filter_block); end

  def has_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_ancestor?(*args, **options, &optional_filter_block); end

  def has_no_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_content?(*args, **options); end

  def has_no_css?(path, **options, &optional_filter_block); end

  def has_no_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_selector?(*args, **options, &optional_filter_block); end

  def has_no_sibling?(*args, **options, &optional_filter_block); end

  def has_no_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_text?(*args, **options); end

  def has_no_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_xpath?(path, **options, &optional_filter_block); end

  def has_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_selector?(*args, **options, &optional_filter_block); end

  def has_sibling?(*args, **options, &optional_filter_block); end

  def has_style?(styles=T.unsafe(nil), **options); end

  def has_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_text?(*args, **options); end

  def has_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_xpath?(path, **options, &optional_filter_block); end

  def matches_css?(css, **options, &optional_filter_block); end

  def matches_selector?(*args, **options, &optional_filter_block); end

  def matches_style?(styles=T.unsafe(nil), **options); end

  def matches_xpath?(xpath, **options, &optional_filter_block); end

  def not_matches_css?(css, **options, &optional_filter_block); end

  def not_matches_selector?(*args, **options, &optional_filter_block); end

  def not_matches_xpath?(xpath, **options, &optional_filter_block); end
end

module Capybara::Node::Matchers
end

class Capybara::Node::Simple
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Matchers
  include ::Capybara::Node::DocumentMatchers
  def [](name); end

  def allow_reload!(*_); end

  def checked?(); end

  def disabled?(); end

  def find_css(css, **_options); end

  def find_xpath(xpath, **_options); end

  def initial_cache(); end

  def initialize(native); end

  def multiple?(); end

  def native(); end

  def path(); end

  def readonly?(); end

  def selected?(); end

  def session_options(); end

  def synchronize(_seconds=T.unsafe(nil)); end

  def tag_name(); end

  def text(_type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end

  def value(); end

  def visible?(check_ancestors=T.unsafe(nil)); end
  VISIBILITY_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Simple
end

module Capybara::Node
end

class Capybara::NotSupportedByDriverError
end

class Capybara::NotSupportedByDriverError
end

module Capybara::Queries
end

class Capybara::Queries::AncestorQuery
  def description(applied=T.unsafe(nil)); end
end

class Capybara::Queries::AncestorQuery
end

class Capybara::Queries::BaseQuery
  def expects_none?(); end

  def failure_message(); end

  def initialize(options); end

  def matches_count?(count); end

  def negative_failure_message(); end

  def options(); end

  def session_options(); end

  def session_options=(session_options); end

  def wait(); end
  COUNT_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::BaseQuery
  def self.wait(options, default=T.unsafe(nil)); end
end

class Capybara::Queries::CurrentPathQuery
  def initialize(expected_path, **options, &optional_filter_block); end

  def resolves_for?(session); end
end

class Capybara::Queries::CurrentPathQuery
end

class Capybara::Queries::MatchQuery
end

class Capybara::Queries::MatchQuery
end

class Capybara::Queries::SelectorQuery
  def applied_description(); end

  def css(); end

  def description(only_applied=T.unsafe(nil)); end

  def exact?(); end

  def expression(); end

  def initialize(*args, session_options:, enable_aria_label: T.unsafe(nil), enable_aria_role: T.unsafe(nil), test_id: T.unsafe(nil), selector_format: T.unsafe(nil), order: T.unsafe(nil), **options, &filter_block); end

  def label(); end

  def locator(); end

  def match(); end

  def matches_filters?(node, node_filter_errors=T.unsafe(nil)); end

  def name(); end

  def resolve_for(node, exact=T.unsafe(nil)); end

  def selector(); end

  def supports_exact?(); end

  def visible(); end

  def xpath(exact=T.unsafe(nil)); end
  SPATIAL_KEYS = ::T.let(nil, ::T.untyped)
  VALID_KEYS = ::T.let(nil, ::T.untyped)
  VALID_MATCH = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::SelectorQuery
end

class Capybara::Queries::SiblingQuery
  def description(applied=T.unsafe(nil)); end
end

class Capybara::Queries::SiblingQuery
end

class Capybara::Queries::StyleQuery
  def initialize(expected_styles, session_options:, **options); end

  def resolves_for?(node); end
end

class Capybara::Queries::StyleQuery
end

class Capybara::Queries::TextQuery
  def description(); end

  def initialize(type=T.unsafe(nil), expected_text, session_options:, **options); end

  def resolve_for(node); end
end

class Capybara::Queries::TextQuery
end

class Capybara::Queries::TitleQuery
  def initialize(expected_title, **options); end

  def resolves_for?(node); end
end

class Capybara::Queries::TitleQuery
end

module Capybara::Queries
end

module Capybara::RackTest
end

class Capybara::RackTest::Browser
  include ::Rack::Test::Methods
  def app(); end

  def build_uri(path); end

  def current_host(); end

  def current_host=(current_host); end

  def current_url(); end

  def dom(); end

  def driver(); end

  def find(format, selector); end

  def follow(method, path, **attributes); end

  def html(); end

  def initialize(driver); end

  def options(); end

  def process(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def process_and_follow_redirects(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def refresh(); end

  def request_path(); end

  def reset_cache!(); end

  def reset_host!(); end

  def submit(method, path, attributes); end

  def title(); end

  def visit(path, **attributes); end
end

class Capybara::RackTest::Browser
end

class Capybara::RackTest::CSSHandlers
  include ::Kernel
  def disabled(list); end

  def enabled(list); end
end

class Capybara::RackTest::CSSHandlers
end

class Capybara::RackTest::Driver
  def app(); end

  def browser(); end

  def delete(*args, &block); end

  def dom(); end

  def find_css(selector); end

  def find_xpath(selector); end

  def follow(method, path, **attributes); end

  def follow_redirects?(); end

  def get(*args, &block); end

  def header(key, value); end

  def initialize(app, **options); end

  def options(); end

  def post(*args, &block); end

  def put(*args, &block); end

  def redirect_limit(); end

  def request(); end

  def response(); end

  def submit(method, path, attributes); end

  def title(); end

  def visit(path, **attributes); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Driver
end

module Capybara::RackTest::Errors
end

class Capybara::RackTest::Errors::StaleElementReferenceError
end

class Capybara::RackTest::Errors::StaleElementReferenceError
end

module Capybara::RackTest::Errors
end

class Capybara::RackTest::Form
  def multipart?(); end

  def params(button); end

  def submit(button); end
end

class Capybara::RackTest::Form::NilUploadedFile
  def initialize(); end

  def read(); end

  def size(); end
end

class Capybara::RackTest::Form::NilUploadedFile
end

class Capybara::RackTest::Form::ParamsHash
  def to_params_hash(); end
end

class Capybara::RackTest::Form::ParamsHash
end

class Capybara::RackTest::Form
end

class Capybara::RackTest::Node
  def [](*_, &_1); end

  def all_text(*_, &_1); end

  def checkbox?(); end

  def checkbox_or_radio?(field=T.unsafe(nil)); end

  def checked?(*_, &_1); end

  def click(*_, &_1); end

  def disabled?(*_, &_1); end

  def displayed_text(check_ancestor: T.unsafe(nil)); end

  def find_css(*_, &_1); end

  def find_xpath(*_, &_1); end

  def input_field?(); end

  def path(*_, &_1); end

  def radio?(); end

  def range?(); end

  def select_option(*_, &_1); end

  def selected?(*_, &_1); end

  def set(*_, &_1); end

  def style(*_, &_1); end

  def tag_name(*_, &_1); end

  def text_or_password?(); end

  def textarea?(); end

  def unselect_option(*_, &_1); end

  def value(*_, &_1); end

  def visible?(*_, &_1); end

  def visible_text(*_, &_1); end
  BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  DISABLED_BY_FIELDSET_XPATH = ::T.let(nil, ::T.untyped)
  OPTION_OWNER_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Node
end

module Capybara::RackTest
end

class Capybara::ReadOnlyElementError
end

class Capybara::ReadOnlyElementError
end

class Capybara::ReadOnlySessionConfig
  def always_include_port=(_); end

  def app_host=(_); end

  def asset_host=(_); end

  def automatic_label_click=(_); end

  def automatic_reload=(_); end

  def default_host=(_); end

  def default_max_wait_time=(_); end

  def default_normalize_ws=(_); end

  def default_selector=(_); end

  def default_set_options=(_); end

  def disable_animation=(_); end

  def enable_aria_label=(_); end

  def enable_aria_role=(_); end

  def exact=(_); end

  def exact_text=(_); end

  def ignore_hidden_elements=(_); end

  def match=(_); end

  def predicates_wait=(_); end

  def raise_server_errors=(_); end

  def run_server=(_); end

  def save_path=(_); end

  def server_errors=(_); end

  def server_host=(_); end

  def server_port=(_); end

  def test_id=(_); end

  def visible_text_only=(_); end

  def w3c_click_offset=(_); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Capybara::ReadOnlySessionConfig
end

class Capybara::RegistrationContainer
  def [](name); end

  def []=(name, value); end

  def method_missing(method_name, *args, **options, &block); end

  def names(); end
end

class Capybara::RegistrationContainer
end

class Capybara::Result
  include ::Enumerable
  def [](*args); end

  def allow_reload!(); end

  def at(*args); end

  def compare_count(); end

  def each(&block); end

  def empty?(); end

  def failure_message(); end

  def index(*_); end

  def initialize(elements, query); end

  def inspect(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def matches_count?(); end

  def negative_failure_message(); end

  def sample(*args, &block); end

  def size(*args, &block); end

  def unfiltered_size(); end

  def values_at(*args, &block); end
end

class Capybara::Result
  extend ::Forwardable
end

class Capybara::ScopeError
end

class Capybara::ScopeError
end

class Capybara::Selector
  def add_error(error_msg); end

  def builder(expr=T.unsafe(nil)); end

  def call(locator, **options); end

  def current_format(); end

  def enable_aria_label(); end

  def enable_aria_role(); end

  def errors(); end

  def expression_for(name, locator, config: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def format(); end

  def initialize(definition, config:, format:); end

  def test_id(); end

  def with_filter_errors(errors); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS
  ESCAPE = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS::Splitter
  def split(css); end
end

class Capybara::Selector::CSS::Splitter
end

class Capybara::Selector::CSS
  def self.escape(str); end

  def self.escape_char(char); end

  def self.split(css); end
end

class Capybara::Selector::CSSBuilder
  def add_attribute_conditions(**attributes); end

  def expression(); end

  def initialize(expression); end
end

class Capybara::Selector::CSSBuilder
end

class Capybara::Selector::Definition
  def css(*allowed_filters, &block); end

  def custom_filters(); end

  def default_format(); end

  def default_visibility(fallback=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe(*args, &block); end

  def describe_all_expression_filters(**opts); end

  def describe_expression_filters(&block); end

  def describe_node_filters(&block); end

  def description(*args, &block); end

  def expression_filter(*args, &block); end

  def expression_filters(); end

  def expressions(); end

  def filter(*args, &block); end

  def filter_set(name, filters_to_use=T.unsafe(nil)); end

  def initialize(name, locator_type: T.unsafe(nil), raw_locator: T.unsafe(nil), supports_exact: T.unsafe(nil), &block); end

  def label(label=T.unsafe(nil)); end

  def locator_filter(*types, **options, &block); end

  def locator_types(); end

  def match(&block); end

  def match?(locator); end

  def name(); end

  def node_filter(*args, &block); end

  def node_filters(); end

  def raw_locator?(); end

  def supports_exact?(); end

  def visible(default_visibility=T.unsafe(nil), &block); end

  def xpath(*allowed_filters, &block); end
end

class Capybara::Selector::Definition
  extend ::Forwardable
end

class Capybara::Selector::FilterSet
  def describe(what=T.unsafe(nil), &block); end

  def description(node_filters: T.unsafe(nil), expression_filters: T.unsafe(nil), **options); end

  def descriptions(); end

  def expression_filter(name, *types, **options, &block); end

  def expression_filter_descriptions(); end

  def expression_filters(); end

  def filter(names, *types, **options, &block); end

  def import(name, filters=T.unsafe(nil)); end

  def initialize(name, &block); end

  def node_filter(names, *types, **options, &block); end

  def node_filter_descriptions(); end

  def node_filters(); end

  def undeclared_descriptions(); end
end

class Capybara::Selector::FilterSet
  def self.[](name); end

  def self.add(name, &block); end

  def self.all(); end

  def self.remove(name); end
end

module Capybara::Selector::Filters
end

class Capybara::Selector::Filters::Base
  def boolean?(); end

  def default(); end

  def default?(); end

  def format(); end

  def handles_option?(option_name); end

  def initialize(name, matcher, block, **options); end

  def matcher?(); end

  def skip?(value); end
end

class Capybara::Selector::Filters::Base
end

class Capybara::Selector::Filters::ExpressionFilter
  def apply_filter(expr, name, value, selector); end
end

class Capybara::Selector::Filters::ExpressionFilter
end

class Capybara::Selector::Filters::IdentityExpressionFilter
  def apply_filter(expr, _name, _value, _ctx); end

  def initialize(name); end
end

class Capybara::Selector::Filters::IdentityExpressionFilter
end

class Capybara::Selector::Filters::LocatorFilter
  def initialize(block, **options); end

  def matches?(node, value, context=T.unsafe(nil), exact:); end
end

class Capybara::Selector::Filters::LocatorFilter
end

class Capybara::Selector::Filters::NodeFilter
  def matches?(node, name, value, context=T.unsafe(nil)); end
end

class Capybara::Selector::Filters::NodeFilter
end

module Capybara::Selector::Filters
end

class Capybara::Selector::RegexpDisassembler
  def alternated_substrings(); end

  def initialize(regexp); end

  def substrings(); end
end

class Capybara::Selector::RegexpDisassembler
end

class Capybara::Selector::XPathBuilder
  def add_attribute_conditions(**conditions); end

  def expression(); end

  def initialize(expression); end
end

class Capybara::Selector::XPathBuilder
end

class Capybara::Selector
  def self.[](name); end

  def self.add(name, **options, &block); end

  def self.all(); end

  def self.for(locator); end

  def self.remove(name); end

  def self.update(name, &block); end
end

module Capybara::Selenium
end

module Capybara::Selenium::ChromeLogs
  def available_log_types(); end

  def commands(command); end

  def log(type); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  LOG_MSG = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::ChromeLogs
end

class Capybara::Selenium::ChromeNode
  include ::Capybara::Selenium::Node::Html5Drag
  include ::Capybara::Selenium::Node::FileInputClickEmulation
  def click(*_, **_1); end

  def drop(*args); end

  def set_text(value, clear: T.unsafe(nil), **_unused); end
end

class Capybara::Selenium::ChromeNode
end

class Capybara::Selenium::Driver
  include ::Capybara::Selenium::Find
  def accept_modal(_type, **options); end

  def app(); end

  def browser(); end

  def dismiss_modal(_type, **options); end

  def frame_obscured_at?(x:, y:); end

  def initialize(app, **options); end

  def open_new_window(kind=T.unsafe(nil)); end

  def options(); end

  def quit(); end

  def save_screenshot(path, **_options); end

  def send_keys(*args); end

  def title(); end
  CAPS_VERSION = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  SPECIAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Driver::ChromeDriver
  def fullscreen_window(handle); end

  def reset!(); end

  def resize_window_to(handle, width, height); end
end

module Capybara::Selenium::Driver::ChromeDriver
  def self.extended(base); end
end

module Capybara::Selenium::Driver::EdgeDriver
  def download_path=(path); end

  def fullscreen_window(handle); end

  def reset!(); end

  def resize_window_to(handle, width, height); end
end

module Capybara::Selenium::Driver::EdgeDriver
  def self.extended(base); end
end

module Capybara::Selenium::Driver::FirefoxDriver
end

module Capybara::Selenium::Driver::FirefoxDriver
  def self.extended(driver); end

  def self.w3c?(driver); end
end

module Capybara::Selenium::Driver::InternetExplorerDriver
  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::InternetExplorerDriver
end

module Capybara::Selenium::Driver::SafariDriver
  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::SafariDriver
end

module Capybara::Selenium::Driver::W3CFirefoxDriver
  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::W3CFirefoxDriver
  def self.extended(driver); end

  def self.pause_broken?(sel_driver); end
end

class Capybara::Selenium::Driver
  def self.load_selenium(); end

  def self.register_specialization(browser_name, specialization); end

  def self.selenium_webdriver_version(); end

  def self.specializations(); end
end

class Capybara::Selenium::EdgeNode
  include ::Capybara::Selenium::Node::Html5Drag
  def click(*_); end

  def drop(*args); end

  def set_text(value, clear: T.unsafe(nil), **_unused); end
end

class Capybara::Selenium::EdgeNode
end

module Capybara::Selenium::Find
  def find_css(selector, uses_visibility: T.unsafe(nil), texts: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end

  def find_xpath(selector, uses_visibility: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end
end

module Capybara::Selenium::Find
end

class Capybara::Selenium::FirefoxNode
  include ::Capybara::Selenium::Node::Html5Drag
  include ::Capybara::Selenium::Node::FileInputClickEmulation
  def drop(*args); end

  def focused?(); end
end

class Capybara::Selenium::FirefoxNode
end

class Capybara::Selenium::IENode
end

class Capybara::Selenium::IENode
end

class Capybara::Selenium::Node
  include ::Capybara::Selenium::Find
  include ::Capybara::Selenium::Scroll
  def content_editable?(); end

  def drag_to(element, drop_modifiers: T.unsafe(nil), **_); end

  def drop(*_); end

  def obscured?(x: T.unsafe(nil), y: T.unsafe(nil)); end

  def scroll_if_needed(); end

  def scroll_to_center(); end
  GET_XPATH_SCRIPT = ::T.let(nil, ::T.untyped)
  OBSCURED_OR_OFFSET_SCRIPT = ::T.let(nil, ::T.untyped)
  RAPID_APPEND_TEXT = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::FileInputClickEmulation
  def click(keys=T.unsafe(nil), **options); end
end

module Capybara::Selenium::Node::FileInputClickEmulation
end

module Capybara::Selenium::Node::Html5Drag
  def drag_to(element, html5: T.unsafe(nil), delay: T.unsafe(nil), drop_modifiers: T.unsafe(nil)); end
  ATTACH_FILE = ::T.let(nil, ::T.untyped)
  DROP_FILE = ::T.let(nil, ::T.untyped)
  DROP_STRING = ::T.let(nil, ::T.untyped)
  HTML5_DRAG_DROP_SCRIPT = ::T.let(nil, ::T.untyped)
  LEGACY_DRAG_CHECK = ::T.let(nil, ::T.untyped)
  MOUSEDOWN_TRACKER = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::Html5Drag
end

class Capybara::Selenium::Node::ModifierKeysStack
  def include?(key); end

  def pop(); end

  def press(key); end

  def push(); end
end

class Capybara::Selenium::Node::ModifierKeysStack
end

class Capybara::Selenium::Node
end

class Capybara::Selenium::SafariNode
  def set_text(value, clear: T.unsafe(nil), **_unused); end
  MODIFIER_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::SafariNode
end

module Capybara::Selenium::Scroll
  def scroll_by(x, y); end

  def scroll_to(element, location, position=T.unsafe(nil)); end
  SCROLL_POSITIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Scroll
end

module Capybara::Selenium
end

class Capybara::Server
  def app(); end

  def base_url(); end

  def boot(); end

  def error(); end

  def host(); end

  def initialize(app, *deprecated_options, port: T.unsafe(nil), host: T.unsafe(nil), reportable_errors: T.unsafe(nil), extra_middleware: T.unsafe(nil)); end

  def port(); end

  def reset_error!(); end

  def responsive?(); end

  def using_ssl?(); end

  def wait_for_pending_requests(); end
end

class Capybara::Server::AnimationDisabler
  def call(env); end

  def initialize(app); end
  DISABLE_MARKUP_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::AnimationDisabler
  def self.selector_for(css_or_bool); end
end

class Capybara::Server::Checker
  def initialize(host, port); end

  def request(&block); end

  def ssl?(); end
  TRY_HTTPS_ERRORS = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::Checker
end

class Capybara::Server::Middleware
  def call(env); end

  def clear_error(); end

  def error(); end

  def initialize(app, server_errors, extra_middleware=T.unsafe(nil)); end

  def pending_requests(); end

  def pending_requests?(); end
end

class Capybara::Server::Middleware::Counter
  def decrement(uri); end

  def increment(uri); end

  def positive?(); end

  def value(); end
end

class Capybara::Server::Middleware::Counter
end

class Capybara::Server::Middleware
end

class Capybara::Server
  def self.ports(); end
end

class Capybara::Session
  include ::Capybara::SessionMatchers
  def accept_alert(text=T.unsafe(nil), **options, &blk); end

  def accept_confirm(text=T.unsafe(nil), **options, &blk); end

  def accept_prompt(text=T.unsafe(nil), **options, &blk); end

  def all(*_, &_1); end

  def app(); end

  def assert_all_of_selectors(*_, &_1); end

  def assert_any_of_selectors(*_, &_1); end

  def assert_no_selector(*_, &_1); end

  def assert_no_text(*_, &_1); end

  def assert_no_title(*_, &_1); end

  def assert_none_of_selectors(*_, &_1); end

  def assert_selector(*_, &_1); end

  def assert_text(*_, &_1); end

  def assert_title(*_, &_1); end

  def attach_file(*_, &_1); end

  def body(); end

  def check(*_, &_1); end

  def choose(*_, &_1); end

  def cleanup!(); end

  def click_button(*_, &_1); end

  def click_link(*_, &_1); end

  def click_link_or_button(*_, &_1); end

  def click_on(*_, &_1); end

  def config(); end

  def configure(); end

  def current_host(); end

  def current_path(); end

  def current_scope(); end

  def current_url(); end

  def current_window(); end

  def dismiss_confirm(text=T.unsafe(nil), **options, &blk); end

  def dismiss_prompt(text=T.unsafe(nil), **options, &blk); end

  def document(); end

  def driver(); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def fill_in(*_, &_1); end

  def find(*_, &_1); end

  def find_all(*_, &_1); end

  def find_button(*_, &_1); end

  def find_by_id(*_, &_1); end

  def find_field(*_, &_1); end

  def find_link(*_, &_1); end

  def first(*_, &_1); end

  def go_back(); end

  def go_forward(); end

  def has_button?(*_, &_1); end

  def has_checked_field?(*_, &_1); end

  def has_content?(*_, &_1); end

  def has_css?(*_, &_1); end

  def has_field?(*_, &_1); end

  def has_link?(*_, &_1); end

  def has_no_button?(*_, &_1); end

  def has_no_checked_field?(*_, &_1); end

  def has_no_content?(*_, &_1); end

  def has_no_css?(*_, &_1); end

  def has_no_field?(*_, &_1); end

  def has_no_link?(*_, &_1); end

  def has_no_select?(*_, &_1); end

  def has_no_selector?(*_, &_1); end

  def has_no_table?(*_, &_1); end

  def has_no_text?(*_, &_1); end

  def has_no_title?(*_, &_1); end

  def has_no_unchecked_field?(*_, &_1); end

  def has_no_xpath?(*_, &_1); end

  def has_select?(*_, &_1); end

  def has_selector?(*_, &_1); end

  def has_table?(*_, &_1); end

  def has_text?(*_, &_1); end

  def has_title?(*_, &_1); end

  def has_unchecked_field?(*_, &_1); end

  def has_xpath?(*_, &_1); end

  def html(); end

  def initialize(mode, app=T.unsafe(nil)); end

  def mode(); end

  def open_new_window(kind=T.unsafe(nil)); end

  def query(*_, &_1); end

  def quit(); end

  def raise_server_error!(); end

  def refresh(); end

  def refute_selector(*_, &_1); end

  def reset!(); end

  def reset_session!(); end

  def response_headers(); end

  def save_and_open_page(path=T.unsafe(nil)); end

  def save_and_open_screenshot(path=T.unsafe(nil), **options); end

  def save_page(path=T.unsafe(nil)); end

  def save_screenshot(path=T.unsafe(nil), **options); end

  def scroll_by(*_, &_1); end

  def scroll_to(*_, &_1); end

  def select(*_, &_1); end

  def send_keys(*args, **kw_args); end

  def server(); end

  def server_url(); end

  def source(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(window=T.unsafe(nil), **options, &window_locator); end

  def synchronized(); end

  def synchronized=(synchronized); end

  def text(*_, &_1); end

  def title(*_, &_1); end

  def uncheck(*_, &_1); end

  def unselect(*_, &_1); end

  def using_wait_time(seconds, &block); end

  def visit(visit_uri); end

  def window_opened_by(**options); end

  def windows(); end

  def within(*args, **kw_args); end

  def within_element(*args, **kw_args); end

  def within_fieldset(locator, &block); end

  def within_frame(*args, **kw_args); end

  def within_table(locator, &block); end

  def within_window(window_or_proc); end
  DOCUMENT_METHODS = ::T.let(nil, ::T.untyped)
  DSL_METHODS = ::T.let(nil, ::T.untyped)
  MODAL_METHODS = ::T.let(nil, ::T.untyped)
  NODE_METHODS = ::T.let(nil, ::T.untyped)
  SESSION_METHODS = ::T.let(nil, ::T.untyped)
end

class Capybara::Session
  def self.instance_created?(); end
end

class Capybara::SessionConfig
  def always_include_port(); end

  def always_include_port=(always_include_port); end

  def app_host(); end

  def app_host=(url); end

  def asset_host(); end

  def asset_host=(asset_host); end

  def automatic_label_click(); end

  def automatic_label_click=(automatic_label_click); end

  def automatic_reload(); end

  def automatic_reload=(automatic_reload); end

  def default_host(); end

  def default_host=(url); end

  def default_max_wait_time(); end

  def default_max_wait_time=(default_max_wait_time); end

  def default_normalize_ws(); end

  def default_normalize_ws=(default_normalize_ws); end

  def default_selector(); end

  def default_selector=(default_selector); end

  def default_set_options(); end

  def default_set_options=(default_set_options); end

  def disable_animation(); end

  def disable_animation=(disable_animation); end

  def enable_aria_label(); end

  def enable_aria_label=(enable_aria_label); end

  def enable_aria_role(); end

  def enable_aria_role=(enable_aria_role); end

  def exact(); end

  def exact=(exact); end

  def exact_text(); end

  def exact_text=(exact_text); end

  def ignore_hidden_elements(); end

  def ignore_hidden_elements=(ignore_hidden_elements); end

  def match(); end

  def match=(match); end

  def predicates_wait(); end

  def predicates_wait=(predicates_wait); end

  def raise_server_errors(); end

  def raise_server_errors=(raise_server_errors); end

  def run_server(); end

  def run_server=(run_server); end

  def save_path(); end

  def save_path=(save_path); end

  def server_errors(); end

  def server_errors=(errors); end

  def server_host(); end

  def server_host=(server_host); end

  def server_port(); end

  def server_port=(server_port); end

  def test_id(); end

  def test_id=(id); end

  def visible_text_only(); end

  def visible_text_only=(visible_text_only); end

  def w3c_click_offset(); end

  def w3c_click_offset=(w3c_click_offset); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::SessionConfig
end

module Capybara::SessionMatchers
  def assert_current_path(path, **options, &optional_filter_block); end

  def assert_no_current_path(path, **options, &optional_filter_block); end

  def has_current_path?(path, **options, &optional_filter_block); end

  def has_no_current_path?(path, **options, &optional_filter_block); end
end

module Capybara::SessionMatchers
end

class Capybara::UnselectNotAllowed
end

class Capybara::UnselectNotAllowed
end

class Capybara::Window
  def ==(other); end

  def close(); end

  def closed?(); end

  def current?(); end

  def eql?(other); end

  def exists?(); end

  def fullscreen(); end

  def handle(); end

  def initialize(session, handle); end

  def maximize(); end

  def resize_to(width, height); end

  def session(); end

  def size(); end
end

class Capybara::Window
end

class Capybara::WindowError
end

class Capybara::WindowError
end

module Capybara
  extend ::Capybara::DSL
  def self.HTML(html); end

  def self.add_selector(name, **options, &block); end

  def self.allow_gumbo(*args, &block); end

  def self.allow_gumbo=(*args, &block); end

  def self.always_include_port(*args, &block); end

  def self.always_include_port=(*args, &block); end

  def self.app(*args, &block); end

  def self.app=(*args, &block); end

  def self.app_host(*args, &block); end

  def self.app_host=(*args, &block); end

  def self.asset_host(*args, &block); end

  def self.asset_host=(*args, &block); end

  def self.automatic_label_click(*args, &block); end

  def self.automatic_label_click=(*args, &block); end

  def self.automatic_reload(*args, &block); end

  def self.automatic_reload=(*args, &block); end

  def self.configure(); end

  def self.current_driver(); end

  def self.current_driver=(name); end

  def self.current_session(); end

  def self.default_driver(*args, &block); end

  def self.default_driver=(*args, &block); end

  def self.default_host(*args, &block); end

  def self.default_host=(*args, &block); end

  def self.default_max_wait_time(*args, &block); end

  def self.default_max_wait_time=(*args, &block); end

  def self.default_normalize_ws(*args, &block); end

  def self.default_normalize_ws=(*args, &block); end

  def self.default_selector(*args, &block); end

  def self.default_selector=(*args, &block); end

  def self.default_set_options(*args, &block); end

  def self.default_set_options=(*args, &block); end

  def self.disable_animation(*args, &block); end

  def self.disable_animation=(*args, &block); end

  def self.drivers(); end

  def self.enable_aria_label(*args, &block); end

  def self.enable_aria_label=(*args, &block); end

  def self.enable_aria_role(*args, &block); end

  def self.enable_aria_role=(*args, &block); end

  def self.exact(*args, &block); end

  def self.exact=(*args, &block); end

  def self.exact_text(*args, &block); end

  def self.exact_text=(*args, &block); end

  def self.ignore_hidden_elements(*args, &block); end

  def self.ignore_hidden_elements=(*args, &block); end

  def self.javascript_driver(*args, &block); end

  def self.javascript_driver=(*args, &block); end

  def self.match(*args, &block); end

  def self.match=(*args, &block); end

  def self.mode(); end

  def self.modify_selector(name, &block); end

  def self.predicates_wait(*args, &block); end

  def self.predicates_wait=(*args, &block); end

  def self.raise_server_errors(*args, &block); end

  def self.raise_server_errors=(*args, &block); end

  def self.register_driver(name, &block); end

  def self.register_server(name, &block); end

  def self.reset!(); end

  def self.reset_sessions!(); end

  def self.reuse_server(*args, &block); end

  def self.reuse_server=(*args, &block); end

  def self.run_default_server(app, port); end

  def self.run_server(*args, &block); end

  def self.run_server=(*args, &block); end

  def self.save_path(*args, &block); end

  def self.save_path=(*args, &block); end

  def self.server(*args, &block); end

  def self.server=(*args, &block); end

  def self.server_errors(*args, &block); end

  def self.server_errors=(*args, &block); end

  def self.server_host(*args, &block); end

  def self.server_host=(*args, &block); end

  def self.server_port(*args, &block); end

  def self.server_port=(*args, &block); end

  def self.servers(); end

  def self.session_name(); end

  def self.session_name=(name); end

  def self.session_options(); end

  def self.string(html); end

  def self.test_id(*args, &block); end

  def self.test_id=(*args, &block); end

  def self.threadsafe(*args, &block); end

  def self.threadsafe=(*args, &block); end

  def self.use_default_driver(); end

  def self.using_driver(driver); end

  def self.using_wait_time(seconds); end

  def self.visible_text_only(*args, &block); end

  def self.visible_text_only=(*args, &block); end

  def self.w3c_click_offset(*args, &block); end

  def self.w3c_click_offset=(*args, &block); end
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*_); end
end

class CodeRay::Encoders::Encoder
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::PluginHost
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*_); end

  def tokens(*_); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

module Commander
  VERSION = ::T.let(nil, ::T.untyped)
end

class Commander::HelpFormatter::Base
  def initialize(runner); end

  def render(); end

  def render_command(command); end
end

class Commander::HelpFormatter::Base
end

class Commander::HelpFormatter::Terminal
  def template(name); end
end

class Commander::HelpFormatter::Terminal
end

class Commander::HelpFormatter::TerminalCompact
end

class Commander::HelpFormatter::TerminalCompact
end

module Commander::UI::AskForClass
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.make_pool(); end

  def self.open(remote_uri); end

  def self.stop_pool(); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

class DRb::ThreadObject
  include ::MonitorMixin
  def _execute(); end

  def alive?(); end

  def initialize(&blk); end

  def kill(); end

  def method_missing(msg, *arg, &blk); end
end

class DRb::ThreadObject
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  include ::DateAndTime::Zones
  def default_inspect(); end

  def infinite?(); end

  def readable_inspect(); end

  def to_default_s(); end
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

module DateAndTime::Zones
  def in_time_zone(zone=T.unsafe(nil)); end
end

module DateAndTime::Zones
end

class DateTime
  def advance(options); end

  def ago(seconds); end

  def at_beginning_of_day(); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_day(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def at_midday(); end

  def at_middle_of_day(); end

  def at_midnight(); end

  def at_noon(); end

  def beginning_of_day(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def change(options); end

  def end_of_day(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmtime(); end

  def in(seconds); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def midday(); end

  def middle_of_day(); end

  def midnight(); end

  def noon(); end

  def nsec(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def since(seconds); end

  def subsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end
end

class DateTime
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end

  def self.current(); end
end

module Declarative::Schema::DSL
  NestedBuilder = ::T.let(nil, ::T.untyped)
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::CorrectElement
  def call(names, element); end
end

class DidYouMean::CorrectElement
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::ParseDimensions
  def call(); end

  def initialize(dictionary, separator); end
end

class DidYouMean::ParseDimensions
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dimensions(); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def separator(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.exists?(_); end
end

module Disposable
  VERSION = ::T.let(nil, ::T.untyped)
end

class Disposable::Twin
  INVALID_PROPERTY_NAMES = ::T.let(nil, ::T.untyped)
end

class Disposable::Twin::Definition
  Filter = ::T.let(nil, ::T.untyped)
end

class Disposable::Twin::Definition::Each
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Disposable::Twin
  extend ::Disposable::Twin::Property::Unnest
  extend ::Uber::Delegates
end

class Dotenv::Parser
  LINE = ::T.let(nil, ::T.untyped)
end

module Dry::AutoInject
  VALID_NAME = ::T.let(nil, ::T.untyped)
end

class Dry::AutoInject::MethodParameters
  EMPTY = ::T.let(nil, ::T.untyped)
  PASS_THROUGH = ::T.let(nil, ::T.untyped)
end

module Dry::Configurable
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::DSL
  VALID_NAME = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::Setting
  CLONEABLE_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  DEFAULT_CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::Setting::Nested
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
end

class Dry::Container
  include ::Dry::Container::Mixin::Initializer
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PREFIX_NAMESPACE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dry::Container::NamespaceDSL
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Dry::Core
  VERSION = ::T.let(nil, ::T.untyped)
end

module Dry::Core::ClassAttributes
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

module Dry::Core::Constants
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

module Dry::Core::Deprecations
  STACK = ::T.let(nil, ::T.untyped)
end

module Dry::Core::Inflector
  BACKENDS = ::T.let(nil, ::T.untyped)
end

class Dry::Inflector
  DEFAULT_SEPARATOR = ::T.let(nil, ::T.untyped)
  ORDINALIZE_TH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Dry::Initializer
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

Dry::Initializer::Mixin = Dry::Initializer

class Dry::Logic::Operations::Abstract
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class Dry::Logic::Result
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class Dry::Logic::Rule
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class Dry::Logic::RuleCompiler
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class Dry::Struct
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Dry::System
  DEFAULT_SEPARATOR = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  PATH_SEPARATOR = ::T.let(nil, ::T.untyped)
  RB_EXT = ::T.let(nil, ::T.untyped)
  RB_GLOB = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
  WORD_REGEX = ::T.let(nil, ::T.untyped)
end

class Dry::System::Components::Bootable
  DEFAULT_FINALIZE = ::T.let(nil, ::T.untyped)
end

class Dry::System::Settings::FileParser
  LINE = ::T.let(nil, ::T.untyped)
end

module Dry::Types
  ALL_PRIMITIVES = ::T.let(nil, ::T.untyped)
  Any = ::T.let(nil, ::T.untyped)
  COERCIBLE = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  NON_COERCIBLE = ::T.let(nil, ::T.untyped)
  NON_NIL = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  TYPE_SPEC_REGEX = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Dry::Types::Builder
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

module Dry::Types::Coercions
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

module Dry::Types::Coercions::Form
  BOOLEAN_MAP = ::T.let(nil, ::T.untyped)
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
end

class Dry::Types::Container
  include ::Dry::Container::Mixin::Initializer
end

module Dry::Validation
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dry::Validation::InputProcessorCompiler
  DEFAULT_TYPE_NODE = ::T.let(nil, ::T.untyped)
end

class Dry::Validation::InputProcessorCompiler::Form
  CONST_MAP = ::T.let(nil, ::T.untyped)
  PREDICATE_MAP = ::T.let(nil, ::T.untyped)
end

class Dry::Validation::InputProcessorCompiler::JSON
  CONST_MAP = ::T.let(nil, ::T.untyped)
  PREDICATE_MAP = ::T.let(nil, ::T.untyped)
end

class Dry::Validation::InputProcessorCompiler::Sanitizer
  CONST_MAP = ::T.let(nil, ::T.untyped)
  PREDICATE_MAP = ::T.let(nil, ::T.untyped)
end

class Dry::Validation::MessageCompiler
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  LIST_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Dry::Validation::MessageSet
  HINT_EXCLUSION = ::T.let(nil, ::T.untyped)
end

class Dry::Validation::Messages::Abstract
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
end

class Dry::Validation::Schema
  NOOP_INPUT_PROCESSOR = ::T.let(nil, ::T.untyped)
end

class Dry::Validation::Schema::Rule
  INVALID_PREDICATES = ::T.let(nil, ::T.untyped)
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
  CESU_8 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def sum(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def eager(); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Yielder
  def to_proc(); end
end

class Enumerator
  def self.produce(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Erubi
  MATCH_METHOD = ::T.let(nil, ::T.untyped)
  RANGE_ALL = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  TEXT_END = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  include ::BetterErrors::ExceptionExtension
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

module ExceptionForMatrix
end

class ExceptionForMatrix::ErrDimensionMismatch
  def initialize(val=T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrDimensionMismatch
end

class ExceptionForMatrix::ErrNotRegular
  def initialize(val=T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrNotRegular
end

class ExceptionForMatrix::ErrOperationNotDefined
  def initialize(vals); end
end

class ExceptionForMatrix::ErrOperationNotDefined
end

class ExceptionForMatrix::ErrOperationNotImplemented
  def initialize(vals); end
end

class ExceptionForMatrix::ErrOperationNotImplemented
end

module ExceptionForMatrix
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def initialize(*_); end
end

class File
  RELATIVE_PARENTDIR = ::T.let(nil, ::T.untyped)
  RELATIVE_SAMEDIR = ::T.let(nil, ::T.untyped)
end

class File
  def self.absolute_path?(_); end

  def self.exists?(_); end

  def self.read_binary(file); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
  def receiver(); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

Gem::Cache = Gem::SourceIndex

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

Gem::Installer::ExtensionBuildError = Gem::Ext::BuildError

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Package
  def gem(); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::RemoteFetcher::FetchError
  include ::Gem::UriParsing
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Requirement
  include ::Gem::Requirement::OrderIndependentComparison
  include ::Gem::Requirement::CorrectHashForLambdaOperator
end

module Gem::Requirement::CorrectHashForLambdaOperator
  def hash(); end
end

module Gem::Requirement::CorrectHashForLambdaOperator
end

module Gem::Requirement::OrderIndependentComparison
  def ==(other); end

  def _requirements_sorted?(); end

  def _with_sorted_requirements(); end
end

module Gem::Requirement::OrderIndependentComparison
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def removed_method_calls(); end

  def to_ruby(); end
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.activated_gem_paths(); end
end

module Hanami
  DEFAULT_PUBLIC_DIRECTORY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hanami::Action::BaseParams
  DEFAULT_REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  ROUTER_PARAMS = ::T.let(nil, ::T.untyped)
end

module Hanami::Action::CSRFProtection
  CSRF_TOKEN = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_HTTP_METHODS = ::T.let(nil, ::T.untyped)
end

class Hanami::Action::Flash
  KEPT_KEY = ::T.let(nil, ::T.untyped)
  SESSION_KEY = ::T.let(nil, ::T.untyped)
end

module Hanami::Action::Glue
  ADDITIONAL_HTTP_STATUSES_WITHOUT_BODY = ::T.let(nil, ::T.untyped)
  ENV_KEY = ::T.let(nil, ::T.untyped)
end

module Hanami::Action::Head
  ENTITY_HEADERS = ::T.let(nil, ::T.untyped)
  HTTP_STATUSES_WITHOUT_BODY = ::T.let(nil, ::T.untyped)
end

module Hanami::Action::Mime
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_ACCEPT = ::T.let(nil, ::T.untyped)
  DEFAULT_CHARSET = ::T.let(nil, ::T.untyped)
  DEFAULT_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  HTTP_ACCEPT = ::T.let(nil, ::T.untyped)
  HTTP_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Hanami::Action::Params::Errors
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Hanami::Action::Rack
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  DEFAULT_REQUEST_ID_LENGTH = ::T.let(nil, ::T.untyped)
  DEFAULT_RESPONSE_BODY = ::T.let(nil, ::T.untyped)
  DEFAULT_RESPONSE_CODE = ::T.let(nil, ::T.untyped)
  FILE_SYSTEM_ROOT = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  NOT_FOUND = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  RESPONSE_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_CODE = ::T.let(nil, ::T.untyped)
  RESPONSE_HEADERS = ::T.let(nil, ::T.untyped)
  ROUTER_PARSED_BODY = ::T.let(nil, ::T.untyped)
  X_CASCADE = ::T.let(nil, ::T.untyped)
end

module Hanami::Action::Rack::Errors
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_EXCEPTION = ::T.let(nil, ::T.untyped)
end

class Hanami::Action::Rack::File
  PATH_INFO = ::T.let(nil, ::T.untyped)
end

module Hanami::Action::Redirect
  LOCATION = ::T.let(nil, ::T.untyped)
end

module Hanami::Action::Session
  ERRORS_KEY = ::T.let(nil, ::T.untyped)
  SESSION_KEY = ::T.let(nil, ::T.untyped)
end

module Hanami::Action::Validatable
  PARAMS_CLASS_NAME = ::T.let(nil, ::T.untyped)
end

class Hanami::ApplicationConfiguration
  DEFAULT_SSL_PORT = ::T.let(nil, ::T.untyped)
  SSL_SCHEME = ::T.let(nil, ::T.untyped)
end

class Hanami::ApplicationName
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Hanami::Assets
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hanami::Assets::Asset
  PUBLIC_DIRECTORY = ::T.let(nil, ::T.untyped)
  URL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Assets::Compiler
  COMPILE_PATTERN = ::T.let(nil, ::T.untyped)
  DEFAULT_PERMISSIONS = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Hanami::Assets::Config::Manifest
  SUBRESOURCE_INTEGRITY = ::T.let(nil, ::T.untyped)
  TARGET = ::T.let(nil, ::T.untyped)
end

class Hanami::Assets::Config::Sources
  SKIPPED_FILE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Hanami::Assets::Configuration
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  DEFAULT_MANIFEST = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_PREFIX = ::T.let(nil, ::T.untyped)
  DEFAULT_PUBLIC_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEME = ::T.let(nil, ::T.untyped)
  DEFAULT_SUBRESOURCE_INTEGRITY_ALGORITHM = ::T.let(nil, ::T.untyped)
  HTTPS_PORT = ::T.let(nil, ::T.untyped)
  HTTPS_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_SCHEME = ::T.let(nil, ::T.untyped)
  SUBRESOURCE_INTEGRITY_SEPARATOR = ::T.let(nil, ::T.untyped)
  URL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Hanami::Assets::Helpers
  ABSOLUTE_URL_MATCHER = ::T.let(nil, ::T.untyped)
  CROSSORIGIN_ANONYMOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_FAVICON = ::T.let(nil, ::T.untyped)
  FAVICON_MIME_TYPE = ::T.let(nil, ::T.untyped)
  FAVICON_REL = ::T.let(nil, ::T.untyped)
  JAVASCRIPT_EXT = ::T.let(nil, ::T.untyped)
  JAVASCRIPT_MIME_TYPE = ::T.let(nil, ::T.untyped)
  NEW_LINE_SEPARATOR = ::T.let(nil, ::T.untyped)
  QUERY_STRING_MATCHER = ::T.let(nil, ::T.untyped)
  STYLESHEET_EXT = ::T.let(nil, ::T.untyped)
  STYLESHEET_MIME_TYPE = ::T.let(nil, ::T.untyped)
  STYLESHEET_REL = ::T.let(nil, ::T.untyped)
  WILDCARD_EXT = ::T.let(nil, ::T.untyped)
end

class Hanami::Assets::Static
  PATH_INFO = ::T.let(nil, ::T.untyped)
end

class Hanami::CommonLogger
  FORM_HASH = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  ROUTER_PARAMS = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
end

class Hanami::Components::App::Controller
  STRICT_TRANSPORT_SECURITY_DEFAULT_VALUE = ::T.let(nil, ::T.untyped)
  STRICT_TRANSPORT_SECURITY_HEADER = ::T.let(nil, ::T.untyped)
end

class Hanami::Components::Component
  LOGGER_METHODS = ::T.let(nil, ::T.untyped)
end

class Hanami::Config::Mapper
  EXTNAME = ::T.let(nil, ::T.untyped)
end

class Hanami::Config::Security
  CONTENT_SECURITY_POLICY_HEADER = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
  SPACED_SEPARATOR = ::T.let(nil, ::T.untyped)
  X_CONTENT_TYPE_OPTIONS_HEADER = ::T.let(nil, ::T.untyped)
  X_FRAME_OPTIONS_HEADER = ::T.let(nil, ::T.untyped)
  X_XSS_PROTECTION_HEADER = ::T.let(nil, ::T.untyped)
end

class Hanami::Config::Sessions
  BLACKLISTED_DOMAINS = ::T.let(nil, ::T.untyped)
  RACK_NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Hanami::Configuration::App
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Hanami::Controller
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hanami::Controller::Configuration
  DEFAULT_ERROR_CODE = ::T.let(nil, ::T.untyped)
  DEFAULT_FORMATS = ::T.let(nil, ::T.untyped)
  DEFAULT_PUBLIC_DIRECTORY = ::T.let(nil, ::T.untyped)
end

class Hanami::Entity::Schema::Definition::Dsl
  DEFAULT_TYPE = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Hanami::Environment
  APPS_PATH = ::T.let(nil, ::T.untyped)
  CODE_RELOADING = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  DEFAULT_ENVIRONMENT_CONFIG = ::T.let(nil, ::T.untyped)
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_RACKUP = ::T.let(nil, ::T.untyped)
  DOTENV_FILES = ::T.let(nil, ::T.untyped)
  DOTENV_LOCAL_FILE = ::T.let(nil, ::T.untyped)
  HANAMI_ENV = ::T.let(nil, ::T.untyped)
  HANAMI_HOST = ::T.let(nil, ::T.untyped)
  HANAMI_PORT = ::T.let(nil, ::T.untyped)
  LISTEN_ALL_HOST = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
  PRODUCTION_ENV = ::T.let(nil, ::T.untyped)
  RACK_ENV = ::T.let(nil, ::T.untyped)
  RACK_ENV_DEPLOYMENT = ::T.let(nil, ::T.untyped)
  SERVE_STATIC_ASSETS = ::T.let(nil, ::T.untyped)
  SERVE_STATIC_ASSETS_ENABLED = ::T.let(nil, ::T.untyped)
  TEST_ENV = ::T.let(nil, ::T.untyped)
end

class Hanami::EnvironmentApplicationConfigurations
  ALL = ::T.let(nil, ::T.untyped)
end

class Hanami::Hanamirc
  DEFAULT_TEMPLATE = ::T.let(nil, ::T.untyped)
  DEFAULT_TEST_SUITE = ::T.let(nil, ::T.untyped)
  FILE_NAME = ::T.let(nil, ::T.untyped)
  PROJECT_NAME = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
  TEMPLATE_KEY = ::T.let(nil, ::T.untyped)
  TEST_KEY = ::T.let(nil, ::T.untyped)
end

module Hanami::Helpers
  VERSION = ::T.let(nil, ::T.untyped)
end

module Hanami::Helpers::FormHelper
  CSRF_TOKEN = ::T.let(nil, ::T.untyped)
  DEFAULT_CHARSET = ::T.let(nil, ::T.untyped)
  DEFAULT_METHOD = ::T.let(nil, ::T.untyped)
end

class Hanami::Helpers::FormHelper::FormBuilder
  ACCEPT_SEPARATOR = ::T.let(nil, ::T.untyped)
  BROWSER_METHODS = ::T.let(nil, ::T.untyped)
  CHECKED = ::T.let(nil, ::T.untyped)
  DEFAULT_CHECKED_VALUE = ::T.let(nil, ::T.untyped)
  DEFAULT_UNCHECKED_VALUE = ::T.let(nil, ::T.untyped)
  EXCLUDED_CSRF_METHODS = ::T.let(nil, ::T.untyped)
  INPUT_ID_REPLACEMENT = ::T.let(nil, ::T.untyped)
  SELECTED = ::T.let(nil, ::T.untyped)
end

class Hanami::Helpers::FormHelper::Values
  GET_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Helpers::HtmlHelper::EmptyHtmlNode
  ATTRIBUTES_SEPARATOR = ::T.let(nil, ::T.untyped)
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Hanami::Helpers::HtmlHelper::HtmlBuilder
  CONTENT_TAGS = ::T.let(nil, ::T.untyped)
  EMPTY_TAGS = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
end

class Hanami::Helpers::NumberFormattingHelper::Formatter
  DEFAULT_DELIMITER = ::T.let(nil, ::T.untyped)
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEPARATOR = ::T.let(nil, ::T.untyped)
  DELIMITATION_REGEX = ::T.let(nil, ::T.untyped)
  INTEGER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Hanami::Http::Status
  ALL = ::T.let(nil, ::T.untyped)
end

module Hanami::Layout::ClassMethods
  SUFFIX = ::T.let(nil, ::T.untyped)
end

class Hanami::Logger
  DEFAULT_APPLICATION_NAME = ::T.let(nil, ::T.untyped)
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Hanami::Logger::Colorizer
  COLORS = ::T.let(nil, ::T.untyped)
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Hanami::Logger::Filter
  FILTERED_VALUE = ::T.let(nil, ::T.untyped)
end

class Hanami::Logger::Formatter
  NEW_LINE = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Hanami::Mailer
  CONTENT_TYPES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hanami::Mailer::Configuration
  DEFAULT_CHARSET = ::T.let(nil, ::T.untyped)
  DEFAULT_DELIVERY_METHOD = ::T.let(nil, ::T.untyped)
  DEFAULT_ROOT = ::T.let(nil, ::T.untyped)
end

class Hanami::Mailer::Rendering::TemplateName
  NAMESPACE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Mailer::Rendering::TemplatesFinder
  ENGINES = ::T.let(nil, ::T.untyped)
  FORMAT = ::T.let(nil, ::T.untyped)
  RECURSIVE = ::T.let(nil, ::T.untyped)
end

module Hanami::Model
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hanami::Model::EntityName
  SUFFIX = ::T.let(nil, ::T.untyped)
end

class Hanami::Model::MappedRelation
  MAPPER_NAME = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Model::Plugins::Timestamps::InputWithTimestamp
  TIMESTAMPS = ::T.let(nil, ::T.untyped)
end

module Hanami::Model::Sql::Types::Schema
  Array = ::T.let(nil, ::T.untyped)
  Bool = ::T.let(nil, ::T.untyped)
  Date = ::T.let(nil, ::T.untyped)
  DateTime = ::T.let(nil, ::T.untyped)
  Decimal = ::T.let(nil, ::T.untyped)
  Float = ::T.let(nil, ::T.untyped)
  Hash = ::T.let(nil, ::T.untyped)
  Int = ::T.let(nil, ::T.untyped)
  MAPPING = ::T.let(nil, ::T.untyped)
  PG_JSON = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Time = ::T.let(nil, ::T.untyped)
end

class Hanami::RenderingPolicy
  BODY = ::T.let(nil, ::T.untyped)
  ERROR_STATUS = ::T.let(nil, ::T.untyped)
  HANAMI_ACTION = ::T.let(nil, ::T.untyped)
  HEADERS = ::T.let(nil, ::T.untyped)
  RACK_EXCEPTION = ::T.let(nil, ::T.untyped)
  RENDERABLE_FORMATS = ::T.let(nil, ::T.untyped)
  STATUS = ::T.let(nil, ::T.untyped)
  SUCCESSFUL_STATUSES = ::T.let(nil, ::T.untyped)
end

class Hanami::Repository
  COMMAND_PLUGINS = ::T.let(nil, ::T.untyped)
end

class Hanami::Router
  ROOT_PATH = ::T.let(nil, ::T.untyped)
end

class Hanami::Router::NotRoutableEndpointError
  PATH_INFO = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::ClassEndpoint
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::Default
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_BODY = ::T.let(nil, ::T.untyped)
  DEFAULT_CODE = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::Default::NullAction
  include ::Hanami::Action::Rack::InstanceMethods
  include ::Hanami::Action::Mime::InstanceMethods
  include ::Hanami::Action::Callbacks::InstanceMethods
  include ::Hanami::Action::Callable
end

class Hanami::Routing::Default::NullAction
  extend ::Hanami::Action::Exposable::Guard::ClassMethods
end

class Hanami::Routing::Endpoint
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::EndpointResolver
  ACTION_SEPARATOR = ::T.let(nil, ::T.untyped)
  DEFAULT_RESPONSE = ::T.let(nil, ::T.untyped)
  NAMING_PATTERN = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::ForceSsl
  DEFAULT_HTTP_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_SSL_PORT = ::T.let(nil, ::T.untyped)
  EMPTY_BODY = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO_SEPARATOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
  LOCATION_HEADER = ::T.let(nil, ::T.untyped)
  MOVED_PERMANENTLY_HTTP_CODE = ::T.let(nil, ::T.untyped)
  ON = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  SSL_SCHEME = ::T.let(nil, ::T.untyped)
  TEMPORARY_REDIRECT_HTTP_CODE = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::HttpRouter
  DEFAULT_PATH_INFO = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  URL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::LazyEndpoint
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::Namespace
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::Parsers
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  FALLBACK_KEY = ::T.let(nil, ::T.untyped)
  MEDIA_TYPE_MATCHER = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  ROUTER_PARAMS = ::T.let(nil, ::T.untyped)
  ROUTER_PARSED_BODY = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::RedirectEndpoint
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::Resource
  NESTED_ROUTES_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::Resource::Action
  NESTED_ROUTES_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::Resource::Nested
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Hanami::Routing::Route
  include ::HttpRouter::RouteHelper
  include ::HttpRouter::GenerationHelper
end

class Hanami::Static
  HEADER_RULES = ::T.let(nil, ::T.untyped)
  MAX_AGE = ::T.let(nil, ::T.untyped)
  URL_PREFIX = ::T.let(nil, ::T.untyped)
end

module Hanami::Utils
  HANAMI_JRUBY = ::T.let(nil, ::T.untyped)
  HANAMI_RUBINIUS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hanami::Utils::Blank
  STRING_MATCHER = ::T.let(nil, ::T.untyped)
end

class Hanami::Utils::Class
  TOKENIZE_REGEXP = ::T.let(nil, ::T.untyped)
  TOKENIZE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Hanami::Utils::Escape
  DEFAULT_URL_SCHEMES = ::T.let(nil, ::T.untyped)
  HEX_BASE = ::T.let(nil, ::T.untyped)
  HEX_CODES = ::T.let(nil, ::T.untyped)
  HTML_ATTRIBUTE_SAFE_CHARS = ::T.let(nil, ::T.untyped)
  HTML_CHARS = ::T.let(nil, ::T.untyped)
  HTML_ENTITIES = ::T.let(nil, ::T.untyped)
  LOW_HEX_CODE_LIMIT = ::T.let(nil, ::T.untyped)
  NON_PRINTABLE_CHARS = ::T.let(nil, ::T.untyped)
  REPLACEMENT_HEX = ::T.let(nil, ::T.untyped)
end

class Hanami::Utils::Hash
  DUPLICATE_LOGIC = ::T.let(nil, ::T.untyped)
end

module Hanami::Utils::Inflector
  A = ::T.let(nil, ::T.untyped)
  CH = ::T.let(nil, ::T.untyped)
  CHES = ::T.let(nil, ::T.untyped)
  EAUX = ::T.let(nil, ::T.untyped)
  ES = ::T.let(nil, ::T.untyped)
  F = ::T.let(nil, ::T.untyped)
  I = ::T.let(nil, ::T.untyped)
  ICE = ::T.let(nil, ::T.untyped)
  ICES = ::T.let(nil, ::T.untyped)
  IDES = ::T.let(nil, ::T.untyped)
  IES = ::T.let(nil, ::T.untyped)
  IFE = ::T.let(nil, ::T.untyped)
  IS = ::T.let(nil, ::T.untyped)
  IVES = ::T.let(nil, ::T.untyped)
  MA = ::T.let(nil, ::T.untyped)
  MATA = ::T.let(nil, ::T.untyped)
  MEN = ::T.let(nil, ::T.untyped)
  MINA = ::T.let(nil, ::T.untyped)
  NA = ::T.let(nil, ::T.untyped)
  NON = ::T.let(nil, ::T.untyped)
  O = ::T.let(nil, ::T.untyped)
  OES = ::T.let(nil, ::T.untyped)
  OUSE = ::T.let(nil, ::T.untyped)
  RSE = ::T.let(nil, ::T.untyped)
  RSES = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  SES = ::T.let(nil, ::T.untyped)
  SSES = ::T.let(nil, ::T.untyped)
  TA = ::T.let(nil, ::T.untyped)
  UM = ::T.let(nil, ::T.untyped)
  US = ::T.let(nil, ::T.untyped)
  USES = ::T.let(nil, ::T.untyped)
  VES = ::T.let(nil, ::T.untyped)
  X = ::T.let(nil, ::T.untyped)
  XES = ::T.let(nil, ::T.untyped)
  Y = ::T.let(nil, ::T.untyped)
end

Hanami::Utils::Json::ParserError = JSON::ParserError

module Hanami::Utils::Kernel
  BOOLEAN_FALSE_STRING = ::T.let(nil, ::T.untyped)
  BOOLEAN_TRUE_INTEGER = ::T.let(nil, ::T.untyped)
  NUMERIC_MATCHER = ::T.let(nil, ::T.untyped)
end

class Hanami::Utils::PathPrefix
  DEFAULT_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Hanami::Utils::QueryString
  HASH_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Hanami::Utils::ShellColor
  COLORS = ::T.let(nil, ::T.untyped)
end

class Hanami::Utils::String
  CAPITALIZE_SEPARATOR = ::T.let(nil, ::T.untyped)
  CLASSIFY_SEPARATOR = ::T.let(nil, ::T.untyped)
  CLASSIFY_WORD_SEPARATOR = ::T.let(nil, ::T.untyped)
  DASHERIZE_SEPARATOR = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  NAMESPACE_SEPARATOR = ::T.let(nil, ::T.untyped)
  TITLEIZE_SEPARATOR = ::T.let(nil, ::T.untyped)
  TOKENIZE_REGEXP = ::T.let(nil, ::T.untyped)
  TOKENIZE_SEPARATOR = ::T.let(nil, ::T.untyped)
  UNDERSCORE_DIVISION_TARGET = ::T.let(nil, ::T.untyped)
  UNDERSCORE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Hanami::Validations
  DEFAULT_MESSAGES_ENGINE = ::T.let(nil, ::T.untyped)
end

class Hanami::Validations::Namespace
  RUBY_NAMESPACE_REPLACEMENT = ::T.let(nil, ::T.untyped)
  RUBY_NAMESPACE_SEPARATOR = ::T.let(nil, ::T.untyped)
  SUFFIX = ::T.let(nil, ::T.untyped)
  SUFFIX_REPLACEMENT = ::T.let(nil, ::T.untyped)
end

module Hanami::Version
  VERSION = ::T.let(nil, ::T.untyped)
end

module Hanami::View
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hanami::View::Configuration
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_ROOT = ::T.let(nil, ::T.untyped)
end

module Hanami::View::Rendering
  KNOWN_RENDER_TYPES = ::T.let(nil, ::T.untyped)
end

class Hanami::View::Rendering::LayoutFinder
  SUFFIX = ::T.let(nil, ::T.untyped)
end

class Hanami::View::Rendering::NullLocal
  TO_STR = ::T.let(nil, ::T.untyped)
end

class Hanami::View::Rendering::PartialFinder
  PREFIX = ::T.let(nil, ::T.untyped)
end

class Hanami::View::Rendering::PartialTemplatesFinder
  PARTIAL_PARTS_SEPARATOR = ::T.let(nil, ::T.untyped)
  PARTIAL_PATTERN = ::T.let(nil, ::T.untyped)
end

class Hanami::View::Rendering::Registry
  DEFAULT_FORMAT = ::T.let(nil, ::T.untyped)
end

class Hanami::View::Rendering::TemplateName
  NAMESPACE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Hanami::View::Rendering::TemplatesFinder
  ENGINES = ::T.let(nil, ::T.untyped)
  FORMAT = ::T.let(nil, ::T.untyped)
  RECURSIVE = ::T.let(nil, ::T.untyped)
end

module Hanami::Webconsole
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def deconstruct_keys(_); end
end

class Hash
  def self.ruby2_keywords_hash(_); end

  def self.ruby2_keywords_hash?(_); end

  def self.try_convert(_); end
end

module Hashie::Extensions::IndifferentAccess
  def convert!(); end

  def convert_key(key); end

  def hash_lacking_indifference?(other); end

  def hash_with_indifference?(other); end

  def indifferent_access?(); end

  def indifferent_default(key=T.unsafe(nil)); end

  def indifferent_delete(key); end

  def indifferent_fetch(key, *args, &block); end

  def indifferent_key?(key); end

  def indifferent_replace(other_hash); end

  def indifferent_update(other_hash); end

  def indifferent_value(value); end

  def indifferent_values_at(*indices); end

  def indifferent_writer(key, value); end

  def merge(*args); end

  def merge!(*_); end
end

module Hashie::Extensions::IndifferentAccess
  def self.included(base); end

  def self.inject(hash); end

  def self.inject!(hash); end
end

class HighLine
  VERSION = ::T.let(nil, ::T.untyped)
end

module HighLine::BuiltinStyles
  BASIC_COLORS = ::T.let(nil, ::T.untyped)
  BLACK = ::T.let(nil, ::T.untyped)
  BLACK_STYLE = ::T.let(nil, ::T.untyped)
  BLINK = ::T.let(nil, ::T.untyped)
  BLINK_STYLE = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BLUE_STYLE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  BOLD_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_BLACK = ::T.let(nil, ::T.untyped)
  BRIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_BLUE = ::T.let(nil, ::T.untyped)
  BRIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_CYAN = ::T.let(nil, ::T.untyped)
  BRIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_GRAY = ::T.let(nil, ::T.untyped)
  BRIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_GREEN = ::T.let(nil, ::T.untyped)
  BRIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_GREY = ::T.let(nil, ::T.untyped)
  BRIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  BRIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_NONE = ::T.let(nil, ::T.untyped)
  BRIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_RED = ::T.let(nil, ::T.untyped)
  BRIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_WHITE = ::T.let(nil, ::T.untyped)
  BRIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  BRIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CLEAR_STYLE = ::T.let(nil, ::T.untyped)
  COLORS = ::T.let(nil, ::T.untyped)
  COLOR_LIST = ::T.let(nil, ::T.untyped)
  CONCEALED = ::T.let(nil, ::T.untyped)
  CONCEALED_STYLE = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  CYAN_STYLE = ::T.let(nil, ::T.untyped)
  DARK = ::T.let(nil, ::T.untyped)
  DARK_STYLE = ::T.let(nil, ::T.untyped)
  ERASE_CHAR = ::T.let(nil, ::T.untyped)
  ERASE_CHAR_STYLE = ::T.let(nil, ::T.untyped)
  ERASE_LINE = ::T.let(nil, ::T.untyped)
  ERASE_LINE_STYLE = ::T.let(nil, ::T.untyped)
  GRAY = ::T.let(nil, ::T.untyped)
  GRAY_STYLE = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  GREEN_STYLE = ::T.let(nil, ::T.untyped)
  GREY = ::T.let(nil, ::T.untyped)
  GREY_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_BLACK = ::T.let(nil, ::T.untyped)
  LIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_BLUE = ::T.let(nil, ::T.untyped)
  LIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_CYAN = ::T.let(nil, ::T.untyped)
  LIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_GRAY = ::T.let(nil, ::T.untyped)
  LIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_GREEN = ::T.let(nil, ::T.untyped)
  LIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_GREY = ::T.let(nil, ::T.untyped)
  LIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  LIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_NONE = ::T.let(nil, ::T.untyped)
  LIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_RED = ::T.let(nil, ::T.untyped)
  LIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_WHITE = ::T.let(nil, ::T.untyped)
  LIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  LIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLACK = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLUE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_CYAN = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GRAY = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREEN = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREY = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_NONE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_RED = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_WHITE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  ON_GRAY = ::T.let(nil, ::T.untyped)
  ON_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  ON_GREY = ::T.let(nil, ::T.untyped)
  ON_GREY_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLACK = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLUE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_CYAN = ::T.let(nil, ::T.untyped)
  ON_LIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GRAY = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREEN = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREY = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_LIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_NONE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_RED = ::T.let(nil, ::T.untyped)
  ON_LIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_WHITE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  ON_LIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  ON_NONE = ::T.let(nil, ::T.untyped)
  ON_NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_RED_STYLE = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  ON_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  RED_STYLE = ::T.let(nil, ::T.untyped)
  RESET = ::T.let(nil, ::T.untyped)
  RESET_STYLE = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  REVERSE_STYLE = ::T.let(nil, ::T.untyped)
  STYLES = ::T.let(nil, ::T.untyped)
  STYLE_LIST = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  UNDERLINE_STYLE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  UNDERSCORE_STYLE = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  WHITE_STYLE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
  YELLOW_STYLE = ::T.let(nil, ::T.untyped)
end

module HighLine::BuiltinStyles::ClassMethods
  RGB_COLOR_PATTERN = ::T.let(nil, ::T.untyped)
end

class HighLine::SampleColorScheme
  SAMPLE_SCHEME = ::T.let(nil, ::T.untyped)
end

module HighLine::StringExtensions
  STYLE_METHOD_NAME_PATTERN = ::T.let(nil, ::T.untyped)
end

module Hirb
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hirb::Helpers::MarkdownTable
  CHARS = ::T.let(nil, ::T.untyped)
end

class Hirb::Helpers::TabTable
  DELIM = ::T.let(nil, ::T.untyped)
end

class Hirb::Helpers::Table
  BORDER_LENGTH = ::T.let(nil, ::T.untyped)
  CHARS = ::T.let(nil, ::T.untyped)
  MIN_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
end

class Hirb::Helpers::UnicodeTable
  CHARS = ::T.let(nil, ::T.untyped)
end

class Hirb::Menu
  CHOSEN_ARG = ::T.let(nil, ::T.untyped)
  CHOSEN_REGEXP = ::T.let(nil, ::T.untyped)
  DIRECTIONS = ::T.let(nil, ::T.untyped)
end

module Hirb::View
  DEFAULT_HEIGHT = ::T.let(nil, ::T.untyped)
  DEFAULT_WIDTH = ::T.let(nil, ::T.untyped)
end

class HttpRouter::Generator
  SCHEME_PORTS = ::T.let(nil, ::T.untyped)
end

class HttpRouter::Node::AbstractRequestNode
  def initialize(route, parent, tests, request_method); end

  def request_method(); end

  def tests(); end
end

class HttpRouter::Node::AbstractRequestNode
end

class HttpRouter::Node::FreeRegex
  def initialize(router, parent, matcher); end

  def matcher(); end
end

class HttpRouter::Node::FreeRegex
end

class HttpRouter::Node::Glob
end

class HttpRouter::Node::Glob
end

class HttpRouter::Node::GlobRegex
  def initialize(router, parent, matcher); end

  def matcher(); end
end

class HttpRouter::Node::GlobRegex
end

class HttpRouter::Node::Host
  def initialize(router, parent, hosts); end
end

class HttpRouter::Node::Host
end

class HttpRouter::Node::Lookup
  def add(part); end

  def initialize(router, parent); end
end

class HttpRouter::Node::Lookup
end

class HttpRouter::Node::Regex
  def capturing_indicies(); end

  def initialize(router, parent, matcher, capturing_indicies, splitting_indicies=T.unsafe(nil)); end

  def matcher(); end

  def ordered_indicies(); end

  def param_capturing_code(); end

  def splitting_indicies(); end
end

class HttpRouter::Node::Regex
end

class HttpRouter::Node::RequestMethod
  def initialize(router, parent, request_methods); end
end

class HttpRouter::Node::RequestMethod
end

class HttpRouter::Node::Scheme
  def initialize(router, parent, schemes); end
end

class HttpRouter::Node::Scheme
end

class HttpRouter::Node::SpanningRegex
end

class HttpRouter::Node::SpanningRegex
end

class HttpRouter::Node::UserAgent
  def initialize(router, parent, user_agents); end
end

class HttpRouter::Node::UserAgent
end

class HttpRouter::Node::Variable
end

class HttpRouter::Node::Variable
end

class HttpRouter::Route
  VALID_HTTP_VERBS = ::T.let(nil, ::T.untyped)
  VALID_HTTP_VERBS_WITHOUT_GET = ::T.let(nil, ::T.untyped)
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key, options=T.unsafe(nil)); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(_); end

  def cursor_left(_); end

  def cursor_right(_); end

  def cursor_up(_); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(_); end

  def erase_screen(_); end

  def getch(*_); end

  def getpass(*_); end

  def goto(_, _1); end

  def goto_column(_); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def scroll_backward(_); end

  def scroll_forward(_); end

  def set_encoding_by_bom(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*_); end

  def raw!(*_); end
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  def self.clear(); end

  def self.colorable?(); end

  def self.colorize(text, seq); end

  def self.colorize_code(code, complete: T.unsafe(nil)); end

  def self.inspect_colorable?(obj, seen: T.unsafe(nil)); end
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def echo_on_assignment(); end

  def echo_on_assignment=(echo_on_assignment); end

  def echo_on_assignment?(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def inspect_last_value(); end

  def newline_before_multiline_output(); end

  def newline_before_multiline_output=(newline_before_multiline_output); end

  def newline_before_multiline_output?(); end

  def omit_on_assignment(); end

  def omit_on_assignment=(omit_on_assignment); end

  def omit_on_assignment?(); end

  def use_colorize(); end

  def use_colorize?(); end

  def use_multiline(); end

  def use_multiline?(); end

  def use_reidline(); end

  def use_reidline?(); end

  def use_singleline(); end

  def use_singleline?(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_info(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def initialize(file); end
end

module IRB::InputCompletor
  BASIC_WORD_BREAK_CHARACTERS = ::T.let(nil, ::T.untyped)
  CompletionProc = ::T.let(nil, ::T.untyped)
  Operators = ::T.let(nil, ::T.untyped)
  PerfectMatchedProc = ::T.let(nil, ::T.untyped)
  ReservedWords = ::T.let(nil, ::T.untyped)
end

module IRB::InputCompletor
  def self.ignored_modules(); end

  def self.retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end

  def self.select_message(receiver, message, candidates, sep=T.unsafe(nil)); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end

  def winsize(); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def assignment_expression?(line); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def output_value(omit=T.unsafe(nil)); end

  def prompt(prompt, ltype, indent, line_no); end
  ASSIGNMENT_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::OutputMethod::NotImplementedError
  def initialize(val); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def self.initialize_readline(); end
end

class IRB::ReidlineInputMethod
  include ::Reline
  def auto_indent(&block); end

  def check_termination(&block); end

  def dynamic_prompt(&block); end

  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReidlineInputMethod
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end
end

module IceNine
  VERSION = ::T.let(nil, ::T.untyped)
end

IceNine::Freezer::BasicObject = IceNine::Freezer::Object

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JaroWinkler
  VERSION = ::T.let(nil, ::T.untyped)
end

class JaroWinkler::Error
end

class JaroWinkler::Error
end

class JaroWinkler::InvalidWeightError
end

class JaroWinkler::InvalidWeightError
end

module Kernel
  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module Kramdown
  VERSION = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Base
  SMART_QUOTE_INDICES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::HashAST
  def convert(el); end
end

class Kramdown::Converter::HashAST
end

Kramdown::Converter::HashAst = Kramdown::Converter::HashAST

class Kramdown::Converter::Html
  ENTITY_NBSP = ::T.let(nil, ::T.untyped)
  FOOTNOTE_BACKLINK_FMT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Kramdown
  include ::Kramdown::Utils::Html
  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, _opts); end

  def convert_blank(_el, _opts); end

  def convert_blockquote(el, opts); end

  def convert_br(_el, _opts); end

  def convert_codeblock(el, _opts); end

  def convert_codespan(el, _opts); end

  def convert_comment(el, _opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, _opts); end

  def convert_footnote(el, _opts); end

  def convert_header(el, opts); end

  def convert_hr(_el, _opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, _opts); end

  def convert_li(el, opts); end

  def convert_math(el, _opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, _opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, _opts); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, _opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, _opts); end

  def convert_xml_pi(el, _opts); end

  def create_abbrev_defs(); end

  def create_footnote_defs(); end

  def create_link_defs(); end

  def ial_for_element(el); end

  def inner(el, opts=T.unsafe(nil)); end

  def parse_title(attr); end
  ESCAPED_CHAR_RE = ::T.let(nil, ::T.untyped)
  HTML_TAGS_WITH_BODY = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Latex
  def attribute_list(el); end

  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, _opts); end

  def convert_blank(_el, opts); end

  def convert_blockquote(el, opts); end

  def convert_br(_el, opts); end

  def convert_codeblock(el, _opts); end

  def convert_codespan(el, _opts); end

  def convert_comment(el, _opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, _opts); end

  def convert_footnote(el, opts); end

  def convert_header(el, opts); end

  def convert_hr(el, _opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, _opts); end

  def convert_li(el, opts); end

  def convert_math(el, _opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, _opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, opts); end

  def convert_standalone_image(el, _opts, img); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, _opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, _opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, _opts); end

  def convert_xml_pi(_el, _opts); end

  def entity_to_latex(entity); end

  def escape(str); end

  def inner(el, opts); end

  def latex_environment(type, el, text); end

  def latex_link_target(el, add_label=T.unsafe(nil)); end

  def normalize_abbreviation_key(key); end
  ENTITY_CONV_TABLE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
  TABLE_ALIGNMENT_CHAR = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Latex
end

class Kramdown::Converter::Man
  def convert(el, opts=T.unsafe(nil)); end
  TABLE_CELL_ALIGNMENT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_MAP = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Man
end

class Kramdown::Converter::RemoveHtmlTags
  def convert(el); end
end

class Kramdown::Converter::RemoveHtmlTags
end

class Kramdown::Converter::Toc
  def convert(el); end
end

class Kramdown::Converter::Toc
end

module Kramdown::Converter
  extend ::Kramdown::Utils::Configurable
end

class Kramdown::Element
  CATEGORY = ::T.let(nil, ::T.untyped)
end

module Kramdown::Options
  ALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::GFM
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS_GFM = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  LIST_TYPES = ::T.let(nil, ::T.untyped)
  NON_WORD_RE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END_GFM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_DELIM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_MATCH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kramdown::Parser::Html::Constants
  HTML_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_COMMENT_RE = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_BLOCK = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_RAW = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_SPAN = ::T.let(nil, ::T.untyped)
  HTML_DOCTYPE_RE = ::T.let(nil, ::T.untyped)
  HTML_ELEMENT = ::T.let(nil, ::T.untyped)
  HTML_ELEMENTS_WITHOUT_BODY = ::T.let(nil, ::T.untyped)
  HTML_ENTITY_RE = ::T.let(nil, ::T.untyped)
  HTML_INSTRUCTION_RE = ::T.let(nil, ::T.untyped)
  HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_TAG_CLOSE_RE = ::T.let(nil, ::T.untyped)
  HTML_TAG_RE = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Html::ElementConverter
  EMPHASIS_TYPE_MAP = ::T.let(nil, ::T.untyped)
  REMOVE_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
  REMOVE_WHITESPACE_CHILDREN = ::T.let(nil, ::T.untyped)
  SIMPLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  STRIP_WHITESPACE = ::T.let(nil, ::T.untyped)
  WRAP_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
end

module Kramdown::Parser::Html::Parser
  HTML_RAW_START = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Kramdown
  ABBREV_DEFINITION_START = ::T.let(nil, ::T.untyped)
  ACHARS = ::T.let(nil, ::T.untyped)
  ALD_ANY_CHARS = ::T.let(nil, ::T.untyped)
  ALD_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_ID_CHARS = ::T.let(nil, ::T.untyped)
  ALD_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_START = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ANY = ::T.let(nil, ::T.untyped)
  ALD_TYPE_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS_MULTI = ::T.let(nil, ::T.untyped)
  ALD_TYPE_KEY_VALUE_PAIR = ::T.let(nil, ::T.untyped)
  ALD_TYPE_REF = ::T.let(nil, ::T.untyped)
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START_STR = ::T.let(nil, ::T.untyped)
  BLANK_LINE = ::T.let(nil, ::T.untyped)
  BLOCKQUOTE_START = ::T.let(nil, ::T.untyped)
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  BLOCK_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  BLOCK_MATH_START = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  CODESPAN_DELIMITER = ::T.let(nil, ::T.untyped)
  DEFINITION_LIST_START = ::T.let(nil, ::T.untyped)
  EMPHASIS_START = ::T.let(nil, ::T.untyped)
  EOB_MARKER = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_START = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_STOP_STR = ::T.let(nil, ::T.untyped)
  EXT_SPAN_START = ::T.let(nil, ::T.untyped)
  EXT_START_STR = ::T.let(nil, ::T.untyped)
  EXT_STOP_STR = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_DEFINITION_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_MARKER_START = ::T.let(nil, ::T.untyped)
  HEADER_ID = ::T.let(nil, ::T.untyped)
  HR_START = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_START = ::T.let(nil, ::T.untyped)
  HTML_MARKDOWN_ATTR_MAP = ::T.let(nil, ::T.untyped)
  HTML_SPAN_START = ::T.let(nil, ::T.untyped)
  IAL_BLOCK = ::T.let(nil, ::T.untyped)
  IAL_BLOCK_START = ::T.let(nil, ::T.untyped)
  IAL_CLASS_ATTR = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  INDENT = ::T.let(nil, ::T.untyped)
  INLINE_MATH_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_START = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_STOP = ::T.let(nil, ::T.untyped)
  LINE_BREAK = ::T.let(nil, ::T.untyped)
  LINK_BRACKET_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_DEFINITION_START = ::T.let(nil, ::T.untyped)
  LINK_INLINE_ID_RE = ::T.let(nil, ::T.untyped)
  LINK_INLINE_TITLE_RE = ::T.let(nil, ::T.untyped)
  LINK_PAREN_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_START = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL_CHECK = ::T.let(nil, ::T.untyped)
  LIST_START = ::T.let(nil, ::T.untyped)
  LIST_START_OL = ::T.let(nil, ::T.untyped)
  LIST_START_UL = ::T.let(nil, ::T.untyped)
  OPT_SPACE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
  PARAGRAPH_MATCH = ::T.let(nil, ::T.untyped)
  PARAGRAPH_START = ::T.let(nil, ::T.untyped)
  PARSE_FIRST_LIST_LINE_REGEXP_CACHE = ::T.let(nil, ::T.untyped)
  PATTERN_TAIL = ::T.let(nil, ::T.untyped)
  SETEXT_HEADER_START = ::T.let(nil, ::T.untyped)
  SMART_QUOTES_RE = ::T.let(nil, ::T.untyped)
  SPAN_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  SQ_CLOSE = ::T.let(nil, ::T.untyped)
  SQ_PUNCT = ::T.let(nil, ::T.untyped)
  SQ_RULES = ::T.let(nil, ::T.untyped)
  SQ_SUBSTS = ::T.let(nil, ::T.untyped)
  TABLE_FSEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_HSEP_ALIGN = ::T.let(nil, ::T.untyped)
  TABLE_LINE = ::T.let(nil, ::T.untyped)
  TABLE_PIPE_CHECK = ::T.let(nil, ::T.untyped)
  TABLE_ROW_LINE = ::T.let(nil, ::T.untyped)
  TABLE_SEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_START = ::T.let(nil, ::T.untyped)
  TRAILING_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_RE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_SUBST = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Markdown
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  EXTENDED = ::T.let(nil, ::T.untyped)
  IAL_RAND_CHARS = ::T.let(nil, ::T.untyped)
  IAL_RAND_STRING = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Markdown
end

module Kramdown::Utils::Entities
  ENTITY_MAP = ::T.let(nil, ::T.untyped)
  ENTITY_TABLE = ::T.let(nil, ::T.untyped)
end

module Kramdown::Utils::Html
  ESCAPE_ALL_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE_FROM_TYPE = ::T.let(nil, ::T.untyped)
  ESCAPE_TEXT_RE = ::T.let(nil, ::T.untyped)
  REDUNDANT_LINE_BREAK_REGEX = ::T.let(nil, ::T.untyped)
end

class Kramdown::Utils::LRUCache
  def [](key); end

  def []=(key, value); end

  def initialize(size); end
end

class Kramdown::Utils::LRUCache
end

class Kramdown::Utils::StringScanner
  def current_line_number(); end

  def initialize(string, start_line_number=T.unsafe(nil)); end

  def pos=(pos); end

  def revert_pos(data); end

  def save_pos(); end

  def start_line_number(); end
end

class Kramdown::Utils::StringScanner
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::BccField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

module Mail::CommonField
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Field
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::FromField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Header
  LIMITED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::InReplyToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Message
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MimeVersionField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte::Unicode
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::PartsList
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mail::ReceivedField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SenderField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

class Matrix
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def *(m); end

  def **(other); end

  def +(m); end

  def +@(); end

  def -(m); end

  def -@(); end

  def /(other); end

  def ==(other); end

  def [](i, j); end

  def []=(i, j, v); end

  def abs(); end

  def adjugate(); end

  def antisymmetric?(); end

  def coerce(other); end

  def cofactor(row, column); end

  def cofactor_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def collect(which=T.unsafe(nil), &block); end

  def collect!(which=T.unsafe(nil)); end

  def column(j); end

  def column_count(); end

  def column_size(); end

  def column_vectors(); end

  def combine(*matrices, &block); end

  def component(i, j); end

  def conj(); end

  def conjugate(); end

  def det(); end

  def det_e(); end

  def determinant(); end

  def determinant_e(); end

  def diagonal?(); end

  def each_with_index(which=T.unsafe(nil)); end

  def eigen(); end

  def eigensystem(); end

  def element(i, j); end

  def elements_to_f(); end

  def elements_to_i(); end

  def elements_to_r(); end

  def empty?(); end

  def entrywise_product(m); end

  def eql?(other); end

  def find_index(*args); end

  def first_minor(row, column); end

  def hadamard_product(m); end

  def hermitian?(); end

  def hstack(*matrices); end

  def imag(); end

  def imaginary(); end

  def index(*args); end

  def initialize(rows, column_count=T.unsafe(nil)); end

  def inv(); end

  def inverse(); end

  def laplace_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def lower_triangular?(); end

  def lup(); end

  def lup_decomposition(); end

  def map(which=T.unsafe(nil), &block); end

  def map!(which=T.unsafe(nil)); end

  def minor(*param); end

  def normal?(); end

  def orthogonal?(); end

  def permutation?(); end

  def rank(); end

  def rank_e(); end

  def real(); end

  def real?(); end

  def rect(); end

  def rectangular(); end

  def regular?(); end

  def round(ndigits=T.unsafe(nil)); end

  def row(i, &block); end

  def row_count(); end

  def row_size(); end

  def row_vectors(); end

  def rows(); end

  def singular?(); end

  def skew_symmetric?(); end

  def square?(); end

  def symmetric?(); end

  def t(); end

  def to_a(); end

  def to_matrix(); end

  def tr(); end

  def trace(); end

  def transpose(); end

  def unitary?(); end

  def upper_triangular?(); end

  def vstack(*matrices); end

  def zero?(); end
  SELECTORS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Matrix::CoercionHelper
end

module Matrix::CoercionHelper
  def self.check_int(val, count, kind); end

  def self.check_range(val, count, kind); end

  def self.coerce_to(obj, cls, meth); end

  def self.coerce_to_int(obj); end

  def self.coerce_to_matrix(obj); end
end

module Matrix::ConversionHelper
end

module Matrix::ConversionHelper
end

class Matrix::EigenvalueDecomposition
  def initialize(a); end
end

class Matrix::LUPDecomposition
  include ::Matrix::ConversionHelper
  def det(); end

  def determinant(); end

  def initialize(a); end

  def l(); end

  def p(); end

  def pivots(); end

  def singular?(); end

  def solve(b); end

  def to_a(); end

  def to_ary(); end

  def u(); end
end

class Matrix::LUPDecomposition
end

class Matrix::Scalar
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def *(other); end

  def **(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def initialize(value); end
end

class Matrix::Scalar
end

class Matrix
  extend ::Matrix::ConversionHelper
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Spec
  include ::Capybara::DSL
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL
  TYPES = ::T.let(nil, ::T.untyped)
end

class Minitest::Test
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Module
  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def method_visibility(method); end

  def redefine_method(method, &block); end

  def redefine_singleton_method(method, &block); end

  def silence_redefinition_of_method(method); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(_, _1); end
end

module MonitorMixin
  def initialize(*args); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::DidYouMean::Correctable
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def ipaddr(); end

  def ipaddr=(addr); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

class Net::HTTPSuccess
end

Net::HTTPSuccessCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
end

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def open_timeout(); end
  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

Net::SMTPSession = Net::SMTP

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class NoMatchingPatternError
end

class NoMatchingPatternError
end

module Nokogiri
  LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  LIBXML_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_MEMORY_MANAGEMENT = ::T.let(nil, ::T.untyped)
  LIBXSLT_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  OTHER_LIBRARY_VERSIONS = ::T.let(nil, ::T.untyped)
  PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  PRECOMPILED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  CACHE_SWITCH_NAME = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::ElementDescription
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEMA = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  SEQUEL_POSTGRES_USES_PG = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::InternalObjectWrapper
  def internal_object_id(); end

  def type(); end
end

class ObjectSpace::InternalObjectWrapper
end

module ObjectSpace
  def self.allocation_class_path(_); end

  def self.allocation_generation(_); end

  def self.allocation_method_id(_); end

  def self.allocation_sourcefile(_); end

  def self.allocation_sourceline(_); end

  def self.count_imemo_objects(*_); end

  def self.count_nodes(*_); end

  def self.count_objects_size(*_); end

  def self.count_symbols(*_); end

  def self.count_tdata_objects(*_); end

  def self.dump(*_); end

  def self.dump_all(*_); end

  def self.internal_class_of(_); end

  def self.internal_super_of(_); end

  def self.memsize_of(_); end

  def self.memsize_of_all(*_); end

  def self.reachable_objects_from(_); end

  def self.reachable_objects_from_root(); end

  def self.trace_object_allocations(); end

  def self.trace_object_allocations_debug_start(); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

module PG
  include ::PG::Constants
  ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PG::ActiveSqlTransaction
end

class PG::ActiveSqlTransaction
end

class PG::AdminShutdown
end

class PG::AdminShutdown
end

class PG::AmbiguousAlias
end

class PG::AmbiguousAlias
end

class PG::AmbiguousColumn
end

class PG::AmbiguousColumn
end

class PG::AmbiguousFunction
end

class PG::AmbiguousFunction
end

class PG::AmbiguousParameter
end

class PG::AmbiguousParameter
end

class PG::ArraySubscriptError
end

class PG::ArraySubscriptError
end

class PG::AssertFailure
end

class PG::AssertFailure
end

class PG::BadCopyFileFormat
end

class PG::BadCopyFileFormat
end

class PG::BasicTypeMapForQueries
  DEFAULT_ARRAY_TYPE_MAP = ::T.let(nil, ::T.untyped)
  DEFAULT_TYPE_MAP = ::T.let(nil, ::T.untyped)
end

module PG::BasicTypeRegistry
  CODERS_BY_NAME = ::T.let(nil, ::T.untyped)
  ValidDirections = ::T.let(nil, ::T.untyped)
  ValidFormats = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeRegistry::CoderMap
  DONT_QUOTE_TYPES = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Float
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Integer
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::ToBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::FromBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int2
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int4
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int8
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BranchTransactionAlreadyActive
end

class PG::BranchTransactionAlreadyActive
end

class PG::CannotCoerce
end

class PG::CannotCoerce
end

class PG::CannotConnectNow
end

class PG::CannotConnectNow
end

class PG::CantChangeRuntimeParam
end

class PG::CantChangeRuntimeParam
end

class PG::CardinalityViolation
end

class PG::CardinalityViolation
end

class PG::CaseNotFound
end

class PG::CaseNotFound
end

class PG::CharacterNotInRepertoire
end

class PG::CharacterNotInRepertoire
end

class PG::CheckViolation
end

class PG::CheckViolation
end

class PG::Coder
  FORMAT_ERROR_MASK = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_PARTIAL = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_RAISE = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_STRING = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_UTC = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_UTC = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
  Params = ::T.let(nil, ::T.untyped)
end

class PG::CollationMismatch
end

class PG::CollationMismatch
end

class PG::CompositeDecoder
end

class PG::CompositeDecoder
end

class PG::CompositeEncoder
end

class PG::CompositeEncoder
end

class PG::ConfigFileError
end

class PG::ConfigFileError
end

class PG::ConfigurationLimitExceeded
end

class PG::ConfigurationLimitExceeded
end

class PG::Connection
  include ::PG::Constants
  CONNECT_ARGUMENT_ORDER = ::T.let(nil, ::T.untyped)
  REDIRECT_METHODS = ::T.let(nil, ::T.untyped)
end

class PG::ConnectionBad
end

class PG::ConnectionBad
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionException
end

class PG::ConnectionException
end

class PG::ConnectionFailure
end

class PG::ConnectionFailure
end

module PG::Constants
  CONNECTION_AUTH_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_AWAITING_RESPONSE = ::T.let(nil, ::T.untyped)
  CONNECTION_BAD = ::T.let(nil, ::T.untyped)
  CONNECTION_MADE = ::T.let(nil, ::T.untyped)
  CONNECTION_NEEDED = ::T.let(nil, ::T.untyped)
  CONNECTION_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_SETENV = ::T.let(nil, ::T.untyped)
  CONNECTION_SSL_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_STARTED = ::T.let(nil, ::T.untyped)
  INVALID_OID = ::T.let(nil, ::T.untyped)
  INV_READ = ::T.let(nil, ::T.untyped)
  INV_WRITE = ::T.let(nil, ::T.untyped)
  InvalidOid = ::T.let(nil, ::T.untyped)
  PGRES_BAD_RESPONSE = ::T.let(nil, ::T.untyped)
  PGRES_COMMAND_OK = ::T.let(nil, ::T.untyped)
  PGRES_COPY_BOTH = ::T.let(nil, ::T.untyped)
  PGRES_COPY_IN = ::T.let(nil, ::T.untyped)
  PGRES_COPY_OUT = ::T.let(nil, ::T.untyped)
  PGRES_EMPTY_QUERY = ::T.let(nil, ::T.untyped)
  PGRES_FATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_NONFATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_FAILED = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_OK = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_READING = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_WRITING = ::T.let(nil, ::T.untyped)
  PGRES_SINGLE_TUPLE = ::T.let(nil, ::T.untyped)
  PGRES_TUPLES_OK = ::T.let(nil, ::T.untyped)
  PG_DIAG_COLUMN_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONSTRAINT_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONTEXT = ::T.let(nil, ::T.untyped)
  PG_DIAG_DATATYPE_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_QUERY = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_DETAIL = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_HINT = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_PRIMARY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SCHEMA_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY_NONLOCALIZED = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FILE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FUNCTION = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_LINE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SQLSTATE = ::T.let(nil, ::T.untyped)
  PG_DIAG_STATEMENT_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_TABLE_NAME = ::T.let(nil, ::T.untyped)
  PQERRORS_DEFAULT = ::T.let(nil, ::T.untyped)
  PQERRORS_SQLSTATE = ::T.let(nil, ::T.untyped)
  PQERRORS_TERSE = ::T.let(nil, ::T.untyped)
  PQERRORS_VERBOSE = ::T.let(nil, ::T.untyped)
  PQPING_NO_ATTEMPT = ::T.let(nil, ::T.untyped)
  PQPING_NO_RESPONSE = ::T.let(nil, ::T.untyped)
  PQPING_OK = ::T.let(nil, ::T.untyped)
  PQPING_REJECT = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ALWAYS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ERRORS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_NEVER = ::T.let(nil, ::T.untyped)
  PQTRANS_ACTIVE = ::T.let(nil, ::T.untyped)
  PQTRANS_IDLE = ::T.let(nil, ::T.untyped)
  PQTRANS_INERROR = ::T.let(nil, ::T.untyped)
  PQTRANS_INTRANS = ::T.let(nil, ::T.untyped)
  PQTRANS_UNKNOWN = ::T.let(nil, ::T.untyped)
  SEEK_CUR = ::T.let(nil, ::T.untyped)
  SEEK_END = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
end

class PG::CopyDecoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyDecoder
end

class PG::CopyEncoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyEncoder
end

class PG::CrashShutdown
end

class PG::CrashShutdown
end

class PG::DataCorrupted
end

class PG::DataCorrupted
end

class PG::DataException
end

class PG::DataException
end

class PG::DatabaseDropped
end

class PG::DatabaseDropped
end

class PG::DatatypeMismatch
end

class PG::DatatypeMismatch
end

class PG::DatetimeFieldOverflow
end

class PG::DatetimeFieldOverflow
end

class PG::DependentObjectsStillExist
end

class PG::DependentObjectsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DiagnosticsException
end

class PG::DiagnosticsException
end

class PG::DiskFull
end

class PG::DiskFull
end

class PG::DivisionByZero
end

class PG::DivisionByZero
end

class PG::DuplicateAlias
end

class PG::DuplicateAlias
end

class PG::DuplicateColumn
end

class PG::DuplicateColumn
end

class PG::DuplicateCursor
end

class PG::DuplicateCursor
end

class PG::DuplicateDatabase
end

class PG::DuplicateDatabase
end

class PG::DuplicateFile
end

class PG::DuplicateFile
end

class PG::DuplicateFunction
end

class PG::DuplicateFunction
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateObject
end

class PG::DuplicateObject
end

class PG::DuplicatePstatement
end

class PG::DuplicatePstatement
end

class PG::DuplicateSchema
end

class PG::DuplicateSchema
end

class PG::DuplicateTable
end

class PG::DuplicateTable
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ErrorInAssignment
end

class PG::ErrorInAssignment
end

class PG::EscapeCharacterConflict
end

class PG::EscapeCharacterConflict
end

class PG::ExclusionViolation
end

class PG::ExclusionViolation
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineInvocationException
end

class PG::ExternalRoutineInvocationException
end

class PG::FdwColumnNameNotFound
end

class PG::FdwColumnNameNotFound
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwError
end

class PG::FdwError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwNoSchemas
end

class PG::FdwNoSchemas
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOutOfMemory
end

class PG::FdwOutOfMemory
end

class PG::FdwReplyHandle
end

class PG::FdwReplyHandle
end

class PG::FdwSchemaNotFound
end

class PG::FdwSchemaNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTooManyHandles
end

class PG::FdwTooManyHandles
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToEstablishConnection
end

class PG::FdwUnableToEstablishConnection
end

class PG::FeatureNotSupported
end

class PG::FeatureNotSupported
end

class PG::FloatingPointException
end

class PG::FloatingPointException
end

class PG::ForeignKeyViolation
end

class PG::ForeignKeyViolation
end

class PG::GeneratedAlways
end

class PG::GeneratedAlways
end

class PG::GroupingError
end

class PG::GroupingError
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleInTransactionSessionTimeout
end

class PG::InFailedSqlTransaction
end

class PG::InFailedSqlTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::IndeterminateCollation
end

class PG::IndeterminateCollation
end

class PG::IndeterminateDatatype
end

class PG::IndeterminateDatatype
end

class PG::IndexCorrupted
end

class PG::IndexCorrupted
end

class PG::IndicatorOverflow
end

class PG::IndicatorOverflow
end

class PG::InsufficientPrivilege
end

class PG::InsufficientPrivilege
end

class PG::InsufficientResources
end

class PG::InsufficientResources
end

class PG::IntegrityConstraintViolation
end

class PG::IntegrityConstraintViolation
end

class PG::InternalError
end

class PG::InternalError
end

class PG::IntervalFieldOverflow
end

class PG::IntervalFieldOverflow
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidCatalogName
end

class PG::InvalidCatalogName
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnReference
end

class PG::InvalidColumnReference
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorName
end

class PG::InvalidCursorName
end

class PG::InvalidCursorState
end

class PG::InvalidCursorState
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeSequence
end

class PG::InvalidEscapeSequence
end

class PG::InvalidForeignKey
end

class PG::InvalidForeignKey
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantor
end

class PG::InvalidGrantor
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidJsonText
end

class PG::InvalidJsonText
end

class PG::InvalidName
end

class PG::InvalidName
end

class PG::InvalidObjectDefinition
end

class PG::InvalidObjectDefinition
end

class PG::InvalidParameterValue
end

class PG::InvalidParameterValue
end

class PG::InvalidPassword
end

class PG::InvalidPassword
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidRecursion
end

class PG::InvalidRecursion
end

class PG::InvalidRegularExpression
end

class PG::InvalidRegularExpression
end

class PG::InvalidResultStatus
end

class PG::InvalidResultStatus
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaName
end

class PG::InvalidSchemaName
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlStatementName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidTableDefinition
end

class PG::InvalidTableDefinition
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionTermination
end

class PG::InvalidTransactionTermination
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlProcessingInstruction
end

class PG::InvalidXmlProcessingInstruction
end

class PG::IoError
end

class PG::IoError
end

class PG::LEInvalidSpecification
end

class PG::LEInvalidSpecification
end

class PG::LocatorException
end

class PG::LocatorException
end

class PG::LockFileExists
end

class PG::LockFileExists
end

class PG::LockNotAvailable
end

class PG::LockNotAvailable
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MostSpecificTypeMismatch
end

class PG::MostSpecificTypeMismatch
end

class PG::NameTooLong
end

class PG::NameTooLong
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoDataFound
end

class PG::NoDataFound
end

class PG::NoResultError
end

class PG::NoResultError
end

class PG::NoSqlJsonItem
end

class PG::NoSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NotAnXmlDocument
end

class PG::NotAnXmlDocument
end

class PG::NotNullViolation
end

class PG::NotNullViolation
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNotAllowed
end

class PG::NullValueNotAllowed
end

class PG::NumericValueOutOfRange
end

class PG::NumericValueOutOfRange
end

class PG::ObjectInUse
end

class PG::ObjectInUse
end

class PG::ObjectNotInPrerequisiteState
end

class PG::ObjectNotInPrerequisiteState
end

class PG::OperatorIntervention
end

class PG::OperatorIntervention
end

class PG::OutOfMemory
end

class PG::OutOfMemory
end

class PG::PlpgsqlError
end

class PG::PlpgsqlError
end

class PG::ProgramLimitExceeded
end

class PG::ProgramLimitExceeded
end

class PG::ProtocolViolation
end

class PG::ProtocolViolation
end

class PG::QueryCanceled
end

class PG::QueryCanceled
end

class PG::RaiseException
end

class PG::RaiseException
end

class PG::ReadOnlySqlTransaction
end

class PG::ReadOnlySqlTransaction
end

class PG::RecordDecoder
end

class PG::RecordDecoder
end

class PG::RecordEncoder
end

class PG::RecordEncoder
end

class PG::ReservedName
end

class PG::ReservedName
end

class PG::RestrictViolation
end

class PG::RestrictViolation
end

class PG::Result
  include ::Enumerable
  include ::PG::Constants
end

class PG::SEInvalidSpecification
end

class PG::SEInvalidSpecification
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SavepointException
end

class PG::SavepointException
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::ServerError
end

class PG::ServerError
end

class PG::SimpleCoder
end

class PG::SimpleCoder
end

class PG::SimpleDecoder
end

class PG::SimpleDecoder
end

class PG::SimpleEncoder
end

class PG::SimpleEncoder
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SnapshotTooOld
end

class PG::SnapshotTooOld
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonScalarRequired
end

class PG::SqlJsonScalarRequired
end

class PG::SqlRoutineException
end

class PG::SqlRoutineException
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StatementTooComplex
end

class PG::StatementTooComplex
end

class PG::StringDataLengthMismatch
end

class PG::StringDataLengthMismatch
end

class PG::StringDataRightTruncation
end

class PG::StringDataRightTruncation
end

class PG::SubstringError
end

class PG::SubstringError
end

class PG::SyntaxError
end

class PG::SyntaxError
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SystemError
end

class PG::SystemError
end

class PG::TRDeadlockDetected
end

class PG::TRDeadlockDetected
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRSerializationFailure
end

class PG::TRSerializationFailure
end

class PG::TRStatementCompletionUnknown
end

class PG::TRStatementCompletionUnknown
end

class PG::TextDecoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Date
end

class PG::TextDecoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::FromBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::JSON
end

class PG::TextDecoder::Numeric
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Record
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Timestamp
  CFUNC = ::T.let(nil, ::T.untyped)
end

PG::TextDecoder::TimestampWithTimeZone = PG::TextDecoder::Timestamp

PG::TextDecoder::TimestampWithoutTimeZone = PG::TextDecoder::TimestampLocal

class PG::TextEncoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Date
end

class PG::TextEncoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Inet
end

class PG::TextEncoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::JSON
end

class PG::TextEncoder::Numeric
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::QuotedLiteral
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Record
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::TimestampUtc
end

class PG::TextEncoder::TimestampWithTimeZone
end

class PG::TextEncoder::TimestampWithoutTimeZone
end

class PG::TextEncoder::ToBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TooManyArguments
end

class PG::TooManyArguments
end

class PG::TooManyColumns
end

class PG::TooManyColumns
end

class PG::TooManyConnections
end

class PG::TooManyConnections
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyRows
end

class PG::TooManyRows
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionRollback
end

class PG::TransactionRollback
end

class PG::TriggeredActionException
end

class PG::TriggeredActionException
end

class PG::TriggeredDataChangeViolation
end

class PG::TriggeredDataChangeViolation
end

class PG::TrimError
end

class PG::TrimError
end

class PG::Tuple
  include ::Enumerable
end

class PG::TypeMapAllStrings
end

class PG::TypeMapAllStrings
end

class PG::TypeMapByClass
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByColumn
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByMriType
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByOid
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapInRuby
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::UnableToSend
end

class PG::UnableToSend
end

class PG::UndefinedColumn
end

class PG::UndefinedColumn
end

class PG::UndefinedFile
end

class PG::UndefinedFile
end

class PG::UndefinedFunction
end

class PG::UndefinedFunction
end

class PG::UndefinedObject
end

class PG::UndefinedObject
end

class PG::UndefinedParameter
end

class PG::UndefinedParameter
end

class PG::UndefinedTable
end

class PG::UndefinedTable
end

class PG::UniqueViolation
end

class PG::UniqueViolation
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnterminatedCString
end

class PG::UnterminatedCString
end

class PG::UntranslatableCharacter
end

class PG::UntranslatableCharacter
end

class PG::WindowingError
end

class PG::WindowingError
end

class PG::WithCheckOptionViolation
end

class PG::WithCheckOptionViolation
end

class PG::WrongObjectType
end

class PG::WrongObjectType
end

class PG::ZeroLengthCharacterString
end

class PG::ZeroLengthCharacterString
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Parser::CurrentRuby = Parser::Ruby27

class Parser::Diagnostic
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::MaxNumparamStack
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby27
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

module Polyfill
  VERSION = ::T.let(nil, ::T.untyped)
end

class Proc
  def <<(_); end

  def >>(_); end

  def clone(); end
end

class ProgressBar::Components::Bar
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TEXT_TO_FORMAT = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class Pry
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::Byebug::Breakpoints::FileBreakpoint
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Pry::Byebug::Breakpoints::MethodBreakpoint
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
end

class Pry::CodeFile
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::Command
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  COLORS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::Output
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::Slop
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module PryRemote
  DefaultHost = ::T.let(nil, ::T.untyped)
  DefaultPort = ::T.let(nil, ::T.untyped)
  System = ::T.let(nil, ::T.untyped)
end

module PrySorbet
  VERSION = ::T.let(nil, ::T.untyped)
end

module PryStackExplorer
  Commands = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

class RDoc::Alias
  def initialize(text, old_name, new_name, comment, singleton=T.unsafe(nil)); end
end

class RDoc::Attr
  def initialize(text, name, rw, comment, singleton=T.unsafe(nil)); end
end

class RDoc::ClassModule
  def initialize(name, superclass=T.unsafe(nil)); end
end

class RDoc::CodeObject
  def initialize_visibility(); end
end

class RDoc::Comment
  def initialize(text=T.unsafe(nil), location=T.unsafe(nil), language=T.unsafe(nil)); end

  def line(); end

  def line=(line); end
end

class RDoc::Constant
  def initialize(name, value, comment); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Context
  def add_module_by_normal_module(mod); end

  def initialize_methods_etc(); end
end

class RDoc::Context::Section
  def initialize(parent, title, comment); end
end

class RDoc::CrossReference
  def initialize(context); end
end

class RDoc::ERBIO
  def initialize(str, safe_level=T.unsafe(nil), trim_mode=T.unsafe(nil), eoutvar=T.unsafe(nil)); end
end

module RDoc::Encoding
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

module RDoc::Encoding
  def self.detect_encoding(string); end

  def self.remove_magic_comment(string); end
end

class RDoc::Generator::Darkfish
  def initialize(store, options); end
end

class RDoc::Generator::JsonIndex
  def initialize(parent_generator, options); end
end

class RDoc::Generator::POT
  def initialize(store, options); end
end

class RDoc::Generator::POT::MessageExtractor
  def initialize(store); end
end

class RDoc::Generator::POT::POEntry
  def initialize(msgid, options=T.unsafe(nil)); end
end

class RDoc::Generator::RI
  def initialize(store, options); end
end

class RDoc::I18n::Locale
  def initialize(name); end
end

class RDoc::I18n::Text
  def initialize(raw); end
end

class RDoc::Markdown
  def initialize(extensions=T.unsafe(nil), debug=T.unsafe(nil)); end
end

class RDoc::Markdown::Literals
  def initialize(str, debug=T.unsafe(nil)); end
end

class RDoc::Markdown::Literals::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::Literals::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markdown::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markup
  def add_regexp_handling(pattern, name); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class RDoc::Markup::AttrSpan
  def initialize(length); end
end

class RDoc::Markup::AttributeManager
  def add_regexp_handling(pattern, name); end

  def convert_regexp_handlings(str, attrs); end

  def regexp_handlings(); end
end

class RDoc::Markup::Attributes
  def regexp_handling(); end
end

class RDoc::Markup::Document
  def initialize(*parts); end
end

class RDoc::Markup::Formatter
  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def convert_regexp_handling(target); end

  def initialize(options, markup=T.unsafe(nil)); end
end

class RDoc::Markup::Include
  def initialize(file, include_path); end
end

class RDoc::Markup::IndentedParagraph
  def initialize(indent, *parts); end
end

class RDoc::Markup::List
  def initialize(type=T.unsafe(nil), *items); end
end

class RDoc::Markup::ListItem
  def initialize(label=T.unsafe(nil), *parts); end
end

class RDoc::Markup::Parser::MyStringScanner
  def [](i); end

  def eos?(); end

  def initialize(input); end

  def matched(); end

  def newline!(); end

  def pos(); end

  def scan(re); end

  def unscan(s); end
end

class RDoc::Markup::Parser::MyStringScanner
end

class RDoc::Markup::PreProcess
  def initialize(input_file_name, include_path); end
end

class RDoc::Markup::Raw
  def initialize(*parts); end
end

class RDoc::Markup::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class RDoc::Markup::RegexpHandling
end

class RDoc::Markup::ToHtml
  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToHtmlCrossref
  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToHtmlSnippet
  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToJoinedParagraph
  def initialize(); end
end

class RDoc::Markup::ToLabel
  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToMarkdown
  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToRdoc
  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToTableOfContents
  def initialize(); end
end

class RDoc::Markup::ToTtOnly
  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::MethodAttr
  def initialize(text, name); end
end

class RDoc::Mixin
  def initialize(name, comment); end
end

class RDoc::Parser
  def initialize(top_level, file_name, content, options, stats); end
end

class RDoc::Parser::C
  def do_classes_and_modules(); end
end

class RDoc::Parser::RipperStateLex
  def get_squashed_tk(); end

  def initialize(code); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  RIPPER_HAS_LEX_STATE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::RipperStateLex::InnerStateLex
  def initialize(code); end

  def on_default(event, tok, data); end
end

class RDoc::Parser::RipperStateLex::InnerStateLex
end

class RDoc::Parser::RipperStateLex::Token
  def char_no(); end

  def char_no=(_); end

  def kind(); end

  def kind=(_); end

  def line_no(); end

  def line_no=(_); end

  def state(); end

  def state=(_); end

  def text(); end

  def text=(_); end
end

class RDoc::Parser::RipperStateLex::Token
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Parser::RipperStateLex
  def self.end?(token); end

  def self.parse(code); end
end

class RDoc::Parser::Ruby
  def get_included_module_with_optional_parens(); end

  def retrieve_comment_body(tk); end
end

module RDoc::Parser::RubyTools
  def skip_tkspace_without_nl(); end
end

class RDoc::RD::BlockParser
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::Inline
  def initialize(rdoc, reference); end
end

class RDoc::RD::InlineParser
  def initialize(block_parser); end
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RI::Driver
  def initialize(initial_options=T.unsafe(nil)); end
end

class RDoc::RI::Driver::NotFoundError
  def initialize(klass, suggestions=T.unsafe(nil)); end
end

RDoc::RI::Store = RDoc::Store

class RDoc::Require
  def initialize(name, comment); end
end

class RDoc::Servlet
  def initialize(server, stores, cache, mount_path=T.unsafe(nil), extra_doc_dirs=T.unsafe(nil)); end
end

class RDoc::Stats
  def initialize(store, num_files, verbosity=T.unsafe(nil)); end
end

class RDoc::Stats::Quiet
  def initialize(num_files); end
end

class RDoc::Store
  def initialize(path=T.unsafe(nil), type=T.unsafe(nil)); end

  def unmatched_constant_alias(); end

  def update_parser_of_file(absolute_name, parser); end
end

class RDoc::Store::MissingFileError
  def initialize(store, file, name); end
end

class RDoc::Task
  def before_running_rdoc(&block); end

  def check_names(names); end

  def clobber_task_description(); end

  def defaults(); end

  def define(); end

  def external(); end

  def external=(external); end

  def generator(); end

  def generator=(generator); end

  def initialize(name=T.unsafe(nil)); end

  def inline_source(); end

  def inline_source=(value); end

  def main(); end

  def main=(main); end

  def markup(); end

  def markup=(markup); end

  def name(); end

  def name=(name); end

  def option_list(); end

  def options(); end

  def options=(options); end

  def rdoc_dir(); end

  def rdoc_dir=(rdoc_dir); end

  def rdoc_files(); end

  def rdoc_files=(rdoc_files); end

  def rdoc_task_description(); end

  def rerdoc_task_description(); end

  def template(); end

  def template=(template); end

  def title(); end

  def title=(title); end
end

class RDoc::Task
end

module RDoc::Text
  def language(); end

  def language=(language); end
end

class RDoc::TopLevel
  def initialize(absolute_name, relative_name=T.unsafe(nil)); end
end

class REXML::Parsers::BaseParser
  EXTERNAL_ID_PUBLIC = ::T.let(nil, ::T.untyped)
  EXTERNAL_ID_SYSTEM = ::T.let(nil, ::T.untyped)
  PUBLIC_ID = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
  DEBUG = ::T.let(nil, ::T.untyped)
end

module ROM
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ROM::AutoRegistration
  DEFAULT_MAPPING = ::T.let(nil, ::T.untyped)
  NamespaceType = ::T.let(nil, ::T.untyped)
  PathnameType = ::T.let(nil, ::T.untyped)
end

class ROM::AutoRegistrationStrategies::Base
  EXTENSION_REGEX = ::T.let(nil, ::T.untyped)
  PathnameType = ::T.let(nil, ::T.untyped)
end

class ROM::Changeset
  DEFAULT_COMMAND_OPTS = ::T.let(nil, ::T.untyped)
end

class ROM::Changeset::Stateful
  EMPTY_PIPE = ::T.let(nil, ::T.untyped)
end

class ROM::Command
  CommandType = ::T.let(nil, ::T.untyped)
  Result = ::T.let(nil, ::T.untyped)
end

class ROM::CommandRegistry
  RegistryType = ::T.let(nil, ::T.untyped)
end

class ROM::Configurable::Config
  WRITER_REGEXP = ::T.let(nil, ::T.untyped)
end

class ROM::Header
  TYPE_MAP = ::T.let(nil, ::T.untyped)
end

class ROM::Mapper
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

module ROM::Mapper::ModelDSL
  DEFAULT_TYPE = ::T.let(nil, ::T.untyped)
end

class ROM::OpenStruct
  IVAR = ::T.let(nil, ::T.untyped)
end

module ROM::Plugins::Relation
  EMPTY_REGISTRY = ::T.let(nil, ::T.untyped)
end

module ROM::Processor::Transproc::Functions
  INVALID_INJECT_UNION_VALUE = ::T.let(nil, ::T.untyped)
end

class ROM::Relation
  NOOP_OUTPUT_SCHEMA = ::T.let(nil, ::T.untyped)
end

module ROM::Relation::ClassInterface
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class ROM::Repository
  CHANGESET_TYPES = ::T.let(nil, ::T.untyped)
end

module ROM::SQL
  ERROR_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ROM::SQL::Association
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class ROM::SQL::Attribute
  NONSTANDARD_EQUALITY_VALUES = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
end

class ROM::SQL::Gateway
  CONNECTION_EXTENSIONS = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class ROM::SQL::Migration::Migrator
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
end

module ROM::SQL::Relation::Reading
  ROW_LOCK_MODES = ::T.let(nil, ::T.untyped)
end

class ROM::SQL::Schema::Inferrer
  CONSTRAINT_DB_TYPE = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
end

module ROM::SQL::Types
  Blob = ::T.let(nil, ::T.untyped)
  Serial = ::T.let(nil, ::T.untyped)
  Void = ::T.let(nil, ::T.untyped)
end

module ROM::SQL::Types::PG
  Array = ::T.let(nil, ::T.untyped)
  BoxT = ::T.let(nil, ::T.untyped)
  BoxTR = ::T.let(nil, ::T.untyped)
  Bytea = ::T.let(nil, ::T.untyped)
  CircleT = ::T.let(nil, ::T.untyped)
  CircleTR = ::T.let(nil, ::T.untyped)
  HStore = ::T.let(nil, ::T.untyped)
  HStoreR = ::T.let(nil, ::T.untyped)
  IPAddress = ::T.let(nil, ::T.untyped)
  IPAddressR = ::T.let(nil, ::T.untyped)
  JSON = ::T.let(nil, ::T.untyped)
  JSONArray = ::T.let(nil, ::T.untyped)
  JSONB = ::T.let(nil, ::T.untyped)
  JSONBArray = ::T.let(nil, ::T.untyped)
  JSONBHash = ::T.let(nil, ::T.untyped)
  JSONBOp = ::T.let(nil, ::T.untyped)
  JSONHash = ::T.let(nil, ::T.untyped)
  JSONOp = ::T.let(nil, ::T.untyped)
  LineSegmentT = ::T.let(nil, ::T.untyped)
  LineSegmentTR = ::T.let(nil, ::T.untyped)
  LineT = ::T.let(nil, ::T.untyped)
  LineTR = ::T.let(nil, ::T.untyped)
  Money = ::T.let(nil, ::T.untyped)
  PathD = ::T.let(nil, ::T.untyped)
  PathT = ::T.let(nil, ::T.untyped)
  PathTR = ::T.let(nil, ::T.untyped)
  PointD = ::T.let(nil, ::T.untyped)
  PointT = ::T.let(nil, ::T.untyped)
  PointTR = ::T.let(nil, ::T.untyped)
  Polygon = ::T.let(nil, ::T.untyped)
  PolygonT = ::T.let(nil, ::T.untyped)
  PolygonTR = ::T.let(nil, ::T.untyped)
  UUID = ::T.let(nil, ::T.untyped)
end

class ROM::Schema
  DEFAULT_INFERRER = ::T.let(nil, ::T.untyped)
  EMPTY_ASSOCIATION_SET = ::T.let(nil, ::T.untyped)
end

class ROM::Transaction
  NoOp = ::T.let(nil, ::T.untyped)
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

Rack::File = Rack::Files

class Rack::Files
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

class Rack::Lint::HijackWrapper
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::Parser
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

class Rack::QueryParser
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::Request
  def query(); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::Response
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Cookie::SessionId
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
  DELIMITER = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
  NOT_SET = ::T.let(nil, ::T.untyped)
end

Rake::RDocTask = RDoc::Task

class Rake::Scope
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::TaskLib
  include ::FileUtils::StreamUtils_
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake
  extend ::FileUtils::StreamUtils_
end

RakeFileUtils = Rake::FileUtilsExt

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module RbReadline
  ABORT_CHAR = ::T.let(nil, ::T.untyped)
  ANCHORED_SEARCH = ::T.let(nil, ::T.untyped)
  ANYOTHERKEY = ::T.let(nil, ::T.untyped)
  AUDIBLE_BELL = ::T.let(nil, ::T.untyped)
  BAD_MODIFIER = ::T.let(nil, ::T.untyped)
  BAD_WORD_SPEC = ::T.let(nil, ::T.untyped)
  BFIND = ::T.let(nil, ::T.untyped)
  BTO = ::T.let(nil, ::T.untyped)
  CapCase = ::T.let(nil, ::T.untyped)
  DEFAULT_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_INPUTRC = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_KILLS = ::T.let(nil, ::T.untyped)
  DownCase = ::T.let(nil, ::T.untyped)
  EOF = ::T.let(nil, ::T.untyped)
  ESC = ::T.let(nil, ::T.untyped)
  EVENT_NOT_FOUND = ::T.let(nil, ::T.untyped)
  FFIND = ::T.let(nil, ::T.untyped)
  FTO = ::T.let(nil, ::T.untyped)
  HISTORY_APPEND = ::T.let(nil, ::T.untyped)
  HISTORY_OVERWRITE = ::T.let(nil, ::T.untyped)
  HISTORY_QUOTE_CHARACTERS = ::T.let(nil, ::T.untyped)
  HISTORY_WORD_DELIMITERS = ::T.let(nil, ::T.untyped)
  ISFUNC = ::T.let(nil, ::T.untyped)
  ISKMAP = ::T.let(nil, ::T.untyped)
  ISMACR = ::T.let(nil, ::T.untyped)
  KEYMAP_SIZE = ::T.let(nil, ::T.untyped)
  KSEQ_DISPATCHED = ::T.let(nil, ::T.untyped)
  KSEQ_RECURSIVE = ::T.let(nil, ::T.untyped)
  KSEQ_SUBSEQ = ::T.let(nil, ::T.untyped)
  MB_FIND_ANY = ::T.let(nil, ::T.untyped)
  MB_FIND_NONZERO = ::T.let(nil, ::T.untyped)
  MB_LEN_MAX = ::T.let(nil, ::T.untyped)
  MULT_MATCH = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  NON_ANCHORED_SEARCH = ::T.let(nil, ::T.untyped)
  NO_BELL = ::T.let(nil, ::T.untyped)
  NO_MATCH = ::T.let(nil, ::T.untyped)
  NO_PREV_SUBST = ::T.let(nil, ::T.untyped)
  NUM_READONE = ::T.let(nil, ::T.untyped)
  NUM_SAWDIGITS = ::T.let(nil, ::T.untyped)
  NUM_SAWMINUS = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  RB_READLINE_VERSION = ::T.let(nil, ::T.untyped)
  READERR = ::T.let(nil, ::T.untyped)
  RETURN = ::T.let(nil, ::T.untyped)
  RL_IM_DEFAULT = ::T.let(nil, ::T.untyped)
  RL_IM_INSERT = ::T.let(nil, ::T.untyped)
  RL_IM_OVERWRITE = ::T.let(nil, ::T.untyped)
  RL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  RL_PROMPT_END_IGNORE = ::T.let(nil, ::T.untyped)
  RL_PROMPT_START_IGNORE = ::T.let(nil, ::T.untyped)
  RL_QF_BACKSLASH = ::T.let(nil, ::T.untyped)
  RL_QF_DOUBLE_QUOTE = ::T.let(nil, ::T.untyped)
  RL_QF_OTHER_QUOTE = ::T.let(nil, ::T.untyped)
  RL_QF_SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  RL_READLINE_VERSION = ::T.let(nil, ::T.untyped)
  RL_SEARCH_CSEARCH = ::T.let(nil, ::T.untyped)
  RL_SEARCH_ISEARCH = ::T.let(nil, ::T.untyped)
  RL_SEARCH_NSEARCH = ::T.let(nil, ::T.untyped)
  RL_STATE_CALLBACK = ::T.let(nil, ::T.untyped)
  RL_STATE_COMPLETING = ::T.let(nil, ::T.untyped)
  RL_STATE_DISPATCHING = ::T.let(nil, ::T.untyped)
  RL_STATE_DONE = ::T.let(nil, ::T.untyped)
  RL_STATE_INITIALIZED = ::T.let(nil, ::T.untyped)
  RL_STATE_INITIALIZING = ::T.let(nil, ::T.untyped)
  RL_STATE_INPUTPENDING = ::T.let(nil, ::T.untyped)
  RL_STATE_ISEARCH = ::T.let(nil, ::T.untyped)
  RL_STATE_MACRODEF = ::T.let(nil, ::T.untyped)
  RL_STATE_MACROINPUT = ::T.let(nil, ::T.untyped)
  RL_STATE_METANEXT = ::T.let(nil, ::T.untyped)
  RL_STATE_MOREINPUT = ::T.let(nil, ::T.untyped)
  RL_STATE_MULTIKEY = ::T.let(nil, ::T.untyped)
  RL_STATE_NONE = ::T.let(nil, ::T.untyped)
  RL_STATE_NSEARCH = ::T.let(nil, ::T.untyped)
  RL_STATE_NUMERICARG = ::T.let(nil, ::T.untyped)
  RL_STATE_OVERWRITE = ::T.let(nil, ::T.untyped)
  RL_STATE_READCMD = ::T.let(nil, ::T.untyped)
  RL_STATE_SEARCH = ::T.let(nil, ::T.untyped)
  RL_STATE_SIGHANDLER = ::T.let(nil, ::T.untyped)
  RL_STATE_TERMPREPPED = ::T.let(nil, ::T.untyped)
  RL_STATE_TTYCSAVED = ::T.let(nil, ::T.untyped)
  RL_STATE_UNDOING = ::T.let(nil, ::T.untyped)
  RL_STATE_VICMDONCE = ::T.let(nil, ::T.untyped)
  RL_STATE_VIMOTION = ::T.let(nil, ::T.untyped)
  RUBOUT = ::T.let(nil, ::T.untyped)
  SF_FAILED = ::T.let(nil, ::T.untyped)
  SF_FOUND = ::T.let(nil, ::T.untyped)
  SF_REVERSE = ::T.let(nil, ::T.untyped)
  SINGLE_MATCH = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  SUBST_FAILED = ::T.let(nil, ::T.untyped)
  SYS_INPUTRC = ::T.let(nil, ::T.untyped)
  TAB = ::T.let(nil, ::T.untyped)
  UNDO_BEGIN = ::T.let(nil, ::T.untyped)
  UNDO_DELETE = ::T.let(nil, ::T.untyped)
  UNDO_END = ::T.let(nil, ::T.untyped)
  UNDO_INSERT = ::T.let(nil, ::T.untyped)
  UpCase = ::T.let(nil, ::T.untyped)
  VISIBLE_BELL = ::T.let(nil, ::T.untyped)
  XOK = ::T.let(nil, ::T.untyped)
end

class Reform::Contract::Result::Errors
  DottedErrors = ::T.let(nil, ::T.untyped)
end

class Reform::Form
  Deserialize = ::T.let(nil, ::T.untyped)
end

class Reform::Form::Call::Result
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Regexp
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::Quantifier
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

module Reline
  def eof?(*args, &block); end
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  RAW_KEYSTROKE_CONFIG = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  def self.clear_screen(); end

  def self.cursor_pos(); end

  def self.deprep(otio); end

  def self.encoding(); end

  def self.erase_after_cursor(); end

  def self.get_screen_size(); end

  def self.getc(); end

  def self.input=(val); end

  def self.move_cursor_column(x); end

  def self.move_cursor_down(x); end

  def self.move_cursor_up(x); end

  def self.output=(val); end

  def self.prep(); end

  def self.retrieve_keybuffer(); end

  def self.scroll_down(x); end

  def self.set_screen_size(rows, columns); end

  def self.set_winch_handler(&handler); end

  def self.ungetc(c); end

  def self.win?(); end
end

class Reline::Config
  def add_default_key_binding(keystroke, target); end

  def bind_key(key, func_name); end

  def bind_tty_special_chars(); end

  def bind_tty_special_chars=(bind_tty_special_chars); end

  def bind_variable(name, value); end

  def blink_matching_paren(); end

  def blink_matching_paren=(blink_matching_paren); end

  def byte_oriented(); end

  def byte_oriented=(byte_oriented); end

  def completion_ignore_case(); end

  def completion_ignore_case=(completion_ignore_case); end

  def convert_meta(); end

  def convert_meta=(convert_meta); end

  def disable_completion(); end

  def disable_completion=(disable_completion); end

  def editing_mode(); end

  def editing_mode=(val); end

  def editing_mode_is?(*val); end

  def emacs_mode_string(); end

  def emacs_mode_string=(emacs_mode_string); end

  def enable_keypad(); end

  def enable_keypad=(enable_keypad); end

  def expand_tilde(); end

  def expand_tilde=(expand_tilde); end

  def handle_directive(directive, file, no); end

  def history_preserve_point(); end

  def history_preserve_point=(history_preserve_point); end

  def history_size(); end

  def history_size=(history_size); end

  def horizontal_scroll_mode(); end

  def horizontal_scroll_mode=(horizontal_scroll_mode); end

  def input_meta(); end

  def input_meta=(input_meta); end

  def inputrc_path(); end

  def key_bindings(); end

  def key_notation_to_code(notation); end

  def keymap(); end

  def keyseq_timeout(); end

  def keyseq_timeout=(keyseq_timeout); end

  def mark_directories(); end

  def mark_directories=(mark_directories); end

  def mark_modified_lines(); end

  def mark_modified_lines=(mark_modified_lines); end

  def mark_symlinked_directories(); end

  def mark_symlinked_directories=(mark_symlinked_directories); end

  def match_hidden_files(); end

  def match_hidden_files=(match_hidden_files); end

  def meta_flag(); end

  def meta_flag=(meta_flag); end

  def output_meta(); end

  def output_meta=(output_meta); end

  def page_completions(); end

  def page_completions=(page_completions); end

  def parse_keyseq(str); end

  def prefer_visible_bell(); end

  def prefer_visible_bell=(prefer_visible_bell); end

  def print_completions_horizontally(); end

  def print_completions_horizontally=(print_completions_horizontally); end

  def read(file=T.unsafe(nil)); end

  def read_lines(lines, file=T.unsafe(nil)); end

  def reset(); end

  def reset_default_key_bindings(); end

  def retrieve_string(str); end

  def show_all_if_ambiguous(); end

  def show_all_if_ambiguous=(show_all_if_ambiguous); end

  def show_all_if_unmodified(); end

  def show_all_if_unmodified=(show_all_if_unmodified); end

  def show_mode_in_prompt(); end

  def show_mode_in_prompt=(show_mode_in_prompt); end

  def test_mode(); end

  def vi_cmd_mode_icon(); end

  def vi_cmd_mode_icon=(vi_cmd_mode_icon); end

  def vi_ins_mode_icon(); end

  def vi_ins_mode_icon=(vi_ins_mode_icon); end

  def visible_stats(); end

  def visible_stats=(visible_stats); end
  KEYSEQ_PATTERN = ::T.let(nil, ::T.untyped)
  VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
  VARIABLE_NAME_SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Reline::Config::InvalidInputrc
  def file(); end

  def file=(file); end

  def lineno(); end

  def lineno=(lineno); end
end

class Reline::Config::InvalidInputrc
end

class Reline::Config
end

class Reline::Core
  def ambiguous_width(); end

  def ambiguous_width=(ambiguous_width); end

  def auto_indent_proc(); end

  def auto_indent_proc=(p); end

  def basic_quote_characters(); end

  def basic_quote_characters=(v); end

  def basic_word_break_characters(); end

  def basic_word_break_characters=(v); end

  def completer_quote_characters(); end

  def completer_quote_characters=(v); end

  def completer_word_break_characters(); end

  def completer_word_break_characters=(v); end

  def completion_append_character(); end

  def completion_append_character=(val); end

  def completion_case_fold(); end

  def completion_case_fold=(v); end

  def completion_proc(); end

  def completion_proc=(p); end

  def completion_quote_character(); end

  def config(); end

  def config=(config); end

  def dig_perfect_match_proc(); end

  def dig_perfect_match_proc=(p); end

  def emacs_editing_mode(); end

  def emacs_editing_mode?(); end

  def encoding(); end

  def filename_quote_characters(); end

  def filename_quote_characters=(v); end

  def get_screen_size(); end

  def input=(val); end

  def key_stroke(); end

  def key_stroke=(key_stroke); end

  def last_incremental_search(); end

  def last_incremental_search=(last_incremental_search); end

  def line_editor(); end

  def line_editor=(line_editor); end

  def output(); end

  def output=(val); end

  def output_modifier_proc(); end

  def output_modifier_proc=(p); end

  def pre_input_hook(); end

  def pre_input_hook=(p); end

  def prompt_proc(); end

  def prompt_proc=(p); end

  def readline(prompt=T.unsafe(nil), add_hist=T.unsafe(nil)); end

  def readmultiline(prompt=T.unsafe(nil), add_hist=T.unsafe(nil), &confirm_multiline_termination); end

  def special_prefixes(); end

  def special_prefixes=(v); end

  def vi_editing_mode(); end

  def vi_editing_mode?(); end
  ATTR_READER_NAMES = ::T.let(nil, ::T.untyped)
end

class Reline::Core
end

class Reline::CursorPos
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Reline::CursorPos
  def self.[](*_); end

  def self.members(); end
end

class Reline::GeneralIO
  RAW_KEYSTROKE_CONFIG = ::T.let(nil, ::T.untyped)
end

class Reline::GeneralIO
  def self.clear_screen(); end

  def self.cursor_pos(); end

  def self.deprep(otio); end

  def self.encoding(); end

  def self.erase_after_cursor(); end

  def self.get_screen_size(); end

  def self.getc(); end

  def self.input=(val); end

  def self.move_cursor_column(val); end

  def self.move_cursor_down(val); end

  def self.move_cursor_up(val); end

  def self.prep(); end

  def self.scroll_down(val); end

  def self.set_screen_size(rows, columns); end

  def self.set_winch_handler(&handler); end

  def self.ungetc(c); end

  def self.win?(); end
end

class Reline::History
  def <<(val); end

  def [](index); end

  def []=(index, val); end

  def concat(*val); end

  def delete_at(index); end

  def initialize(config); end

  def push(*val); end
end

class Reline::History
end

Reline::IOGate = Reline::ANSI

Reline::Key = Struct::Key

module Reline::KeyActor
end

class Reline::KeyActor::Base
  def get_method(key); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Base
end

class Reline::KeyActor::Emacs
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Emacs
end

class Reline::KeyActor::ViCommand
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViCommand
end

class Reline::KeyActor::ViInsert
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViInsert
end

module Reline::KeyActor
end

class Reline::KeyStroke
  def expand(input); end

  def initialize(config); end

  def match_status(input); end
end

class Reline::KeyStroke
end

class Reline::KillRing
  def append(string, before_p=T.unsafe(nil)); end

  def initialize(max=T.unsafe(nil)); end

  def process(); end

  def yank(); end

  def yank_pop(); end
end

class Reline::KillRing::RingBuffer
  def <<(point); end

  def empty?(); end

  def head(); end

  def initialize(max=T.unsafe(nil)); end

  def size(); end
end

class Reline::KillRing::RingBuffer
end

class Reline::KillRing::RingPoint
  def ==(other); end

  def backward(); end

  def backward=(_); end

  def forward(); end

  def forward=(_); end

  def initialize(str); end

  def str(); end

  def str=(_); end
end

class Reline::KillRing::RingPoint
  def self.[](*_); end

  def self.members(); end
end

module Reline::KillRing::State
  CONTINUED = ::T.let(nil, ::T.untyped)
  FRESH = ::T.let(nil, ::T.untyped)
  PROCESSED = ::T.let(nil, ::T.untyped)
  YANK = ::T.let(nil, ::T.untyped)
end

module Reline::KillRing::State
end

class Reline::KillRing
end

class Reline::LineEditor
  def auto_indent_proc(); end

  def auto_indent_proc=(auto_indent_proc); end

  def byte_pointer(); end

  def byte_pointer=(val); end

  def call_completion_proc(); end

  def completion_append_character(); end

  def completion_append_character=(completion_append_character); end

  def completion_proc(); end

  def completion_proc=(completion_proc); end

  def confirm_multiline_termination(); end

  def confirm_multiline_termination_proc(); end

  def confirm_multiline_termination_proc=(confirm_multiline_termination_proc); end

  def delete_text(start=T.unsafe(nil), length=T.unsafe(nil)); end

  def dig_perfect_match_proc(); end

  def dig_perfect_match_proc=(dig_perfect_match_proc); end

  def editing_mode(); end

  def eof?(); end

  def finalize(); end

  def finish(); end

  def finished?(); end

  def initialize(config, encoding); end

  def input_key(key); end

  def insert_text(text); end

  def line(); end

  def multiline_off(); end

  def multiline_on(); end

  def output=(output); end

  def output_modifier_proc(); end

  def output_modifier_proc=(output_modifier_proc); end

  def pre_input_hook(); end

  def pre_input_hook=(pre_input_hook); end

  def prompt_proc(); end

  def prompt_proc=(prompt_proc); end

  def rerender(); end

  def reset(prompt=T.unsafe(nil), encoding:); end

  def reset_line(); end

  def reset_variables(prompt=T.unsafe(nil), encoding:); end

  def retrieve_completion_block(set_completion_quote_character=T.unsafe(nil)); end

  def whole_buffer(); end

  def whole_lines(index: T.unsafe(nil), line: T.unsafe(nil)); end
  VI_MOTIONS = ::T.let(nil, ::T.untyped)
end

Reline::LineEditor::CompletionJourneyData = Struct::CompletionJourneyData

module Reline::LineEditor::CompletionState
  COMPLETION = ::T.let(nil, ::T.untyped)
  JOURNEY = ::T.let(nil, ::T.untyped)
  MENU = ::T.let(nil, ::T.untyped)
  MENU_WITH_PERFECT_MATCH = ::T.let(nil, ::T.untyped)
  NORMAL = ::T.let(nil, ::T.untyped)
  PERFECT_MATCH = ::T.let(nil, ::T.untyped)
end

module Reline::LineEditor::CompletionState
end

Reline::LineEditor::MenuInfo = Struct::MenuInfo

class Reline::LineEditor
end

class Reline::Unicode
  CSI_REGEXP = ::T.let(nil, ::T.untyped)
  EscapedChars = ::T.let(nil, ::T.untyped)
  EscapedPairs = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
  OSC_REGEXP = ::T.let(nil, ::T.untyped)
  WIDTH_SCANNER = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
  TYPE_A = ::T.let(nil, ::T.untyped)
  TYPE_F = ::T.let(nil, ::T.untyped)
  TYPE_H = ::T.let(nil, ::T.untyped)
  TYPE_N = ::T.let(nil, ::T.untyped)
  TYPE_NA = ::T.let(nil, ::T.untyped)
  TYPE_W = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
end

class Reline::Unicode
  def self.calculate_width(str, allow_escape_code=T.unsafe(nil)); end

  def self.ed_transpose_words(line, byte_pointer); end

  def self.em_backward_word(line, byte_pointer); end

  def self.em_big_backward_word(line, byte_pointer); end

  def self.em_forward_word(line, byte_pointer); end

  def self.em_forward_word_with_capitalization(line, byte_pointer); end

  def self.escape_for_print(str); end

  def self.get_mbchar_byte_size_by_first_char(c); end

  def self.get_mbchar_width(mbchar); end

  def self.get_next_mbchar_size(line, byte_pointer); end

  def self.get_prev_mbchar_size(line, byte_pointer); end

  def self.split_by_width(str, max_width, encoding=T.unsafe(nil)); end

  def self.vi_backward_word(line, byte_pointer); end

  def self.vi_big_backward_word(line, byte_pointer); end

  def self.vi_big_forward_end_word(line, byte_pointer); end

  def self.vi_big_forward_word(line, byte_pointer); end

  def self.vi_first_print(line); end

  def self.vi_forward_end_word(line, byte_pointer); end

  def self.vi_forward_word(line, byte_pointer); end
end

module Reline
  extend ::Forwardable
  extend ::SingleForwardable
  def self.ambiguous_width(*args, &block); end

  def self.auto_indent_proc(*args, &block); end

  def self.auto_indent_proc=(*args, &block); end

  def self.basic_quote_characters(*args, &block); end

  def self.basic_quote_characters=(*args, &block); end

  def self.basic_word_break_characters(*args, &block); end

  def self.basic_word_break_characters=(*args, &block); end

  def self.completer_quote_characters(*args, &block); end

  def self.completer_quote_characters=(*args, &block); end

  def self.completer_word_break_characters(*args, &block); end

  def self.completer_word_break_characters=(*args, &block); end

  def self.completion_append_character(*args, &block); end

  def self.completion_append_character=(*args, &block); end

  def self.completion_case_fold(*args, &block); end

  def self.completion_case_fold=(*args, &block); end

  def self.completion_proc(*args, &block); end

  def self.completion_proc=(*args, &block); end

  def self.completion_quote_character(*args, &block); end

  def self.core(); end

  def self.delete_text(*args, &block); end

  def self.dig_perfect_match_proc(*args, &block); end

  def self.dig_perfect_match_proc=(*args, &block); end

  def self.emacs_editing_mode(*args, &block); end

  def self.emacs_editing_mode?(*args, &block); end

  def self.encoding_system_needs(); end

  def self.eof?(*args, &block); end

  def self.filename_quote_characters(*args, &block); end

  def self.filename_quote_characters=(*args, &block); end

  def self.get_screen_size(*args, &block); end

  def self.input=(*args, &block); end

  def self.insert_text(*args, &block); end

  def self.last_incremental_search(*args, &block); end

  def self.last_incremental_search=(*args, &block); end

  def self.line_buffer(*args, &block); end

  def self.line_editor(); end

  def self.output=(*args, &block); end

  def self.output_modifier_proc(*args, &block); end

  def self.output_modifier_proc=(*args, &block); end

  def self.point(*args, &block); end

  def self.point=(*args, &block); end

  def self.pre_input_hook(*args, &block); end

  def self.pre_input_hook=(*args, &block); end

  def self.prompt_proc(*args, &block); end

  def self.prompt_proc=(*args, &block); end

  def self.readline(*args, &block); end

  def self.readmultiline(*args, &block); end

  def self.redisplay(*args, &block); end

  def self.special_prefixes(*args, &block); end

  def self.special_prefixes=(*args, &block); end

  def self.vi_editing_mode(*args, &block); end

  def self.vi_editing_mode?(*args, &block); end
end

module Representable
  As = ::T.let(nil, ::T.untyped)
  AssignAs = ::T.let(nil, ::T.untyped)
  AssignFragment = ::T.let(nil, ::T.untyped)
  AssignName = ::T.let(nil, ::T.untyped)
  Decorate = ::T.let(nil, ::T.untyped)
  Default = ::T.let(nil, ::T.untyped)
  Deserialize = ::T.let(nil, ::T.untyped)
  Deserializer = ::T.let(nil, ::T.untyped)
  FindOrInstantiate = ::T.let(nil, ::T.untyped)
  GetValue = ::T.let(nil, ::T.untyped)
  Getter = ::T.let(nil, ::T.untyped)
  If = ::T.let(nil, ::T.untyped)
  OptionsForNested = ::T.let(nil, ::T.untyped)
  OverwriteOnNil = ::T.let(nil, ::T.untyped)
  ParseFilter = ::T.let(nil, ::T.untyped)
  Prepare = ::T.let(nil, ::T.untyped)
  ReadFragment = ::T.let(nil, ::T.untyped)
  Reader = ::T.let(nil, ::T.untyped)
  RenderDefault = ::T.let(nil, ::T.untyped)
  RenderFilter = ::T.let(nil, ::T.untyped)
  Serialize = ::T.let(nil, ::T.untyped)
  Serializer = ::T.let(nil, ::T.untyped)
  SetValue = ::T.let(nil, ::T.untyped)
  Setter = ::T.let(nil, ::T.untyped)
  SkipParse = ::T.let(nil, ::T.untyped)
  SkipRender = ::T.let(nil, ::T.untyped)
  Stop = ::T.let(nil, ::T.untyped)
  StopOnExcluded = ::T.let(nil, ::T.untyped)
  StopOnNil = ::T.let(nil, ::T.untyped)
  StopOnNotFound = ::T.let(nil, ::T.untyped)
  StopOnSkipable = ::T.let(nil, ::T.untyped)
  WriteFragment = ::T.let(nil, ::T.untyped)
  Writer = ::T.let(nil, ::T.untyped)
end

module Representable::CreateObject
  Class = ::T.let(nil, ::T.untyped)
  Instance = ::T.let(nil, ::T.untyped)
  Populator = ::T.let(nil, ::T.untyped)
end

module Representable::Declarative
  NestedBuilder = ::T.let(nil, ::T.untyped)
end

class Representable::Decorator
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
end

module Representable::Hash::AllowSymbols
end

module Representable::Hash::AllowSymbols
end

module Representable::Hash::Collection
  include ::Representable::Hash
  include ::Representable
  def create_representation_with(doc, options, format); end

  def update_properties_from(doc, options, format); end
end

module Representable::Hash::Collection::ClassMethods
  def items(options=T.unsafe(nil), &block); end
end

module Representable::Hash::Collection::ClassMethods
end

module Representable::Hash::Collection
  extend ::Representable::Declarative
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Hash::ClassMethods
  def self.included(base); end
end

module Representable::HashMethods
  def create_representation_with(doc, options, format); end

  def update_properties_from(doc, options, format); end
end

module Representable::HashMethods
end

module Representable::Object
  def from_object(data, options=T.unsafe(nil), binding_builder=T.unsafe(nil)); end

  def to_object(options=T.unsafe(nil), binding_builder=T.unsafe(nil)); end
end

class Representable::Object::Binding
  def deserialize_method(); end

  def read(hash, as); end

  def serialize_method(); end

  def write(hash, fragment, as); end
end

class Representable::Object::Binding::Collection
  include ::Representable::Binding::Collection
end

class Representable::Object::Binding::Collection
end

class Representable::Object::Binding
  def self.build_for(definition); end
end

module Representable::Object::ClassMethods
  def collection_representer_class(); end
end

module Representable::Object::ClassMethods
end

module Representable::Object
  def self.included(base); end
end

class Representable::Pipeline
  Insert = ::T.let(nil, ::T.untyped)
end

class Representable::Populator
  FindOrInstantiate = ::T.let(nil, ::T.untyped)
end

module Representable::XML
  def from_node(node, options=T.unsafe(nil)); end

  def from_xml(doc, *args); end

  def parse(doc, *args); end

  def render(*args); end

  def to_node(options=T.unsafe(nil)); end

  def to_xml(*args); end
end

class Representable::XML::Binding
  def deserialize_from(nodes); end

  def deserialize_method(); end

  def read(node, as); end

  def serialize_for(value, parent, as); end

  def serialize_method(); end

  def serialize_node(node, value, as); end

  def write(parent, fragments, as); end
end

class Representable::XML::Binding::Attribute
  def write(parent, value, as); end
end

class Representable::XML::Binding::Attribute
end

class Representable::XML::Binding::AttributeHash
  def deserialize_from(node); end

  def write(parent, value, as); end
end

class Representable::XML::Binding::AttributeHash
end

class Representable::XML::Binding::Collection
  include ::Representable::Binding::Collection
end

class Representable::XML::Binding::Collection
end

class Representable::XML::Binding::Content
  def serialize_for(value, parent); end

  def write(parent, value, as); end
end

class Representable::XML::Binding::Content
end

class Representable::XML::Binding::Hash
end

class Representable::XML::Binding::Hash
end

class Representable::XML::Binding
  def self.build_for(definition); end
end

module Representable::XML::ClassMethods
  def collection_representer_class(); end

  def format_engine(); end

  def remove_namespaces!(); end
end

module Representable::XML::ClassMethods
end

module Representable::XML::Collection
end

module Representable::XML::Collection::Methods
  def create_representation_with(doc, options, format); end

  def update_properties_from(doc, *args); end
end

module Representable::XML::Collection::Methods
end

module Representable::XML::Collection
  def self.included(base); end
end

module Representable::XML::Namespace
  def add_namespace_definitions!(node, namespaces); end

  def from_node(node, options=T.unsafe(nil)); end

  def representable_map(options, format); end

  def to_node(options=T.unsafe(nil)); end
end

module Representable::XML::Namespace::AsWithNamespace
  def read(node, as); end

  def write(doc, fragment, as); end
end

module Representable::XML::Namespace::AsWithNamespace
end

module Representable::XML::Namespace::DSL
  def namespace(namespace); end

  def namespace_def(mapping); end

  def namespace_defs(); end

  def property(name, options=T.unsafe(nil)); end

  def update_namespace_defs!(namespace_defs); end
end

module Representable::XML::Namespace::DSL
end

module Representable::XML::Namespace
  def self.Namespaced(prefix, name); end

  def self.included(includer); end
end

module Representable::XML
  def self.Node(document, name, attributes=T.unsafe(nil)); end

  def self.included(base); end
end

module Representable::YAML
  include ::Representable::Hash
  include ::Representable
  def from_yaml(doc, options=T.unsafe(nil)); end

  def parse(doc, options=T.unsafe(nil)); end

  def render(*args); end

  def to_ast(options=T.unsafe(nil)); end

  def to_yaml(*args); end
end

class Representable::YAML::Binding
  def node_for(fragment); end

  def write(map, fragment, as); end

  def write_scalar(value); end
end

class Representable::YAML::Binding::Collection
  include ::Representable::Binding::Collection
  def node_for(fragments); end
end

class Representable::YAML::Binding::Collection
end

class Representable::YAML::Binding
end

module Representable::YAML::ClassMethods
  def format_engine(); end
end

module Representable::YAML::ClassMethods
end

module Representable::YAML
  extend ::Representable::Declarative
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Hash::ClassMethods
  def self.included(base); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

module ReverseMarkdown
  VERSION = ::T.let(nil, ::T.untyped)
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(); end

  def scan(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(_); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilder
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  def self.dedent_string(_, _1); end

  def self.lex_state_name(_); end

  def self.token_match(src, pattern); end
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
  VAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug
  def comments(*args, &block); end

  def node_ids(); end

  def tokens(*args, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  def compiler(); end

  def initialize(pattern, compiler: T.unsafe(nil)); end

  def node_pattern(); end

  def pattern(); end

  def test(ruby, trace: T.unsafe(nil)); end
  COLOR_SCHEME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def color_map(color_scheme=T.unsafe(nil)); end

  def colorize(color_scheme=T.unsafe(nil)); end

  def colorizer(); end

  def colorizer=(_); end

  def match_map(); end

  def matched?(node); end

  def returned(); end

  def returned=(_); end

  def ruby_ast(); end

  def ruby_ast=(_); end

  def trace(); end

  def trace=(_); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  def do_compile(); end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  def enter(node_id); end

  def matched?(node_id); end

  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
end

class RuboCop::AST::NodePattern::Compiler::Debug
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  DELTA = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::LexerRex
  CALL = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node
  MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::Repetition
  ARITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser::WithMeta
  def comments(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
  def emit_atom(type, token); end

  def emit_call(type, selector_t, args=T.unsafe(nil)); end

  def emit_list(type, begin_t, children, end_t); end

  def emit_unary_op(type, operator_t=T.unsafe(nil), *children); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
  def initialize(str_or_buffer); end

  def pos(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
end

class RuboCop::AST::NodePattern::Parser::WithMeta
end

module RuboCop::AST::NodePattern::Sets
  MAX = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  SET_0_1 = ::T.let(nil, ::T.untyped)
  SET_10_10 = ::T.let(nil, ::T.untyped)
  SET_1_1 = ::T.let(nil, ::T.untyped)
  SET_ABSTRACT_OVERRIDE_OVERRIDABLE_ETC = ::T.let(nil, ::T.untyped)
  SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  SET_ADD_INDEX_DROP_INDEX = ::T.let(nil, ::T.untyped)
  SET_AFTER_ACTION_APPEND_AFTER_ACTION_APPEND_AROUND_ACTION_ETC = ::T.let(nil, ::T.untyped)
  SET_ANY_ALL_NORETURN_ETC = ::T.let(nil, ::T.untyped)
  SET_AP_P_PP_ETC = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = ::T.let(nil, ::T.untyped)
  SET_BELONGS_TO_HAS_ONE_HAS_MANY_HAS_AND_BELONGS_TO_MANY = ::T.let(nil, ::T.untyped)
  SET_BINWRITE_SYSWRITE_WRITE_WRITE_NONBLOCK = ::T.let(nil, ::T.untyped)
  SET_CALLER_CALLER_LOCATIONS = ::T.let(nil, ::T.untyped)
  SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = ::T.let(nil, ::T.untyped)
  SET_CIPHER_DIGEST = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_INSTANCE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE_STRUCT = ::T.let(nil, ::T.untyped)
  SET_COLLECT_COMPACT_FLATTEN_ETC = ::T.let(nil, ::T.untyped)
  SET_CONSTANTIZE_CONSTANTS_CONST_GET = ::T.let(nil, ::T.untyped)
  SET_COUNT_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_CREATED_AT_UPDATED_AT = ::T.let(nil, ::T.untyped)
  SET_CREATED_AT_UPDATED_AT_2 = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = ::T.let(nil, ::T.untyped)
  SET_DOWNCASE_UPCASE = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_INDEX_WITH_INDEX = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_OBJECT_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  SET_ENUMERATOR_RATIONAL_COMPLEX_THREAD = ::T.let(nil, ::T.untyped)
  SET_ESCAPE_ENCODE_UNESCAPE_DECODE = ::T.let(nil, ::T.untyped)
  SET_EXECUTE_REMOVE_BELONGS_TO = ::T.let(nil, ::T.untyped)
  SET_EXIST_EXISTS = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST_POP_ETC = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST__ETC = ::T.let(nil, ::T.untyped)
  SET_FIRST_TAKE = ::T.let(nil, ::T.untyped)
  SET_FIXNUM_BIGNUM = ::T.let(nil, ::T.untyped)
  SET_FLATTEN_FLATTEN = ::T.let(nil, ::T.untyped)
  SET_FORMAT_SPRINTF_PRINTF = ::T.let(nil, ::T.untyped)
  SET_GEMCUTTER_RUBYGEMS_RUBYFORGE = ::T.let(nil, ::T.untyped)
  SET_GET_POST_PUT_ETC = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB_SUB_SUB = ::T.let(nil, ::T.untyped)
  SET_HAS_MANY_HAS_ONE = ::T.let(nil, ::T.untyped)
  SET_HAS_MANY_HAS_ONE_BELONGS_TO = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_EXTEND_PREPEND = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_MEMBER = ::T.let(nil, ::T.untyped)
  SET_INSERT_INSERT = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = ::T.let(nil, ::T.untyped)
  SET_IO_FILE = ::T.let(nil, ::T.untyped)
  SET_JSON_HSTORE = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES = ::T.let(nil, ::T.untyped)
  SET_KEY_HAS_KEY_FETCH_ETC = ::T.let(nil, ::T.untyped)
  SET_LAST_FIRST = ::T.let(nil, ::T.untyped)
  SET_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_LOAD_RESTORE = ::T.let(nil, ::T.untyped)
  SET_MAP_COLLECT = ::T.let(nil, ::T.untyped)
  SET_MATCH_MATCH = ::T.let(nil, ::T.untyped)
  SET_MATCH__MATCH = ::T.let(nil, ::T.untyped)
  SET_MUST_BE_EMPTY_MUST_EQUAL_MUST_BE_CLOSE_TO_ETC = ::T.let(nil, ::T.untyped)
  SET_MUST_OUTPUT_MUST_RAISE_MUST_BE_SILENT_MUST_THROW = ::T.let(nil, ::T.untyped)
  SET_NEW_COMPILE = ::T.let(nil, ::T.untyped)
  SET_NEW_OPEN = ::T.let(nil, ::T.untyped)
  SET_NIL_ = ::T.let(nil, ::T.untyped)
  SET_ONLY_EXCEPT = ::T.let(nil, ::T.untyped)
  SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PUBLIC = ::T.let(nil, ::T.untyped)
  SET_PROP_CONST = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_REDUCE_INJECT = ::T.let(nil, ::T.untyped)
  SET_REFERER_REFERRER = ::T.let(nil, ::T.untyped)
  SET_REJECT_REJECT = ::T.let(nil, ::T.untyped)
  SET_RENDER_REDIRECT_TO = ::T.let(nil, ::T.untyped)
  SET_REQUIRE_REQUIRE_RELATIVE = ::T.let(nil, ::T.untyped)
  SET_RETURNING_UNIQUE_BY = ::T.let(nil, ::T.untyped)
  SET_SELECT_FIND_ALL = ::T.let(nil, ::T.untyped)
  SET_SELECT_REJECT = ::T.let(nil, ::T.untyped)
  SET_SELECT_SELECT = ::T.let(nil, ::T.untyped)
  SET_SEND_PUBLIC_SEND___SEND__ = ::T.let(nil, ::T.untyped)
  SET_SINCE_FROM_NOW_AFTER_ETC = ::T.let(nil, ::T.untyped)
  SET_SKIP_AFTER_ACTION_SKIP_AROUND_ACTION_SKIP_BEFORE_ACTION_SKIP_ACTION_CALLBACK = ::T.let(nil, ::T.untyped)
  SET_SORT_BY_SORT = ::T.let(nil, ::T.untyped)
  SET_SORT_MIN_MAX = ::T.let(nil, ::T.untyped)
  SET_SPAWN_SYSTEM = ::T.let(nil, ::T.untyped)
  SET_SPRINTF_FORMAT = ::T.let(nil, ::T.untyped)
  SET_START_WITH_END_WITH = ::T.let(nil, ::T.untyped)
  SET_START_WITH_STARTS_WITH_END_WITH_ENDS_WITH = ::T.let(nil, ::T.untyped)
  SET_STRUCT_CLASS = ::T.let(nil, ::T.untyped)
  SET_SUCC_PRED_NEXT = ::T.let(nil, ::T.untyped)
  SET_TASK_NAMESPACE = ::T.let(nil, ::T.untyped)
  SET_TEMPFILE_STRINGIO = ::T.let(nil, ::T.untyped)
  SET_TO_ENUM_ENUM_FOR = ::T.let(nil, ::T.untyped)
  SET_TO_I_TO_F_TO_C = ::T.let(nil, ::T.untyped)
  SET_TRANSLATE_LOCALIZE = ::T.let(nil, ::T.untyped)
  SET_TRUE_FALSE = ::T.let(nil, ::T.untyped)
  SET_TRY_TRY = ::T.let(nil, ::T.untyped)
  SET_TYPE_TEMPLATE_TYPE_MEMBER = ::T.let(nil, ::T.untyped)
  SET_UNIQ_DISTINCT = ::T.let(nil, ::T.untyped)
  SET_ZERO_POSITIVE_NEGATIVE = ::T.let(nil, ::T.untyped)
  SET__ = ::T.let(nil, ::T.untyped)
  SET__AT_SLICE = ::T.let(nil, ::T.untyped)
  SET__EQL_ = ::T.let(nil, ::T.untyped)
  SET__EQUAL_EQL = ::T.let(nil, ::T.untyped)
  SET__GLOB = ::T.let(nil, ::T.untyped)
  SET___ = ::T.let(nil, ::T.untyped)
  SET___2 = ::T.let(nil, ::T.untyped)
  SET___3 = ::T.let(nil, ::T.untyped)
  SET___4 = ::T.let(nil, ::T.untyped)
  SET___5 = ::T.let(nil, ::T.untyped)
  SET___6 = ::T.let(nil, ::T.untyped)
  SET___7 = ::T.let(nil, ::T.untyped)
  SET___8 = ::T.let(nil, ::T.untyped)
  SET___METHOD_____CALLEE__ = ::T.let(nil, ::T.untyped)
  SET___VALUE_EXPECT = ::T.let(nil, ::T.untyped)
  SET____ = ::T.let(nil, ::T.untyped)
  SET____ETC = ::T.let(nil, ::T.untyped)
  SET____ETC_2 = ::T.let(nil, ::T.untyped)
  SET____ETC_3 = ::T.let(nil, ::T.untyped)
  SET____ETC_4 = ::T.let(nil, ::T.untyped)
  SET____ETC_5 = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::RuboCopCompatibility
  INCOMPATIBLE_COPS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
  TYPE_TO_METHOD = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::ExecuteRunner
  INTEGRATION_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::SuggestExtensions
  INCLUDED_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig
  COMMENT_DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  REDUNDANT_DISABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
end

class RuboCop::ConfigObsoletion
  COP_RULE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_RULES_FILE = ::T.let(nil, ::T.untyped)
  PARAMETER_RULE_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedParameter
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::RemovedCop
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigRegeneration
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  COMMAND_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ActiveRecordHelper
  WHERE_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
  CHECKED_OPTIONS_CONFIG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CodeLength
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
  FORMATS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Corrector
  NOOP_CONSUMER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  CORRECTION = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::HashTransformMethod
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::InDeltaMixin
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BeginEndAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  KIND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
  TYPE_MSG = ::T.let(nil, ::T.untyped)
  WIDTH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ParameterAlignment
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RUBY_2_5_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  MSG = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  MATH_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateBranch
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  MSG_REPEATED_ELEMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyClass
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  METACLASS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INVALID = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IdentityComparison
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  ILLEGAL_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  COP_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  MSG = ::T.let(nil, ::T.untyped)
  NIL_SPECIFIC_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SEND_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToEnumArguments
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  METHOD_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  URI_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessTimes
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
  MSG = ::T.let(nil, ::T.untyped)
  OPTIONAL_PARAMETERS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  VAR_SETTER_TO_GETTER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Migration::DepartmentName
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertEmpty
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertEmptyLiteral
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertEqual
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertInDelta
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertIncludes
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertInstanceOf
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertKindOf
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertMatch
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertNil
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertOutput
  MSG = ::T.let(nil, ::T.untyped)
  OUTPUT_GLOBAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertPathExists
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertRespondTo
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertSilent
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertTruthy
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertWithExpectedArgument
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::AssertionInLifecycleHook
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::GlobalExpectations
  BLOCK_MATCHERS = ::T.let(nil, ::T.untyped)
  BLOCK_MATCHERS_STR = ::T.let(nil, ::T.untyped)
  DSL_METHODS_LIST = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VALUE_MATCHERS = ::T.let(nil, ::T.untyped)
  VALUE_MATCHERS_STR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::LiteralAsActualArgument
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::MultipleAssertions
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::NoAssertions
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteEmpty
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteEqual
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteFalse
  MSG_FOR_ASSERT = ::T.let(nil, ::T.untyped)
  MSG_FOR_ASSERT_EQUAL = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteInDelta
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteIncludes
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteInstanceOf
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteKindOf
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteMatch
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteNil
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefutePathExists
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::RefuteRespondTo
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::TestMethodName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Minitest::UnspecifiedException
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MinitestExplorationHelpers
  ASSERTION_METHODS = ::T.let(nil, ::T.untyped)
  ASSERTION_PREFIXES = ::T.let(nil, ::T.untyped)
  FLUNK = ::T.let(nil, ::T.untyped)
  LIFECYCLE_HOOK_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  EXCLUDED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::AncestorsInclude
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::BigDecimalWithNumericArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::IoReadlines
  ENUMERABLE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantSortBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantStringChars
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEABLE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ReverseFirst
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::SortReverse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Squeeze
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::StringInclude
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveRecordCallbacksOrder
  CALLBACKS_IN_ORDER = ::T.let(nil, ::T.untyped)
  CALLBACKS_ORDER_MAP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ContentTag
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DefaultScope
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindById
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Inquiry
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::MailerName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::MatchRoute
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::NegateInclude
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Pick
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Pluck
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::PluckId
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::PluckInWhere
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantForeignKey
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RenderInline
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RenderPlainText
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ShortI18n
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::WhereExists
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rake::ClassDefinitionInTask
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rake::Desc
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rake::DuplicateNamespace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rake::DuplicateTask
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rake::MethodDefinitionInTask
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sequel::ColumnDefault
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sequel::ConcurrentIndex
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sequel::JSONColumn
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sequel::MigrationName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sequel::SaveChanges
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::CallbackConditionalsBinding
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::EnforceSigilOrder
  CODING_REGEX = ::T.let(nil, ::T.untyped)
  FROZEN_REGEX = ::T.let(nil, ::T.untyped)
  INDENT_REGEX = ::T.let(nil, ::T.untyped)
  MAGIC_REGEX = ::T.let(nil, ::T.untyped)
  PREFERRED_ORDER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidExtendTSigHelpersInShims
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidIncludeConstLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidRBIOutsideOfSorbetDir
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidSuperclassConstLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidUntypedStructProps
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::OneAncestorPerLine
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::SignatureBuildOrder
  ORDER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::SingleLineRbiClassModuleDefinitions
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ValidSigil
  SIGIL_REGEX = ::T.let(nil, ::T.untyped)
  STRICTNESS_LEVELS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  ACCESSOR_METHODS = ::T.let(nil, ::T.untyped)
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayCoercion
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::CaseEquality
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassEqualityComparison
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionCompact
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
  BLOCK_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::IfInsideElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
  MSG_IF_ELSE = ::T.let(nil, ::T.untyped)
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LambdaCall
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilLambda
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NonNilCheck
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  BOOLEAN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
  MESSAGE_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  MSG_REDUNDANT_CHARACTER_CLASS = ::T.let(nil, ::T.untyped)
  REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  ALLOWED_ALWAYS_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  MSG_REDUNDANT_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SlicingWithRange
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StaticClass
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SwapValues
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::TernaryParentheses
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VisibilityHelp
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::GitHubActionsFormatter
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::PacmanFormatter
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

module RuboCop::Minitest
  CONFIG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Minitest::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
end

RuboCop::NodePattern::Builder = RuboCop::AST::NodePattern::Builder

class RuboCop::AST::NodePattern::Compiler
end

RuboCop::NodePattern::Compiler::Debug = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler
end

class RuboCop::AST::NodePattern::Lexer
end

RuboCop::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern
end

class RuboCop::Options
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

module RuboCop::Rake
  CONFIG = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Sorbet
  CONFIG = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetFinder
  HIDDEN_PATH_SUBSTRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::GemspecFile
  GEMSPEC_EXTENSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
  FILENAME = ::T.let(nil, ::T.untyped)
end

RuboCop::Token = RuboCop::AST::Token

module RuboCop::Version
  CANONICAL_FEATURE_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

class RubyLex
  def check_code_block(code); end

  def check_corresponding_token_depth(); end

  def check_newline_depth_difference(); end

  def check_state(code); end

  def check_string_literal(); end

  def each_top_level_statement(); end

  def initialize_input(); end

  def lex(); end

  def process_continue(); end

  def process_literal_type(); end

  def process_nesting_level(); end

  def prompt(); end

  def ripper_lex_without_warning(code); end

  def set_auto_indent(context); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end
end

class RubyLex::TerminateLineInput
  def initialize(); end
end

class RubyLex::TerminateLineInput
end

class RubyLex
  def self.compile_with_errors_suppressed(code); end
end

module RubyNext
  LAST_MINOR_VERSIONS = ::T.let(nil, ::T.untyped)
  LATEST_VERSION = ::T.let(nil, ::T.untyped)
  MIN_SUPPORTED_VERSION = ::T.let(nil, ::T.untyped)
  NEXT_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_NEXT_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module RubyNext::Core
end

class RubyNext::Core::Patch
  def body(); end

  def core_ext(); end

  def core_ext?(); end

  def initialize(mod=T.unsafe(nil), method:, version:, name: T.unsafe(nil), supported: T.unsafe(nil), native: T.unsafe(nil), location: T.unsafe(nil), refineable: T.unsafe(nil), core_ext: T.unsafe(nil), singleton: T.unsafe(nil)); end

  def location(); end

  def method_name(); end

  def mod(); end

  def name(); end

  def native(); end

  def native?(); end

  def prepend?(); end

  def refineables(); end

  def singleton(); end

  def singleton?(); end

  def supported(); end

  def supported?(); end

  def to_module(); end

  def version(); end
end

class RubyNext::Core::Patch
end

class RubyNext::Core::Patches
  def <<(patch); end

  def extensions(); end

  def refined(); end
end

class RubyNext::Core::Patches
end

module RubyNext::Core
  def self.backports?(); end

  def self.core_ext?(); end

  def self.inject!(contents); end

  def self.patch(*_, &_1); end

  def self.patches(); end

  def self.refine?(); end

  def self.strategy(); end

  def self.strategy=(val); end
end

module RubyNext::Language
end

module RubyNext::Language::GemTranspiler
end

module RubyNext::Language::GemTranspiler
  def self.maybe_transpile(root_dir, lib_dir, target_dir); end
end

module RubyNext::Language
  def self.runtime?(); end

  def self.setup_gem_load_path(lib_dir=T.unsafe(nil), rbnext_dir: T.unsafe(nil), transpile: T.unsafe(nil)); end
end

module RubyNext::Utils
end

module RubyNext::Utils
  def self.refine_modules?(); end

  def self.resolve_feature_path(feature); end

  def self.source_with_lines(source, path); end
end

module RubyNext
  def self.current_ruby_version(); end

  def self.debug_enabled(); end

  def self.debug_enabled=(val); end

  def self.debug_source(source, filepath=T.unsafe(nil)); end

  def self.next_ruby_version(version=T.unsafe(nil)); end

  def self.silence_warnings(); end

  def self.silence_warnings=(silence_warnings); end

  def self.warn(msg); end
end

class RubyVM::AbstractSyntaxTree::Node
  def ==(other); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def to_sexp(); end
end

class RubyVM::DebugInspector
  VERSION = ::T.let(nil, ::T.untyped)
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

SE = PryStackExplorer

ScanError = StringScanner::Error

module Sequel
  ADAPTER_MAP = ::T.let(nil, ::T.untyped)
  COLUMN_REF_RE1 = ::T.let(nil, ::T.untyped)
  COLUMN_REF_RE2 = ::T.let(nil, ::T.untyped)
  COLUMN_REF_RE3 = ::T.let(nil, ::T.untyped)
  DATABASES = ::T.let(nil, ::T.untyped)
  DEFAULT_INFLECTIONS_PROC = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  OPTS = ::T.let(nil, ::T.untyped)
  SHARED_ADAPTER_MAP = ::T.let(nil, ::T.untyped)
  SPLIT_SYMBOL_CACHE = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VIRTUAL_ROW = ::T.let(nil, ::T.untyped)
end

class Sequel::ConnectionPool
  CONNECTION_POOL_MAP = ::T.let(nil, ::T.untyped)
  CONNECTION_POOL__MAP = ::T.let(nil, ::T.untyped)
  DEFAULT_SERVER = ::T.let(nil, ::T.untyped)
  OPTS = ::T.let(nil, ::T.untyped)
end

class Sequel::Database
  ADAPTERS = ::T.let(nil, ::T.untyped)
  AUTOINCREMENT = ::T.let(nil, ::T.untyped)
  CHECK_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
  COLUMN_DEFINITION_ORDER = ::T.let(nil, ::T.untyped)
  COLUMN_SCHEMA_DATETIME_TYPES = ::T.let(nil, ::T.untyped)
  COLUMN_SCHEMA_STRING_TYPES = ::T.let(nil, ::T.untyped)
  COMBINABLE_ALTER_TABLE_OPS = ::T.let(nil, ::T.untyped)
  COMMA_SEPARATOR = ::T.let(nil, ::T.untyped)
  CURRENT_TIMESTAMP_RE = ::T.let(nil, ::T.untyped)
  DEFAULT_DATABASE_ERROR_REGEXPS = ::T.let(nil, ::T.untyped)
  DEFAULT_JOIN_TABLE_COLUMN_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_STRING_COLUMN_SIZE = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
  LEADING_ZERO_RE = ::T.let(nil, ::T.untyped)
  NOT_NULL = ::T.let(nil, ::T.untyped)
  NOT_NULL_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  OPTS = ::T.let(nil, ::T.untyped)
  PRIMARY_KEY = ::T.let(nil, ::T.untyped)
  SCHEMA_TYPE_CLASSES = ::T.let(nil, ::T.untyped)
  SERIALIZATION_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
  SQL_BEGIN = ::T.let(nil, ::T.untyped)
  SQL_COMMIT = ::T.let(nil, ::T.untyped)
  SQL_RELEASE_SAVEPOINT = ::T.let(nil, ::T.untyped)
  SQL_ROLLBACK = ::T.let(nil, ::T.untyped)
  SQL_ROLLBACK_TO_SAVEPOINT = ::T.let(nil, ::T.untyped)
  SQL_SAVEPOINT = ::T.let(nil, ::T.untyped)
  STRING_DEFAULT_RE = ::T.let(nil, ::T.untyped)
  TEMPORARY = ::T.let(nil, ::T.untyped)
  TRANSACTION_BEGIN = ::T.let(nil, ::T.untyped)
  TRANSACTION_COMMIT = ::T.let(nil, ::T.untyped)
  TRANSACTION_ISOLATION_LEVELS = ::T.let(nil, ::T.untyped)
  TRANSACTION_ROLLBACK = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  UNIQUE = ::T.let(nil, ::T.untyped)
  UNIQUE_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
  UNSIGNED = ::T.let(nil, ::T.untyped)
end

Sequel::Database::DatasetClass = Sequel::Dataset

class Sequel::Dataset
  ACTION_METHODS = ::T.let(nil, ::T.untyped)
  ALL = ::T.let(nil, ::T.untyped)
  AND_SEPARATOR = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  APOS_RE = ::T.let(nil, ::T.untyped)
  ARG_BLOCK_ERROR_MSG = ::T.let(nil, ::T.untyped)
  ARRAY_ACCESS_ERROR_MSG = ::T.let(nil, ::T.untyped)
  ARRAY_EMPTY = ::T.let(nil, ::T.untyped)
  AS = ::T.let(nil, ::T.untyped)
  ASC = ::T.let(nil, ::T.untyped)
  BACKSLASH = ::T.let(nil, ::T.untyped)
  BITCOMP_CLOSE = ::T.let(nil, ::T.untyped)
  BITCOMP_OPEN = ::T.let(nil, ::T.untyped)
  BITWISE_METHOD_MAP = ::T.let(nil, ::T.untyped)
  BOOL_FALSE = ::T.let(nil, ::T.untyped)
  BOOL_TRUE = ::T.let(nil, ::T.untyped)
  BRACKET_CLOSE = ::T.let(nil, ::T.untyped)
  BRACKET_OPEN = ::T.let(nil, ::T.untyped)
  CASE_ELSE = ::T.let(nil, ::T.untyped)
  CASE_END = ::T.let(nil, ::T.untyped)
  CASE_OPEN = ::T.let(nil, ::T.untyped)
  CASE_THEN = ::T.let(nil, ::T.untyped)
  CASE_WHEN = ::T.let(nil, ::T.untyped)
  CAST_OPEN = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  COLUMNS_CLONE_OPTIONS = ::T.let(nil, ::T.untyped)
  COLUMN_CHANGE_OPTS = ::T.let(nil, ::T.untyped)
  COLUMN_REF_RE1 = ::T.let(nil, ::T.untyped)
  COLUMN_REF_RE2 = ::T.let(nil, ::T.untyped)
  COLUMN_REF_RE3 = ::T.let(nil, ::T.untyped)
  COMMA = ::T.let(nil, ::T.untyped)
  COMMA_SEPARATOR = ::T.let(nil, ::T.untyped)
  CONDITIONED_JOIN_TYPES = ::T.let(nil, ::T.untyped)
  CONDITION_FALSE = ::T.let(nil, ::T.untyped)
  CONDITION_TRUE = ::T.let(nil, ::T.untyped)
  COUNT_FROM_SELF_OPTS = ::T.let(nil, ::T.untyped)
  COUNT_OF_ALL_AS_COUNT = ::T.let(nil, ::T.untyped)
  DATASET_ALIAS_BASE_NAME = ::T.let(nil, ::T.untyped)
  DATETIME_SECFRACTION_ARG = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  DEFAULT_PREPARED_STATEMENT_MODULE_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  DESC = ::T.let(nil, ::T.untyped)
  DISTINCT = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  DOUBLE_APOS = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTE = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_PARENS = ::T.let(nil, ::T.untyped)
  EMULATED_FUNCTION_MAP = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXISTS = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  EXTRACT = ::T.let(nil, ::T.untyped)
  FILTER = ::T.let(nil, ::T.untyped)
  FORMAT_DATE = ::T.let(nil, ::T.untyped)
  FORMAT_DATE_STANDARD = ::T.let(nil, ::T.untyped)
  FORMAT_OFFSET = ::T.let(nil, ::T.untyped)
  FORMAT_TIMESTAMP_RE = ::T.let(nil, ::T.untyped)
  FORMAT_USEC = ::T.let(nil, ::T.untyped)
  FOR_UPDATE = ::T.let(nil, ::T.untyped)
  FRAME_ALL = ::T.let(nil, ::T.untyped)
  FRAME_ROWS = ::T.let(nil, ::T.untyped)
  FROM = ::T.let(nil, ::T.untyped)
  FUNCTION_DISTINCT = ::T.let(nil, ::T.untyped)
  GROUP_BY = ::T.let(nil, ::T.untyped)
  HAVING = ::T.let(nil, ::T.untyped)
  IMPORT_ERROR_MSG = ::T.let(nil, ::T.untyped)
  INSERT = ::T.let(nil, ::T.untyped)
  INTO = ::T.let(nil, ::T.untyped)
  IS_LITERALS = ::T.let(nil, ::T.untyped)
  IS_OPERATORS = ::T.let(nil, ::T.untyped)
  JOIN_METHODS = ::T.let(nil, ::T.untyped)
  LATERAL = ::T.let(nil, ::T.untyped)
  LIKE_OPERATORS = ::T.let(nil, ::T.untyped)
  LIMIT = ::T.let(nil, ::T.untyped)
  MUTATION_METHODS = ::T.let(nil, ::T.untyped)
  NON_SQL_OPTIONS = ::T.let(nil, ::T.untyped)
  NOTIMPL_MSG = ::T.let(nil, ::T.untyped)
  NOT_SPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NULLS_FIRST = ::T.let(nil, ::T.untyped)
  NULLS_LAST = ::T.let(nil, ::T.untyped)
  N_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
  OFFSET = ::T.let(nil, ::T.untyped)
  ON = ::T.let(nil, ::T.untyped)
  ON_PAREN = ::T.let(nil, ::T.untyped)
  OPTS = ::T.let(nil, ::T.untyped)
  ORDER_BY = ::T.let(nil, ::T.untyped)
  ORDER_BY_NS = ::T.let(nil, ::T.untyped)
  OVER = ::T.let(nil, ::T.untyped)
  PAREN_CLOSE = ::T.let(nil, ::T.untyped)
  PAREN_OPEN = ::T.let(nil, ::T.untyped)
  PAREN_SPACE_OPEN = ::T.let(nil, ::T.untyped)
  PARTITION_BY = ::T.let(nil, ::T.untyped)
  PREPARED_ARG_PLACEHOLDER = ::T.let(nil, ::T.untyped)
  PREPARED_STATEMENT_MODULE_CODE = ::T.let(nil, ::T.untyped)
  QUALIFY_KEYS = ::T.let(nil, ::T.untyped)
  QUERY_METHODS = ::T.let(nil, ::T.untyped)
  QUESTION_MARK = ::T.let(nil, ::T.untyped)
  QUESTION_MARK_RE = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  QUOTE_RE = ::T.let(nil, ::T.untyped)
  REGEXP_OPERATORS = ::T.let(nil, ::T.untyped)
  RETURNING = ::T.let(nil, ::T.untyped)
  SELECT = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
  SIMPLE_SELECT_ALL_ALLOWED_FROM = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  SPACE_WITH = ::T.let(nil, ::T.untyped)
  SQL_WITH = ::T.let(nil, ::T.untyped)
  STANDARD_TIMESTAMP_FORMAT = ::T.let(nil, ::T.untyped)
  TILDE = ::T.let(nil, ::T.untyped)
  TIMESTAMP_FORMAT = ::T.let(nil, ::T.untyped)
  TRUE_FREEZE = ::T.let(nil, ::T.untyped)
  TWO_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
  UNCONDITIONED_JOIN_TYPES = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  UNION_ALL_SELECT = ::T.let(nil, ::T.untyped)
  UPDATE = ::T.let(nil, ::T.untyped)
  USING = ::T.let(nil, ::T.untyped)
  VALUES = ::T.let(nil, ::T.untyped)
  WHERE = ::T.let(nil, ::T.untyped)
  WILDCARD = ::T.let(nil, ::T.untyped)
  WITHIN_GROUP = ::T.let(nil, ::T.untyped)
  WITH_ORDINALITY = ::T.let(nil, ::T.untyped)
end

module Sequel::Dataset::PreparedStatementMethods
  PLACEHOLDER_RE = ::T.let(nil, ::T.untyped)
end

module Sequel::Inflections
  CAMELIZE_CONVERT_REGEXP = ::T.let(nil, ::T.untyped)
  CAMELIZE_MODULE_REGEXP = ::T.let(nil, ::T.untyped)
  DASH = ::T.let(nil, ::T.untyped)
  DEMODULIZE_CONVERT_REGEXP = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  UNDERSCORE_CONVERT_REGEXP1 = ::T.let(nil, ::T.untyped)
  UNDERSCORE_CONVERT_REGEXP2 = ::T.let(nil, ::T.untyped)
  UNDERSCORE_CONVERT_REPLACE = ::T.let(nil, ::T.untyped)
  UNDERSCORE_MODULE_REGEXP = ::T.let(nil, ::T.untyped)
  VALID_CONSTANT_NAME_REGEXP = ::T.let(nil, ::T.untyped)
end

class Sequel::IntegerMigrator
  DEFAULT_SCHEMA_COLUMN = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEMA_TABLE = ::T.let(nil, ::T.untyped)
end

Sequel::IntegerMigrator::Error = Sequel::Migrator::Error

class Sequel::Migrator
  MIGRATION_FILE_PATTERN = ::T.let(nil, ::T.untyped)
  MIGRATION_SPLITTER = ::T.let(nil, ::T.untyped)
  MINIMUM_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

class Sequel::Model
  AFTER_HOOKS = ::T.let(nil, ::T.untyped)
  AROUND_HOOKS = ::T.let(nil, ::T.untyped)
  BEFORE_HOOKS = ::T.let(nil, ::T.untyped)
  BOOLEAN_SETTINGS = ::T.let(nil, ::T.untyped)
  DATASET_METHODS = ::T.let(nil, ::T.untyped)
  HOOKS = ::T.let(nil, ::T.untyped)
  INHERITED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NORMAL_METHOD_NAME_REGEXP = ::T.let(nil, ::T.untyped)
  OPTS = ::T.let(nil, ::T.untyped)
  RESTRICTED_SETTER_METHODS = ::T.let(nil, ::T.untyped)
  SETTER_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
end

module Sequel::Model::Associations
  ASSOCIATION_TYPES = ::T.let(nil, ::T.untyped)
end

class Sequel::Model::Associations::AssociationReflection
  ASSOCIATION_DATASET_PROC = ::T.let(nil, ::T.untyped)
  FINALIZE_SETTINGS = ::T.let(nil, ::T.untyped)
end

class Sequel::Model::Associations::ManyToManyAssociationReflection
  FINALIZE_SETTINGS = ::T.let(nil, ::T.untyped)
end

class Sequel::Model::Associations::ManyToOneAssociationReflection
  FINALIZE_SETTINGS = ::T.let(nil, ::T.untyped)
end

class Sequel::Model::Associations::OneToManyAssociationReflection
  FINALIZE_SETTINGS = ::T.let(nil, ::T.untyped)
end

module Sequel::Model::ClassMethods
  FINDER_TYPES = ::T.let(nil, ::T.untyped)
end

class Sequel::Model::Errors
  ATTRIBUTE_JOINER = ::T.let(nil, ::T.untyped)
end

module Sequel::Postgres
  CAST_JSON = ::T.let(nil, ::T.untyped)
  CAST_JSONB = ::T.let(nil, ::T.untyped)
  CONVERTED_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  DASH_STR = ::T.let(nil, ::T.untyped)
  MINUS_INFINITY = ::T.let(nil, ::T.untyped)
  MINUS_INFINITY_STR = ::T.let(nil, ::T.untyped)
  NAN_STR = ::T.let(nil, ::T.untyped)
  PG_NAMED_TYPES = ::T.let(nil, ::T.untyped)
  PG_NAMED__TYPES = ::T.let(nil, ::T.untyped)
  PG_TYPES = ::T.let(nil, ::T.untyped)
  PG__TYPES = ::T.let(nil, ::T.untyped)
  PLUS_INFINITY = ::T.let(nil, ::T.untyped)
  PLUS_INFINITY_STR = ::T.let(nil, ::T.untyped)
  SEQUEL_PG_VERSION_INTEGER = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
  TRUE_STR = ::T.let(nil, ::T.untyped)
  TYPE_CONVERTOR = ::T.let(nil, ::T.untyped)
  TYPE_TRANSLATOR = ::T.let(nil, ::T.untyped)
  USES_PG = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::Adapter
  DISCONNECT_ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  DISCONNECT_ERROR_RE = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::ArrayOp
  CONCAT = ::T.let(nil, ::T.untyped)
  CONTAINED_BY = ::T.let(nil, ::T.untyped)
  CONTAINS = ::T.let(nil, ::T.untyped)
  OVERLAPS = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::Database
  DATABASE_ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  INFINITE_DATETIME_VALUES = ::T.let(nil, ::T.untyped)
  INFINITE_TIMESTAMP_STRINGS = ::T.let(nil, ::T.untyped)
end

Sequel::Postgres::Database::DatasetClass = Sequel::Postgres::Dataset

module Sequel::Postgres::DatabaseMethods
  DATABASE_ERROR_REGEXPS = ::T.let(nil, ::T.untyped)
  DEADLOCK_SQL_STATE = ::T.let(nil, ::T.untyped)
  EXCLUSION_CONSTRAINT_SQL_STATE = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_LIST_ON_DELETE_MAP = ::T.let(nil, ::T.untyped)
  ON_COMMIT = ::T.let(nil, ::T.untyped)
  POSTGRES_DEFAULT_RE = ::T.let(nil, ::T.untyped)
  PREPARED_ARG_PLACEHOLDER = ::T.let(nil, ::T.untyped)
  RE_CURRVAL_ERROR = ::T.let(nil, ::T.untyped)
  SELECT_CUSTOM_SEQUENCE_SQL = ::T.let(nil, ::T.untyped)
  SELECT_PK_SQL = ::T.let(nil, ::T.untyped)
  SELECT_SERIAL_SEQUENCE_SQL = ::T.let(nil, ::T.untyped)
  UNLOGGED = ::T.let(nil, ::T.untyped)
  VALID_CLIENT_MIN_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::Dataset
  APOS = ::T.let(nil, ::T.untyped)
  DEFAULT_CURSOR_NAME = ::T.let(nil, ::T.untyped)
  PREPARED_ARG_PLACEHOLDER = ::T.let(nil, ::T.untyped)
end

module Sequel::Postgres::DatasetMethods
  ACCESS_EXCLUSIVE = ::T.let(nil, ::T.untyped)
  ACCESS_SHARE = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  APOS_RE = ::T.let(nil, ::T.untyped)
  AS = ::T.let(nil, ::T.untyped)
  BACKSLASH = ::T.let(nil, ::T.untyped)
  BLOB_RE = ::T.let(nil, ::T.untyped)
  BOOL_FALSE = ::T.let(nil, ::T.untyped)
  BOOL_TRUE = ::T.let(nil, ::T.untyped)
  COMMA = ::T.let(nil, ::T.untyped)
  COMMA_SEPARATOR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  DOUBLE_APOS = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXCLUSIVE = ::T.let(nil, ::T.untyped)
  EXPLAIN = ::T.let(nil, ::T.untyped)
  EXPLAIN_ANALYZE = ::T.let(nil, ::T.untyped)
  FOR_SHARE = ::T.let(nil, ::T.untyped)
  FROM = ::T.let(nil, ::T.untyped)
  LOCK_MODES = ::T.let(nil, ::T.untyped)
  NON_SQL_OPTIONS = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  PAREN_CLOSE = ::T.let(nil, ::T.untyped)
  PAREN_OPEN = ::T.let(nil, ::T.untyped)
  PG_TIMESTAMP_FORMAT = ::T.let(nil, ::T.untyped)
  QUERY_PLAN = ::T.let(nil, ::T.untyped)
  ROW_EXCLUSIVE = ::T.let(nil, ::T.untyped)
  ROW_SHARE = ::T.let(nil, ::T.untyped)
  SELECT_VALUES = ::T.let(nil, ::T.untyped)
  SHARE = ::T.let(nil, ::T.untyped)
  SHARE_ROW_EXCLUSIVE = ::T.let(nil, ::T.untyped)
  SHARE_UPDATE_EXCLUSIVE = ::T.let(nil, ::T.untyped)
  SKIP_LOCKED = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  SQL_WITH_RECURSIVE = ::T.let(nil, ::T.untyped)
  WINDOW = ::T.let(nil, ::T.untyped)
  XOR_OP = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::HStore
  COMMA = ::T.let(nil, ::T.untyped)
  DEFAULT_PROC = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_REPLACE = ::T.let(nil, ::T.untyped)
  HSTORE_CAST = ::T.let(nil, ::T.untyped)
  KV_SEP = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::HStore::Parser
  KV_SEP_RE = ::T.let(nil, ::T.untyped)
  NULL_RE = ::T.let(nil, ::T.untyped)
  QUOTED_RE = ::T.let(nil, ::T.untyped)
  QUOTE_RE = ::T.let(nil, ::T.untyped)
  REPLACE_RE = ::T.let(nil, ::T.untyped)
  REPLACE_WITH = ::T.let(nil, ::T.untyped)
  SEP_RE = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::JSONArray
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::JSONArrayBase
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::JSONBArray
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::JSONBHash
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::JSONBOp
  CONCAT = ::T.let(nil, ::T.untyped)
  CONTAINED_BY = ::T.let(nil, ::T.untyped)
  CONTAINS = ::T.let(nil, ::T.untyped)
  CONTAIN_ALL = ::T.let(nil, ::T.untyped)
  CONTAIN_ANY = ::T.let(nil, ::T.untyped)
  DELETE_PATH = ::T.let(nil, ::T.untyped)
  HAS_KEY = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::JSONBaseOp
  GET = ::T.let(nil, ::T.untyped)
  GET_PATH = ::T.let(nil, ::T.untyped)
  GET_PATH_TEXT = ::T.let(nil, ::T.untyped)
  GET_TEXT = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::JSONHash
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::JSONHashBase
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sequel::Postgres::PGArray
  ARRAY = ::T.let(nil, ::T.untyped)
  ARRAY_TYPES = ::T.let(nil, ::T.untyped)
  BACKSLASH = ::T.let(nil, ::T.untyped)
  CLOSE_BRACE = ::T.let(nil, ::T.untyped)
  CLOSE_BRACKET = ::T.let(nil, ::T.untyped)
  COMMA = ::T.let(nil, ::T.untyped)
  DOUBLE_COLON = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_BRACKET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  OPEN_BRACE = ::T.let(nil, ::T.untyped)
  OPEN_BRACKET = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Sequel::Postgres::PGArray::DatabaseMethods
  APOS = ::T.let(nil, ::T.untyped)
  BLOB_RANGE = ::T.let(nil, ::T.untyped)
  DOUBLE_APOS = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_REPLACEMENT = ::T.let(nil, ::T.untyped)
end

Sequel::Postgres::PGError = PG::Error

Sequel::Postgres::PGconn = PG::Connection

Sequel::Postgres::PGresult = PG::Result

class Sequel::SQL::ComplexExpression
  ASSOCIATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  BITWISE_OPERATORS = ::T.let(nil, ::T.untyped)
  BOOLEAN_OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
  CONSTANT_INVERSIONS = ::T.let(nil, ::T.untyped)
  CUSTOM_EXPRESSIONS = ::T.let(nil, ::T.untyped)
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  INEQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  IN_OPERATORS = ::T.let(nil, ::T.untyped)
  IS_OPERATORS = ::T.let(nil, ::T.untyped)
  LIKE_OPERATORS = ::T.let(nil, ::T.untyped)
  MATHEMATICAL_OPERATORS = ::T.let(nil, ::T.untyped)
  N_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
  ONE_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
  OPERTATOR_INVERSIONS = ::T.let(nil, ::T.untyped)
  REGEXP_OPERATORS = ::T.let(nil, ::T.untyped)
  TWO_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
end

module Sequel::SQL::Constants
  CURRENT_DATE = ::T.let(nil, ::T.untyped)
  CURRENT_TIME = ::T.let(nil, ::T.untyped)
  CURRENT_TIMESTAMP = ::T.let(nil, ::T.untyped)
  FALSE = ::T.let(nil, ::T.untyped)
  NOTNULL = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  SQLFALSE = ::T.let(nil, ::T.untyped)
  SQLTRUE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class Sequel::SQL::Function
  COMMA_ARRAY = ::T.let(nil, ::T.untyped)
  DISTINCT = ::T.let(nil, ::T.untyped)
  WILDCARD = ::T.let(nil, ::T.untyped)
end

class Sequel::SQL::OrderedExpression
  INVERT_NULLS = ::T.let(nil, ::T.untyped)
end

class Sequel::SQL::StringExpression
  LIKE_MAP = ::T.let(nil, ::T.untyped)
end

class Sequel::SQL::VirtualRow
  DOUBLE_UNDERSCORE = ::T.let(nil, ::T.untyped)
  QUESTION_MARK = ::T.let(nil, ::T.untyped)
end

class Sequel::Schema::CreateTableGenerator
  GENERIC_TYPES = ::T.let(nil, ::T.untyped)
end

Sequel::Schema::Generator = Sequel::Schema::CreateTableGenerator

class Sequel::ThreadedConnectionPool
  USE_WAITER = ::T.let(nil, ::T.untyped)
end

class Sequel::TimestampMigrator
  DEFAULT_SCHEMA_COLUMN = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEMA_TABLE = ::T.let(nil, ::T.untyped)
end

Sequel::TimestampMigrator::Error = Sequel::Migrator::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class Shotgun::Loader
  include ::Rack::Utils
  def assemble_app(); end

  def call(env); end

  def call!(env); end

  def camel_case(string); end

  def format_error(error, backtrace); end

  def initialize(rackup_file, &block); end

  def inner_app(); end

  def proceed_as_child(); end

  def proceed_as_parent(); end

  def rackup_file(); end

  def spec_body(body); end
end

class Shotgun::Loader::Body
  def close(); end
end

class Shotgun::Loader::Body
end

class Shotgun::Loader
end

class Shotgun::SkipFavicon
  def call(env); end
end

class Shotgun::SkipFavicon
end

class Shotgun::Static
  def call(env); end

  def initialize(app, public_dir=T.unsafe(nil)); end
end

class Shotgun::Static
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Slop
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Slop::Option
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Solargraph
  VERSION = ::T.let(nil, ::T.untyped)
  VIEWS_PATH = ::T.let(nil, ::T.untyped)
  YARDOC_PATH = ::T.let(nil, ::T.untyped)
  YARD_EXTENSION_FILE = ::T.let(nil, ::T.untyped)
end

class Solargraph::ApiMap
  include ::Solargraph::ApiMap::SourceToYard
  include ::Solargraph::ApiMap::BundlerMethods
  def bundled?(filename); end

  def catalog(bench); end

  def clip(cursor); end

  def clip_at(filename, position); end

  def cursor_at(filename, position); end

  def document(path); end

  def document_symbols(filename); end

  def get_class_variable_pins(namespace); end

  def get_complex_type_methods(type, context=T.unsafe(nil), internal=T.unsafe(nil)); end

  def get_constants(namespace, *contexts); end

  def get_global_variable_pins(); end

  def get_instance_variable_pins(namespace, scope=T.unsafe(nil)); end

  def get_method_stack(fqns, name, scope: T.unsafe(nil)); end

  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil), deep: T.unsafe(nil)); end

  def get_path_pins(path); end

  def get_path_suggestions(path); end

  def get_symbols(); end

  def implicit(); end

  def index(pins); end

  def initialize(pins: T.unsafe(nil)); end

  def keyword_pins(); end

  def local_path_hash(); end

  def locate_pins(location); end

  def map(source); end

  def named_macro(name); end

  def namespace_exists?(name, context=T.unsafe(nil)); end

  def namespaces(); end

  def pins(); end

  def qualify(namespace, context=T.unsafe(nil)); end

  def query_symbols(query); end

  def rebindable_method_names(); end

  def require_reference_at(location); end

  def required(); end

  def search(query); end

  def source_map(filename); end

  def source_maps(); end

  def super_and_sub?(sup, sub); end

  def type_include?(host, mod); end

  def unresolved_requires(); end

  def workspaced?(filename); end

  def yard_map(); end
end

module Solargraph::ApiMap::BundlerMethods
end

module Solargraph::ApiMap::BundlerMethods
  def self.require_from_bundle(directory); end

  def self.reset_require_from_bundle(); end
end

class Solargraph::ApiMap::Cache
  def clear(); end

  def empty?(); end

  def get_constants(namespace, context); end

  def get_methods(fqns, scope, visibility, deep); end

  def get_qualified_namespace(name, context); end

  def get_receiver_definition(path); end

  def receiver_defined?(path); end

  def set_constants(namespace, context, value); end

  def set_methods(fqns, scope, visibility, deep, value); end

  def set_qualified_namespace(name, context, value); end

  def set_receiver_definition(path, pin); end
end

class Solargraph::ApiMap::Cache
end

module Solargraph::ApiMap::SourceToYard
  def code_object_at(path); end

  def code_object_paths(); end

  def rake_yard(store); end
end

module Solargraph::ApiMap::SourceToYard
end

class Solargraph::ApiMap::Store
  def block_pins(); end

  def domains(fqns); end

  def get_class_variables(fqns); end

  def get_constants(fqns, visibility=T.unsafe(nil)); end

  def get_extends(fqns); end

  def get_includes(fqns); end

  def get_instance_variables(fqns, scope=T.unsafe(nil)); end

  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def get_path_pins(path); end

  def get_prepends(fqns); end

  def get_superclass(fqns); end

  def get_symbols(); end

  def initialize(pins=T.unsafe(nil)); end

  def method_pins(); end

  def named_macros(); end

  def namespace_exists?(fqns); end

  def namespace_pins(); end

  def namespaces(); end

  def pins(); end

  def pins_by_class(klass); end
end

class Solargraph::ApiMap::Store
end

class Solargraph::ApiMap
  def self.load(directory); end
end

class Solargraph::Bench
  def directory(); end

  def gemnames(); end

  def initialize(source_maps: T.unsafe(nil), load_paths: T.unsafe(nil), gemnames: T.unsafe(nil), directory: T.unsafe(nil)); end

  def load_paths(); end

  def source_maps(); end
end

class Solargraph::Bench
end

class Solargraph::ComplexType
  def [](index); end

  def all?(&block); end

  def each(&block); end

  def first(); end

  def initialize(types=T.unsafe(nil)); end

  def length(); end

  def map(&block); end

  def method_missing(name, *args, &block); end

  def qualify(api_map, context=T.unsafe(nil)); end

  def select(&block); end

  def self_to(dst); end

  def selfy?(); end
  BOOLEAN = ::T.let(nil, ::T.untyped)
  NIL = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  SELF = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module Solargraph::ComplexType::TypeMethods
  def ==(other); end

  def defined?(); end

  def duck_type?(); end

  def fixed_parameters?(); end

  def hash_parameters?(); end

  def key_types(); end

  def list_parameters?(); end

  def name(); end

  def namespace(); end

  def nil_type?(); end

  def parameters?(); end

  def qualify(api_map, context=T.unsafe(nil)); end

  def rooted?(); end

  def scope(); end

  def substring(); end

  def subtypes(); end

  def tag(); end

  def undefined?(); end

  def value_types(); end

  def void?(); end
end

module Solargraph::ComplexType::TypeMethods
end

class Solargraph::ComplexType::UniqueType
  include ::Solargraph::ComplexType::TypeMethods
  def initialize(name, substring=T.unsafe(nil)); end

  def self_to(dst); end

  def selfy?(); end
  BOOLEAN = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Solargraph::ComplexType::UniqueType
end

class Solargraph::ComplexType
  def self.parse(*strings, partial: T.unsafe(nil)); end

  def self.try_parse(*strings); end
end

module Solargraph::Convention
end

class Solargraph::Convention::Base
  def global(yard_map); end

  def local(source_map); end
  EMPTY_ENVIRON = ::T.let(nil, ::T.untyped)
end

class Solargraph::Convention::Base
end

class Solargraph::Convention::Gemfile
end

class Solargraph::Convention::Gemfile
end

class Solargraph::Convention::Gemspec
end

class Solargraph::Convention::Gemspec
end

class Solargraph::Convention::Rspec
end

class Solargraph::Convention::Rspec
end

module Solargraph::Convention
  def self.for_global(yard_map); end

  def self.for_local(source_map); end

  def self.register(convention); end
end

module Solargraph::Diagnostics
end

class Solargraph::Diagnostics::Base
  def args(); end

  def diagnose(source, api_map); end

  def initialize(*args); end
end

class Solargraph::Diagnostics::Base
end

class Solargraph::Diagnostics::RequireNotFound
end

class Solargraph::Diagnostics::RequireNotFound
end

class Solargraph::Diagnostics::Rubocop
  include ::Solargraph::Diagnostics::RubocopHelpers
  def diagnose(source, _api_map); end
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Diagnostics::Rubocop
end

module Solargraph::Diagnostics::RubocopHelpers
end

module Solargraph::Diagnostics::RubocopHelpers
  def self.fix_drive_letter(path); end

  def self.generate_options(filename, code); end

  def self.redirect_stdout(); end

  def self.require_rubocop(version=T.unsafe(nil)); end
end

module Solargraph::Diagnostics::Severities
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module Solargraph::Diagnostics::Severities
end

class Solargraph::Diagnostics::TypeCheck
end

class Solargraph::Diagnostics::TypeCheck
end

class Solargraph::Diagnostics::UpdateErrors
end

class Solargraph::Diagnostics::UpdateErrors
end

module Solargraph::Diagnostics
  def self.register(name, klass); end

  def self.reporter(name); end

  def self.reporters(); end
end

class Solargraph::Documentor
  def document(); end

  def initialize(directory, rebuild: T.unsafe(nil), out: T.unsafe(nil)); end
  RDOC_GEMS = ::T.let(nil, ::T.untyped)
end

class Solargraph::Documentor
  def self.specs_from_bundle(directory); end
end

class Solargraph::Environ
  def clear(); end

  def domains(); end

  def initialize(requires: T.unsafe(nil), domains: T.unsafe(nil), pins: T.unsafe(nil)); end

  def merge(other); end

  def pins(); end

  def requires(); end
end

class Solargraph::Environ
end

module Solargraph::LanguageServer
end

module Solargraph::LanguageServer::CompletionItemKinds
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::CompletionItemKinds
end

module Solargraph::LanguageServer::ErrorCodes
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_PARAMS = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  PARSE_ERROR = ::T.let(nil, ::T.untyped)
  REQUEST_CANCELLED = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_END = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_START = ::T.let(nil, ::T.untyped)
  SERVER_NOT_INITIALIZED = ::T.let(nil, ::T.untyped)
  UNKNOWN_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::ErrorCodes
end

class Solargraph::LanguageServer::Host
  include ::Solargraph::LanguageServer::UriHelpers
  include ::Solargraph::Logging
  include ::Solargraph::LanguageServer::Host::Dispatch
  include ::Observable
  def allow_registration(method); end

  def can_register?(method); end

  def cancel(id); end

  def cancel?(id); end

  def catalog(); end

  def change(params); end

  def clear(id); end

  def client_capabilities(); end

  def client_capabilities=(client_capabilities); end

  def close(uri); end

  def completions_at(uri, line, column); end

  def configure(update); end

  def create(uri); end

  def default_configuration(); end

  def definitions_at(uri, line, column); end

  def delete(uri); end

  def diagnose(uri); end

  def document(query); end

  def document_symbols(uri); end

  def flush(); end

  def folders(); end

  def folding_ranges(uri); end

  def formatter_config(uri); end

  def locate_pins(params); end

  def open(uri, text, version); end

  def open?(uri); end

  def open_from_disk(uri); end

  def options(); end

  def pending_requests(); end

  def prepare(directory, name=T.unsafe(nil)); end

  def prepare_folders(array); end

  def query_symbols(query); end

  def queue(message); end

  def read_text(uri); end

  def receive(request); end

  def references_from(uri, line, column, strip: T.unsafe(nil)); end

  def register_capabilities(methods); end

  def registered?(method); end

  def remove(directory); end

  def remove_folders(array); end

  def search(query); end

  def send_notification(method, params); end

  def send_request(method, params, &block); end

  def show_message(text, type=T.unsafe(nil)); end

  def show_message_request(text, type, actions, &block); end

  def signatures_at(uri, line, column); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def synchronizing?(); end

  def unregister_capabilities(methods); end
end

class Solargraph::LanguageServer::Host::Cataloger
  def initialize(host); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Solargraph::LanguageServer::Host::Cataloger
end

class Solargraph::LanguageServer::Host::Diagnoser
  def initialize(host); end

  def schedule(uri); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Solargraph::LanguageServer::Host::Diagnoser
end

module Solargraph::LanguageServer::Host::Dispatch
  def explicit_library_for(uri); end

  def generic_library(); end

  def generic_library_for(uri); end

  def implicit_library_for(uri); end

  def libraries(); end

  def library_for(uri); end

  def sources(); end

  def update_libraries(uri); end
end

module Solargraph::LanguageServer::Host::Dispatch
end

class Solargraph::LanguageServer::Host::Sources
  include ::Observable
  include ::Solargraph::LanguageServer::UriHelpers
  def add_uri(uri); end

  def async_update(uri, updater); end

  def clear(); end

  def close(uri); end

  def find(uri); end

  def include?(uri); end

  def next_uri(); end

  def open(uri, text, version); end

  def open_from_disk(uri); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end

  def update(uri, updater); end
end

class Solargraph::LanguageServer::Host::Sources
end

class Solargraph::LanguageServer::Host
end

module Solargraph::LanguageServer::Message
end

class Solargraph::LanguageServer::Message::Base
  def error(); end

  def host(); end

  def id(); end

  def initialize(host, request); end

  def method(); end

  def params(); end

  def post_initialize(); end

  def process(); end

  def request(); end

  def result(); end

  def send_response(); end

  def set_error(code, message); end

  def set_result(data); end
end

class Solargraph::LanguageServer::Message::Base
end

class Solargraph::LanguageServer::Message::CancelRequest
end

class Solargraph::LanguageServer::Message::CancelRequest
end

module Solargraph::LanguageServer::Message::CompletionItem
end

class Solargraph::LanguageServer::Message::CompletionItem::Resolve
end

class Solargraph::LanguageServer::Message::CompletionItem::Resolve
end

module Solargraph::LanguageServer::Message::CompletionItem
end

class Solargraph::LanguageServer::Message::ExitNotification
end

class Solargraph::LanguageServer::Message::ExitNotification
end

module Solargraph::LanguageServer::Message::Extended
end

class Solargraph::LanguageServer::Message::Extended::CheckGemVersion
  def initialize(host, request, current: T.unsafe(nil), available: T.unsafe(nil)); end
  GEM_ZERO = ::T.let(nil, ::T.untyped)
end

class Solargraph::LanguageServer::Message::Extended::CheckGemVersion
  def self.fetcher(); end

  def self.fetcher=(obj); end
end

class Solargraph::LanguageServer::Message::Extended::Document
end

class Solargraph::LanguageServer::Message::Extended::Document
end

class Solargraph::LanguageServer::Message::Extended::DocumentGems
end

class Solargraph::LanguageServer::Message::Extended::DocumentGems
end

class Solargraph::LanguageServer::Message::Extended::DownloadCore
end

class Solargraph::LanguageServer::Message::Extended::DownloadCore
end

class Solargraph::LanguageServer::Message::Extended::Environment
end

class Solargraph::LanguageServer::Message::Extended::Environment
end

class Solargraph::LanguageServer::Message::Extended::Search
end

class Solargraph::LanguageServer::Message::Extended::Search
end

module Solargraph::LanguageServer::Message::Extended
end

class Solargraph::LanguageServer::Message::Initialize
end

class Solargraph::LanguageServer::Message::Initialize
end

class Solargraph::LanguageServer::Message::Initialized
end

class Solargraph::LanguageServer::Message::Initialized
end

class Solargraph::LanguageServer::Message::MethodNotFound
end

class Solargraph::LanguageServer::Message::MethodNotFound
end

class Solargraph::LanguageServer::Message::MethodNotImplemented
end

class Solargraph::LanguageServer::Message::MethodNotImplemented
end

class Solargraph::LanguageServer::Message::Shutdown
end

class Solargraph::LanguageServer::Message::Shutdown
end

module Solargraph::LanguageServer::Message::TextDocument
end

class Solargraph::LanguageServer::Message::TextDocument::Base
  include ::Solargraph::LanguageServer::UriHelpers
  def filename(); end
end

class Solargraph::LanguageServer::Message::TextDocument::Base
end

class Solargraph::LanguageServer::Message::TextDocument::CodeAction
end

class Solargraph::LanguageServer::Message::TextDocument::CodeAction
end

class Solargraph::LanguageServer::Message::TextDocument::Completion
  def empty_result(incomplete=T.unsafe(nil)); end
end

class Solargraph::LanguageServer::Message::TextDocument::Completion
end

class Solargraph::LanguageServer::Message::TextDocument::Definition
end

class Solargraph::LanguageServer::Message::TextDocument::Definition
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol
  include ::Solargraph::LanguageServer::UriHelpers
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting
  include ::Solargraph::Diagnostics::RubocopHelpers
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting
end

class Solargraph::LanguageServer::Message::TextDocument::Hover
end

class Solargraph::LanguageServer::Message::TextDocument::Hover
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename
end

class Solargraph::LanguageServer::Message::TextDocument::References
end

class Solargraph::LanguageServer::Message::TextDocument::References
end

class Solargraph::LanguageServer::Message::TextDocument::Rename
end

class Solargraph::LanguageServer::Message::TextDocument::Rename
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp
end

module Solargraph::LanguageServer::Message::TextDocument
end

module Solargraph::LanguageServer::Message::Workspace
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles
  include ::Solargraph::LanguageServer::UriHelpers
  CHANGED = ::T.let(nil, ::T.untyped)
  CREATED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol
  include ::Solargraph::LanguageServer::UriHelpers
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol
end

module Solargraph::LanguageServer::Message::Workspace
end

module Solargraph::LanguageServer::Message
  def self.register(path, message_class); end

  def self.select(path); end
end

module Solargraph::LanguageServer::MessageTypes
  ERROR = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::MessageTypes
end

class Solargraph::LanguageServer::Request
  def initialize(id, &block); end

  def process(result); end

  def send_response(); end
end

class Solargraph::LanguageServer::Request
end

module Solargraph::LanguageServer::SymbolKinds
  ARRAY = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PACKAGE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::SymbolKinds
end

module Solargraph::LanguageServer::Transport
end

module Solargraph::LanguageServer::Transport::Adapter
  def closing(); end

  def opening(); end

  def receiving(data); end

  def update(); end
end

module Solargraph::LanguageServer::Transport::Adapter
end

class Solargraph::LanguageServer::Transport::DataReader
  def receive(data); end

  def set_message_handler(&block); end
end

class Solargraph::LanguageServer::Transport::DataReader
end

module Solargraph::LanguageServer::Transport
end

module Solargraph::LanguageServer::UriHelpers
end

module Solargraph::LanguageServer::UriHelpers
  def self.decode(text); end

  def self.encode(text); end

  def self.file_to_uri(file); end

  def self.uri_to_file(uri); end
end

module Solargraph::LanguageServer
end

class Solargraph::Library
  include ::Solargraph::Logging
  def attach(source); end

  def attached?(filename); end

  def bench(); end

  def catalog(); end

  def close(filename); end

  def completions_at(filename, line, column); end

  def contain?(filename); end

  def create(filename, text); end

  def create_from_disk(filename); end

  def current(); end

  def definitions_at(filename, line, column); end

  def delete(filename); end

  def detach(filename); end

  def diagnose(filename); end

  def document(query); end

  def document_symbols(filename); end

  def folding_ranges(filename); end

  def get_path_pins(path); end

  def initialize(workspace=T.unsafe(nil), name=T.unsafe(nil)); end

  def locate_pins(location); end

  def locate_ref(location); end

  def map!(); end

  def mapped?(); end

  def merge(source); end

  def name(); end

  def next_map(); end

  def open?(filename); end

  def path_pins(path); end

  def pins(); end

  def query_symbols(query); end

  def read_text(filename); end

  def references_from(filename, line, column, strip: T.unsafe(nil)); end

  def search(query); end

  def signatures_at(filename, line, column); end

  def source_map_hash(); end

  def source_maps(); end

  def synchronized?(); end

  def workspace(); end
end

class Solargraph::Library
  def self.load(directory=T.unsafe(nil), name=T.unsafe(nil)); end
end

class Solargraph::Location
  def ==(other); end

  def filename(); end

  def initialize(filename, range); end

  def range(); end

  def to_hash(); end
end

class Solargraph::Location
end

module Solargraph::Logging
  DEFAULT_LOG_LEVEL = ::T.let(nil, ::T.untyped)
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
end

module Solargraph::Logging
  def self.logger(); end
end

class Solargraph::Page
  def initialize(directory=T.unsafe(nil)); end

  def render(template, layout: T.unsafe(nil), locals: T.unsafe(nil)); end
end

class Solargraph::Page
  def self.select_template(directories, name); end
end

module Solargraph::Parser
end

class Solargraph::Parser::CommentRipper
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def on_comment(*args); end

  def on_embdoc(*args); end

  def on_embdoc_beg(*args); end

  def on_embdoc_end(*args); end
end

class Solargraph::Parser::CommentRipper
end

module Solargraph::Parser::Legacy
end

module Solargraph::Parser::Legacy::ClassMethods
  def chain(*args); end

  def chain_string(*args); end

  def infer_literal_node_type(node); end

  def inner_node_references(name, top); end

  def is_ast_node?(node); end

  def map(source); end

  def node_range(node); end

  def parse(code, filename=T.unsafe(nil), line=T.unsafe(nil)); end

  def parse_with_comments(code, filename=T.unsafe(nil)); end

  def parser(); end

  def process_node(*args); end

  def references(source, name); end

  def returns_from(node); end

  def version(); end
end

module Solargraph::Parser::Legacy::ClassMethods
end

class Solargraph::Parser::Legacy::FlawedBuilder
end

class Solargraph::Parser::Legacy::FlawedBuilder
end

class Solargraph::Parser::Legacy::NodeChainer
  include ::Solargraph::Parser::Legacy::NodeMethods
  def chain(); end

  def initialize(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end
end

Solargraph::Parser::Legacy::NodeChainer::Chain = Solargraph::Source::Chain

class Solargraph::Parser::Legacy::NodeChainer
  def self.chain(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end

  def self.load_string(code); end
end

module Solargraph::Parser::Legacy::NodeMethods
  NIL_NODE = ::T.let(nil, ::T.untyped)
end

module Solargraph::Parser::Legacy::NodeMethods::DeepInference
end

module Solargraph::Parser::Legacy::NodeMethods::DeepInference
  def self.get_return_nodes(node); end
end

module Solargraph::Parser::Legacy::NodeMethods
  def self.call_nodes_from(node); end

  def self.const_nodes_from(node); end

  def self.convert_hash(node); end

  def self.drill_signature(node, signature); end

  def self.find_recipient_node(cursor); end

  def self.get_node_end_position(node); end

  def self.get_node_start_position(node); end

  def self.infer_literal_node_type(node); end

  def self.pack_name(node); end

  def self.returns_from(node); end

  def self.splatted_call?(node); end

  def self.splatted_hash?(node); end

  def self.unpack_name(node); end
end

module Solargraph::Parser::Legacy::NodeProcessors
end

class Solargraph::Parser::Legacy::NodeProcessors::AliasNode
end

class Solargraph::Parser::Legacy::NodeProcessors::AliasNode
end

class Solargraph::Parser::Legacy::NodeProcessors::ArgsNode
end

class Solargraph::Parser::Legacy::NodeProcessors::ArgsNode
end

class Solargraph::Parser::Legacy::NodeProcessors::BeginNode
end

class Solargraph::Parser::Legacy::NodeProcessors::BeginNode
end

class Solargraph::Parser::Legacy::NodeProcessors::BlockNode
end

class Solargraph::Parser::Legacy::NodeProcessors::BlockNode
end

class Solargraph::Parser::Legacy::NodeProcessors::CasgnNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::CasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::CvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::CvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::DefNode
end

class Solargraph::Parser::Legacy::NodeProcessors::DefNode
end

class Solargraph::Parser::Legacy::NodeProcessors::DefsNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::DefsNode
end

class Solargraph::Parser::Legacy::NodeProcessors::GvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::GvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::IvasgnNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::IvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::LvasgnNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::LvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::NamespaceNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::NamespaceNode
end

class Solargraph::Parser::Legacy::NodeProcessors::OrasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::OrasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::ResbodyNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::ResbodyNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SclassNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SclassNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SendNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::SendNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SymNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SymNode
end

module Solargraph::Parser::Legacy::NodeProcessors
end

module Solargraph::Parser::Legacy
end

Solargraph::Parser::NodeMethods = Solargraph::Parser::Rubyvm::NodeMethods

module Solargraph::Parser::NodeProcessor
end

class Solargraph::Parser::NodeProcessor::Base
  def initialize(node, region, pins, locals); end

  def locals(); end

  def node(); end

  def pins(); end

  def process(); end

  def region(); end
end

class Solargraph::Parser::NodeProcessor::Base
end

module Solargraph::Parser::NodeProcessor
  def self.process(node, region=T.unsafe(nil), pins=T.unsafe(nil), locals=T.unsafe(nil)); end

  def self.register(type, cls); end
end

class Solargraph::Parser::Region
  def closure(); end

  def code_for(node); end

  def filename(); end

  def initialize(source: T.unsafe(nil), closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil), lvars: T.unsafe(nil)); end

  def lvars(); end

  def scope(); end

  def source(); end

  def update(closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil), lvars: T.unsafe(nil)); end

  def visibility(); end
end

class Solargraph::Parser::Region
end

module Solargraph::Parser::Rubyvm
end

module Solargraph::Parser::Rubyvm::ClassMethods
  def chain(*args); end

  def chain_string(*args); end

  def infer_literal_node_type(node); end

  def inner_node_references(name, top); end

  def is_ast_node?(node); end

  def map(source); end

  def match_rubyvm_node_to_ref(top, name); end

  def node_range(node); end

  def parse(code, filename=T.unsafe(nil), line=T.unsafe(nil)); end

  def parse_with_comments(code, filename=T.unsafe(nil)); end

  def process_node(*args); end

  def recipient_node(tree); end

  def references(source, name); end

  def string_ranges(node); end

  def version(); end
end

module Solargraph::Parser::Rubyvm::ClassMethods
end

class Solargraph::Parser::Rubyvm::NodeChainer
  include ::Solargraph::Parser::Rubyvm::NodeMethods
  def chain(); end

  def initialize(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end
end

Solargraph::Parser::Rubyvm::NodeChainer::Chain = Solargraph::Source::Chain

class Solargraph::Parser::Rubyvm::NodeChainer
  def self.chain(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end

  def self.load_string(code); end
end

module Solargraph::Parser::Rubyvm::NodeMethods
end

module Solargraph::Parser::Rubyvm::NodeMethods::DeepInference
end

module Solargraph::Parser::Rubyvm::NodeMethods::DeepInference
  def self.get_return_nodes(node); end
end

module Solargraph::Parser::Rubyvm::NodeMethods
  def self.call_nodes_from(node); end

  def self.const_nodes_from(node); end

  def self.convert_hash(node); end

  def self.find_recipient_node(cursor); end

  def self.infer_literal_node_type(node); end

  def self.node?(node); end

  def self.pack_name(node); end

  def self.returns_from(node); end

  def self.splatted_call?(node); end

  def self.splatted_hash?(node); end

  def self.splatted_node?(node); end

  def self.synchronized_find_recipient_node(cursor); end

  def self.unpack_name(node); end

  def self.unsynchronized_find_recipient_node(cursor); end
end

module Solargraph::Parser::Rubyvm::NodeProcessors
end

class Solargraph::Parser::Rubyvm::NodeProcessors::AliasNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::AliasNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ArgsNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ArgsNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BeginNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BeginNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BlockNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BlockNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefsNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefsNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::GvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::GvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::IvasgnNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::IvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::KwArgNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::KwArgNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LitNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LitNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::NamespaceNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::NamespaceNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OptArgNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OptArgNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OrasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OrasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ResbodyNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ResbodyNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SclassNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SclassNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ScopeNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ScopeNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SendNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SendNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SymNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SymNode
end

module Solargraph::Parser::Rubyvm::NodeProcessors
end

module Solargraph::Parser::Rubyvm
end

class Solargraph::Parser::Snippet
  def initialize(range, text); end

  def range(); end

  def text(); end
end

class Solargraph::Parser::Snippet
end

class Solargraph::Parser::SyntaxError
end

class Solargraph::Parser::SyntaxError
end

module Solargraph::Parser
  extend ::Solargraph::Parser::Rubyvm::ClassMethods
  def self.rubyvm?(); end
end

module Solargraph::Pin
  ROOT_PIN = ::T.let(nil, ::T.untyped)
end

class Solargraph::Pin::Base
  include ::Solargraph::Pin::Common
  include ::Solargraph::Pin::Conversions
  include ::Solargraph::Pin::Documenting
  def ==(other); end

  def code_object(); end

  def completion_item_kind(); end

  def deprecated?(); end

  def directives(); end

  def docstring(); end

  def filename(); end

  def identity(); end

  def infer(api_map); end

  def initialize(location: T.unsafe(nil), closure: T.unsafe(nil), name: T.unsafe(nil), comments: T.unsafe(nil)); end

  def macros(); end

  def maybe_directives?(); end

  def nearly?(other); end

  def probe(api_map); end

  def probed=(probed); end

  def probed?(); end

  def proxied=(proxied); end

  def proxied?(); end

  def proxy(return_type); end

  def realize(api_map); end

  def return_type=(return_type); end

  def symbol_kind(); end

  def try_merge!(pin); end

  def typify(api_map); end

  def variable?(); end
end

class Solargraph::Pin::Base
end

class Solargraph::Pin::BaseVariable
  include ::Solargraph::Parser::Rubyvm::NodeMethods
  def assignment(); end

  def initialize(assignment: T.unsafe(nil), **splat); end

  def nil_assignment?(); end
end

class Solargraph::Pin::BaseVariable
end

class Solargraph::Pin::Block
  def initialize(receiver: T.unsafe(nil), args: T.unsafe(nil), **splat); end

  def parameter_names(); end

  def parameters(); end

  def rebind(api_map); end

  def receiver(); end
end

class Solargraph::Pin::Block
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::Closure
  def gates(); end

  def initialize(scope: T.unsafe(nil), **splat); end

  def scope(); end
end

class Solargraph::Pin::Closure
end

module Solargraph::Pin::Common
  def binder(); end

  def closure(); end

  def comments(); end

  def context(); end

  def full_context(); end

  def location(); end

  def name(); end

  def namespace(); end

  def path(); end

  def return_type(); end
end

module Solargraph::Pin::Common
end

class Solargraph::Pin::Constant
  def initialize(visibility: T.unsafe(nil), **splat); end

  def visibility(); end
end

class Solargraph::Pin::Constant
end

module Solargraph::Pin::Conversions
  def completion_item(); end

  def detail(); end

  def link_documentation(); end

  def reset_conversions(); end

  def resolve_completion_item(); end

  def signature_help(); end

  def text_documentation(); end
end

module Solargraph::Pin::Conversions
end

module Solargraph::Pin::Documenting
  def documentation(); end
end

class Solargraph::Pin::Documenting::DocSection
  def code?(); end

  def concat(text); end

  def initialize(code); end

  def plaintext(); end
end

class Solargraph::Pin::Documenting::DocSection
end

module Solargraph::Pin::Documenting
end

class Solargraph::Pin::DuckMethod
end

class Solargraph::Pin::DuckMethod
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::InstanceVariable
  def scope(); end
end

class Solargraph::Pin::InstanceVariable
end

class Solargraph::Pin::Keyword
  def initialize(name); end
end

class Solargraph::Pin::Keyword
end

class Solargraph::Pin::KeywordParam
end

class Solargraph::Pin::KeywordParam
end

class Solargraph::Pin::LocalVariable
  include ::Solargraph::Pin::Localized
  def initialize(assignment: T.unsafe(nil), presence: T.unsafe(nil), **splat); end
end

class Solargraph::Pin::LocalVariable
end

module Solargraph::Pin::Localized
  def presence(); end

  def visible_at?(other_loc); end

  def visible_from?(other, position); end
end

module Solargraph::Pin::Localized
end

class Solargraph::Pin::Method
  include ::Solargraph::Parser::Rubyvm::NodeMethods
  def attribute?(); end

  def explicit?(); end

  def initialize(visibility: T.unsafe(nil), explicit: T.unsafe(nil), parameters: T.unsafe(nil), node: T.unsafe(nil), attribute: T.unsafe(nil), **splat); end

  def node(); end

  def overloads(); end

  def parameter_names(); end

  def parameters(); end

  def visibility(); end
end

class Solargraph::Pin::Method
end

class Solargraph::Pin::MethodAlias
  def initialize(scope: T.unsafe(nil), original: T.unsafe(nil), **splat); end

  def original(); end
end

class Solargraph::Pin::MethodAlias
end

class Solargraph::Pin::Namespace
  def domains(); end

  def initialize(type: T.unsafe(nil), visibility: T.unsafe(nil), gates: T.unsafe(nil), **splat); end

  def type(); end

  def visibility(); end
end

class Solargraph::Pin::Namespace
end

class Solargraph::Pin::Parameter
  def asgn_code(); end

  def decl(); end

  def full(); end

  def index(); end

  def initialize(decl: T.unsafe(nil), asgn_code: T.unsafe(nil), **splat); end

  def keyword?(); end

  def kwrestarg?(); end

  def rest?(); end

  def restarg?(); end
end

class Solargraph::Pin::Parameter
end

class Solargraph::Pin::ProxyType
  def initialize(return_type: T.unsafe(nil), **splat); end
end

class Solargraph::Pin::ProxyType
  def self.anonymous(return_type); end
end

class Solargraph::Pin::Reference
end

class Solargraph::Pin::Reference::Extend
end

class Solargraph::Pin::Reference::Extend
end

class Solargraph::Pin::Reference::Include
end

class Solargraph::Pin::Reference::Include
end

class Solargraph::Pin::Reference::Override
  def delete(); end

  def initialize(location, name, tags, delete=T.unsafe(nil)); end

  def tags(); end
end

class Solargraph::Pin::Reference::Override
  def self.from_comment(name, comment); end

  def self.method_return(name, *tags, delete: T.unsafe(nil)); end
end

class Solargraph::Pin::Reference::Prepend
end

class Solargraph::Pin::Reference::Prepend
end

class Solargraph::Pin::Reference::Require
  def initialize(location, name); end
end

class Solargraph::Pin::Reference::Require
end

class Solargraph::Pin::Reference::Superclass
end

class Solargraph::Pin::Reference::Superclass
end

class Solargraph::Pin::Reference
end

class Solargraph::Pin::Singleton
  def initialize(name: T.unsafe(nil), location: T.unsafe(nil), closure: T.unsafe(nil)); end
end

class Solargraph::Pin::Singleton
end

class Solargraph::Pin::Symbol
  def initialize(location, name); end

  def visibility(); end
end

class Solargraph::Pin::Symbol
end

module Solargraph::Pin
end

class Solargraph::Position
  def ==(other); end

  def character(); end

  def column(); end

  def initialize(line, character); end

  def line(); end

  def to_hash(); end
end

class Solargraph::Position
  def self.from_offset(text, offset); end

  def self.line_char_to_offset(text, line, character); end

  def self.normalize(object); end

  def self.to_offset(text, position); end
end

class Solargraph::Range
  def ==(other); end

  def contain?(position); end

  def ending(); end

  def include?(position); end

  def initialize(start, ending); end

  def start(); end

  def to_hash(); end
end

class Solargraph::Range
  def self.from_expr(expr); end

  def self.from_node(node); end

  def self.from_to(l1, c1, l2, c2); end
end

module Solargraph::ServerMethods
  def available_port(); end
end

module Solargraph::ServerMethods
end

class Solargraph::Shell
  include ::Solargraph::ServerMethods
  def available_cores(); end

  def bundle(); end

  def clear(); end

  def config(directory=T.unsafe(nil)); end

  def download_core(version=T.unsafe(nil)); end

  def list_cores(); end

  def rdoc(gem, version=T.unsafe(nil)); end

  def reporters(); end

  def scan(); end

  def socket(); end

  def stdio(); end

  def typecheck(*files); end

  def uncache(*gems); end

  def version(); end
end

class Solargraph::Shell
end

class Solargraph::Source
  include ::Solargraph::Source::EncodingFixes
  def associated_comments(); end

  def at(range); end

  def code(); end

  def code=(val); end

  def code_for(node); end

  def comment_at?(position); end

  def comments(); end

  def comments=(comments); end

  def comments_for(node); end

  def cursor_at(position); end

  def error_ranges(); end

  def error_ranges=(error_ranges); end

  def filename(); end

  def filename=(filename); end

  def finish_synchronize(); end

  def folding_ranges(); end

  def from_to(l1, c1, l2, c2); end

  def initialize(code, filename=T.unsafe(nil), version=T.unsafe(nil)); end

  def last_updater(); end

  def last_updater=(last_updater); end

  def location(); end

  def node(); end

  def node=(node); end

  def node_at(line, column); end

  def parsed=(parsed); end

  def parsed?(); end

  def references(name); end

  def repaired(); end

  def repaired=(repaired); end

  def repaired?(); end

  def start_synchronize(updater); end

  def string_at?(position); end

  def string_ranges(); end

  def synchronize(updater); end

  def synchronized=(synchronized); end

  def synchronized?(); end

  def tree_at(line, column); end

  def version(); end

  def version=(version); end
  FOLDING_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Source::Chain
  def base(); end

  def constant?(); end

  def define(api_map, name_pin, locals); end

  def defined?(); end

  def infer(api_map, name_pin, locals); end

  def initialize(links, node=T.unsafe(nil), splat=T.unsafe(nil)); end

  def links(); end

  def literal?(); end

  def node(); end

  def splat?(); end

  def undefined?(); end
  UNDEFINED_CALL = ::T.let(nil, ::T.untyped)
  UNDEFINED_CONSTANT = ::T.let(nil, ::T.untyped)
end

class Solargraph::Source::Chain::BlockVariable
end

class Solargraph::Source::Chain::BlockVariable
end

class Solargraph::Source::Chain::Call
  def arguments(); end

  def initialize(word, arguments=T.unsafe(nil), with_block=T.unsafe(nil)); end

  def with_block?(); end
end

class Solargraph::Source::Chain::Call
end

class Solargraph::Source::Chain::ClassVariable
end

class Solargraph::Source::Chain::ClassVariable
end

class Solargraph::Source::Chain::Constant
  def initialize(word); end
end

class Solargraph::Source::Chain::Constant
end

class Solargraph::Source::Chain::GlobalVariable
end

class Solargraph::Source::Chain::GlobalVariable
end

class Solargraph::Source::Chain::Head
end

class Solargraph::Source::Chain::Head
end

class Solargraph::Source::Chain::InstanceVariable
end

class Solargraph::Source::Chain::InstanceVariable
end

class Solargraph::Source::Chain::Link
  def ==(other); end

  def clone_body(); end

  def clone_head(); end

  def constant?(); end

  def head?(); end

  def initialize(word=T.unsafe(nil)); end

  def last_context(); end

  def last_context=(last_context); end

  def mark_head(bool); end

  def resolve(api_map, name_pin, locals); end

  def undefined?(); end

  def word(); end
end

class Solargraph::Source::Chain::Link
end

class Solargraph::Source::Chain::Literal
  def initialize(type); end
end

class Solargraph::Source::Chain::Literal
end

class Solargraph::Source::Chain::Or
  def initialize(links); end
end

class Solargraph::Source::Chain::Or
end

class Solargraph::Source::Chain::Variable
end

class Solargraph::Source::Chain::Variable
end

class Solargraph::Source::Chain::ZSuper
  def initialize(word, with_block=T.unsafe(nil)); end
end

class Solargraph::Source::Chain::ZSuper
end

class Solargraph::Source::Chain
end

class Solargraph::Source::Change
  include ::Solargraph::Source::EncodingFixes
  def initialize(range, new_text); end

  def new_text(); end

  def range(); end

  def repair(text); end

  def write(text, nullable=T.unsafe(nil)); end
end

class Solargraph::Source::Change
end

class Solargraph::Source::Cursor
  def argument?(); end

  def chain(); end

  def comment?(); end

  def end_of_word(); end

  def filename(); end

  def initialize(source, position); end

  def node(); end

  def node_position(); end

  def offset(); end

  def position(); end

  def range(); end

  def receiver(); end

  def recipient(); end

  def recipient_node(); end

  def source(); end

  def start_of_constant?(); end

  def start_of_word(); end

  def string?(); end

  def word(); end
end

class Solargraph::Source::Cursor
end

module Solargraph::Source::EncodingFixes
end

module Solargraph::Source::EncodingFixes
  def self.normalize(string); end
end

class Solargraph::Source::SourceChainer
  def chain(); end

  def initialize(source, position); end
end

class Solargraph::Source::SourceChainer
  def self.chain(source, position); end
end

class Solargraph::Source::Updater
  def changes(); end

  def filename(); end

  def initialize(filename, version, changes); end

  def repair(text); end

  def version(); end

  def write(text, nullable=T.unsafe(nil)); end
end

class Solargraph::Source::Updater
end

class Solargraph::Source
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil), version=T.unsafe(nil)); end

  def self.parse_docstring(comments); end
end

class Solargraph::SourceMap
  def code(); end

  def cursor_at(position); end

  def document_symbols(); end

  def environ(); end

  def filename(); end

  def first_pin(path); end

  def initialize(source, pins, locals); end

  def locals(); end

  def locals_at(location); end

  def locate_block_pin(line, character); end

  def locate_named_path_pin(line, character); end

  def locate_pins(location); end

  def pins(); end

  def pins_by_class(klass); end

  def query_symbols(query); end

  def rebindable_method_names(); end

  def references(name); end

  def requires(); end

  def source(); end

  def try_merge!(other_map); end
end

class Solargraph::SourceMap::Clip
  def complete(); end

  def define(); end

  def gates(); end

  def in_block?(); end

  def infer(); end

  def initialize(api_map, cursor); end

  def locals(); end

  def signify(); end

  def translate(phrase); end
end

class Solargraph::SourceMap::Clip
end

class Solargraph::SourceMap::Completion
  def initialize(pins, range); end

  def pins(); end

  def range(); end
end

class Solargraph::SourceMap::Completion
end

class Solargraph::SourceMap::Mapper
  def closure_at(position); end

  def find_directive_line_number(comment, tag, start); end

  def map(source); end

  def pins(); end

  def process_comment(source_position, comment_position, comment); end

  def process_comment_directives(); end

  def process_directive(source_position, comment_position, directive); end

  def remove_inline_comment_hashes(comment); end

  def unmap(filename, code); end
  MACRO_REGEXP = ::T.let(nil, ::T.untyped)
end

class Solargraph::SourceMap::Mapper
  def self.map(source); end
end

class Solargraph::SourceMap
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil)); end

  def self.map(source); end
end

class Solargraph::TypeChecker
  include ::Solargraph::TypeChecker::Checks
  include ::Solargraph::Parser::Rubyvm::NodeMethods
  def api_map(); end

  def filename(); end

  def initialize(filename, api_map: T.unsafe(nil), level: T.unsafe(nil)); end

  def problems(); end

  def rules(); end

  def source_map(); end
end

module Solargraph::TypeChecker::Checks
end

module Solargraph::TypeChecker::Checks
  def self.any_types_match?(api_map, expected, inferred); end

  def self.duck_types_match?(api_map, expected, inferred); end

  def self.either_way?(api_map, cls1, cls2); end

  def self.fuzz(type); end

  def self.types_match?(api_map, expected, inferred); end
end

class Solargraph::TypeChecker::ParamDef
  def initialize(name, type); end

  def name(); end

  def type(); end
end

class Solargraph::TypeChecker::ParamDef
  def self.from(pin); end
end

class Solargraph::TypeChecker::Problem
  def initialize(location, message, pin: T.unsafe(nil), suggestion: T.unsafe(nil)); end

  def location(); end

  def message(); end

  def pin(); end

  def suggestion(); end
end

class Solargraph::TypeChecker::Problem
end

class Solargraph::TypeChecker::Rules
  def ignore_all_undefined?(); end

  def initialize(level); end

  def level(); end

  def must_tag_or_infer?(); end

  def rank(); end

  def require_type_tags?(); end

  def validate_calls?(); end

  def validate_consts?(); end

  def validate_tags?(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Solargraph::TypeChecker::Rules
end

class Solargraph::TypeChecker
  def self.load(filename, level=T.unsafe(nil)); end

  def self.load_string(code, filename=T.unsafe(nil), level=T.unsafe(nil)); end
end

class Solargraph::Workspace
  def config(); end

  def directory(); end

  def filenames(); end

  def gemnames(); end

  def gemspec?(); end

  def gemspecs(); end

  def has_file?(filename); end

  def initialize(directory=T.unsafe(nil), config=T.unsafe(nil)); end

  def merge(source); end

  def remove(filename); end

  def require_paths(); end

  def source(filename); end

  def sources(); end

  def synchronize!(updater); end

  def would_merge?(filename); end

  def would_require?(path); end
end

class Solargraph::Workspace::Config
  def allow?(filename); end

  def calculated(); end

  def directory(); end

  def domains(); end

  def excluded(); end

  def formatter(); end

  def included(); end

  def initialize(directory=T.unsafe(nil)); end

  def max_files(); end

  def plugins(); end

  def raw_data(); end

  def reporters(); end

  def require_paths(); end

  def required(); end
  MAX_FILES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Workspace::Config
end

class Solargraph::Workspace
end

class Solargraph::YardMap
  def change(new_requires, new_gemset, source_gems=T.unsafe(nil)); end

  def core_pins(); end

  def gemset(); end

  def initialize(required: T.unsafe(nil), gemset: T.unsafe(nil), with_dependencies: T.unsafe(nil)); end

  def load_yardoc(y); end

  def path_pin(path); end

  def pins(); end

  def rebindable_method_names(); end

  def require_reference(path); end

  def required(); end

  def stdlib_paths(); end

  def stdlib_pins(); end

  def unresolved_requires(); end

  def with_dependencies=(with_dependencies); end

  def with_dependencies?(); end

  def yardocs(); end
end

class Solargraph::YardMap::Cache
  def get_path_pins(path); end

  def set_path_pins(path, pins); end
end

class Solargraph::YardMap::Cache
end

module Solargraph::YardMap::CoreDocs
  DEFAULT = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
end

module Solargraph::YardMap::CoreDocs
  def self.available(); end

  def self.best_download(current=T.unsafe(nil)); end

  def self.best_match(); end

  def self.cache_dir(); end

  def self.clear(); end

  def self.download(version); end

  def self.require_minimum(); end

  def self.valid?(ver); end

  def self.versions(); end

  def self.yardoc_file(ver=T.unsafe(nil)); end

  def self.yardoc_stdlib_file(ver=T.unsafe(nil)); end
end

module Solargraph::YardMap::CoreFills
  ALL = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  OVERRIDES = ::T.let(nil, ::T.untyped)
  PINS = ::T.let(nil, ::T.untyped)
end

Solargraph::YardMap::CoreFills::Override = Solargraph::Pin::Reference::Override

module Solargraph::YardMap::CoreFills
end

module Solargraph::YardMap::CoreGen
end

module Solargraph::YardMap::CoreGen
  def self.generate_docs(ruby_dir, dest_dir); end

  def self.generate_gzip(ruby_dir, ver_name=T.unsafe(nil), dest_dir=T.unsafe(nil)); end
end

module Solargraph::YardMap::Helpers
end

module Solargraph::YardMap::Helpers
  def self.object_location(code_object, spec); end
end

class Solargraph::YardMap::Mapper
  def initialize(code_objects, spec=T.unsafe(nil)); end

  def map(); end
end

module Solargraph::YardMap::Mapper::ToConstant
end

module Solargraph::YardMap::Mapper::ToConstant
  extend ::Solargraph::YardMap::Helpers
  def self.make(code_object, closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

module Solargraph::YardMap::Mapper::ToMethod
end

module Solargraph::YardMap::Mapper::ToMethod
  extend ::Solargraph::YardMap::Helpers
  def self.make(code_object, name=T.unsafe(nil), scope=T.unsafe(nil), visibility=T.unsafe(nil), closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

module Solargraph::YardMap::Mapper::ToNamespace
end

module Solargraph::YardMap::Mapper::ToNamespace
  extend ::Solargraph::YardMap::Helpers
  def self.make(code_object, spec, closure=T.unsafe(nil)); end
end

class Solargraph::YardMap::Mapper
end

module Solargraph::YardMap::RdocToYard
end

module Solargraph::YardMap::RdocToYard
  extend ::Solargraph::ApiMap::SourceToYard
  def self.base_name(mod); end

  def self.commentary(cmnt); end

  def self.find_file(obj); end

  def self.locate(obj); end

  def self.run(spec, cache_dir: T.unsafe(nil)); end
end

module Solargraph::YardMap::StdlibFills
  LIBS = ::T.let(nil, ::T.untyped)
end

Solargraph::YardMap::StdlibFills::Override = Solargraph::Pin::Reference::Override

module Solargraph::YardMap::StdlibFills
  def self.get(path); end
end

class Solargraph::YardMap::ToMethod
  def make(code_object, name=T.unsafe(nil), scope=T.unsafe(nil), visibility=T.unsafe(nil), closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

class Solargraph::YardMap::ToMethod
  extend ::Solargraph::YardMap::Helpers
end

class Solargraph::YardMap
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

module Spoom
  SPOOM_PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Spoom::Cli::Coverage
  DATA_DIR = ::T.let(nil, ::T.untyped)
end

module Spoom::Cli::Helper
  HIGHLIGHT_COLOR = ::T.let(nil, ::T.untyped)
end

class Spoom::Cli::Run
  DEFAULT_FORMAT = ::T.let(nil, ::T.untyped)
  SORT_CODE = ::T.let(nil, ::T.untyped)
  SORT_ENUM = ::T.let(nil, ::T.untyped)
  SORT_LOC = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Cards::Card
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Cards::Snapshot
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

module Spoom::Coverage::D3
  COLOR_FALSE = ::T.let(nil, ::T.untyped)
  COLOR_IGNORE = ::T.let(nil, ::T.untyped)
  COLOR_STRICT = ::T.let(nil, ::T.untyped)
  COLOR_STRONG = ::T.let(nil, ::T.untyped)
  COLOR_TRUE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Page
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Snapshot
  STRICTNESSES = ::T.let(nil, ::T.untyped)
end

class Spoom::LSP::DocumentSymbol
  SYMBOL_KINDS = ::T.let(nil, ::T.untyped)
end

module Spoom::Sorbet
  BIN_PATH = ::T.let(nil, ::T.untyped)
  CONFIG_PATH = ::T.let(nil, ::T.untyped)
  GEM_PATH = ::T.let(nil, ::T.untyped)
end

class Spoom::Sorbet::Errors::Parser
  ERROR_LINE_MATCH_REGEX = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
end

module Spoom::Sorbet::MetricsParser
  DEFAULT_PREFIX = ::T.let(nil, ::T.untyped)
end

module Spoom::Sorbet::Sigils
  SIGIL_REGEXP = ::T.let(nil, ::T.untyped)
  STRICTNESS_FALSE = ::T.let(nil, ::T.untyped)
  STRICTNESS_IGNORE = ::T.let(nil, ::T.untyped)
  STRICTNESS_INTERNAL = ::T.let(nil, ::T.untyped)
  STRICTNESS_STRICT = ::T.let(nil, ::T.untyped)
  STRICTNESS_STRONG = ::T.let(nil, ::T.untyped)
  STRICTNESS_TRUE = ::T.let(nil, ::T.untyped)
  VALID_STRICTNESS = ::T.let(nil, ::T.untyped)
end

module Spoom::Sorbet
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Squasher
  COLORS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Squasher::Cleaner
  def process(); end
  MIGRATION_NAME = ::T.let(nil, ::T.untyped)
end

class Squasher::Cleaner
  def self.process(*args); end
end

class Squasher::Render
  def config(); end

  def each_schema_line(&block); end

  def initialize(name, config); end

  def name(); end

  def render(); end
end

class Squasher::Render
  def self.render(*args); end
end

class Squasher::Worker
  def date(); end

  def initialize(date); end

  def process(); end
end

class Squasher::Worker
  def self.process(*args); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def parse_csv(**options); end

  def shellescape(); end

  def shellsplit(); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(_); end

  def filter(*_); end
end

class Struct::CompletionJourneyData
  def list(); end

  def list=(_); end

  def pointer(); end

  def pointer=(_); end

  def postposing(); end

  def postposing=(_); end

  def preposing(); end

  def preposing=(_); end
end

class Struct::CompletionJourneyData
  def self.[](*_); end

  def self.members(); end
end

Struct::Group = Etc::Group

class Struct::Key
  def char(); end

  def char=(_); end

  def combined_char(); end

  def combined_char=(_); end

  def with_meta(); end

  def with_meta=(_); end
end

class Struct::Key
  def self.[](*_); end

  def self.members(); end
end

class Struct::MenuInfo
  def list(); end

  def list=(_); end

  def target(); end

  def target=(_); end
end

class Struct::MenuInfo
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

module Tapioca
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tapioca::Compilers::Dsl::Base
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::KramdownTemplate
  def allows_script?(); end
  DUMB_QUOTES = ::T.let(nil, ::T.untyped)
end

class Tilt::KramdownTemplate
end

class Tilt::Mapping
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Time
  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def to_default_s(); end
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.new(*events); end
end

class Trailblazer::Activity::Circuit
  Run = ::T.let(nil, ::T.untyped)
end

Trailblazer::Activity::DSL::Linear::Helper::Contract = Trailblazer::Macro::Contract

Trailblazer::Activity::DSL::Linear::Helper::Policy = Trailblazer::Macro::Policy

module Trailblazer::Activity::FastTrack::DSL
  Normalizers = ::T.let(nil, ::T.untyped)
end

Trailblazer::Activity::FastTrack::Linear = Trailblazer::Activity::DSL::Linear

module Trailblazer::Activity::Path::DSL
  Normalizers = ::T.let(nil, ::T.untyped)
end

Trailblazer::Activity::Path::DSL::Linear = Trailblazer::Activity::DSL::Linear

module Trailblazer::Activity::Railway::DSL
  Normalizers = ::T.let(nil, ::T.untyped)
end

Trailblazer::Activity::Railway::DSL::Linear = Trailblazer::Activity::DSL::Linear

class Trailblazer::Context::Container
  include ::Trailblazer::Context::Container::CommonMethods
  include ::Enumerable
  def decompose(); end

  def initialize(wrapped_options, mutable_options, replica_class:, aliases: T.unsafe(nil), **_); end
end

module Trailblazer::Context::Container::CommonMethods
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def each(&block); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def key?(key); end

  def keys(); end

  def merge(other_hash); end

  def store(key, value); end

  def to_hash(); end

  def value?(value); end

  def values(); end
end

module Trailblazer::Context::Container::CommonMethods
end

module Trailblazer::Context::Container::Delegations
  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def dig(*args, &block); end

  def each_key(*args, &block); end

  def each_value(*args, &block); end

  def fetch_values(*args, &block); end

  def index(*args, &block); end

  def key(*args, &block); end

  def slice(*args, &block); end

  def values_at(*args, &block); end
end

module Trailblazer::Context::Container::Delegations
  extend ::Forwardable
end

class Trailblazer::Context::Container::UseWithAliases
end

class Trailblazer::Context::Container::UseWithAliases
end

class Trailblazer::Context::Container::WithAliases
  def alias_mapping_for(key); end

  def aliased_delete(key); end

  def aliased_merge(other_hash); end

  def aliased_writer(key, value); end

  def initialize(wrapped_options, mutable_options, aliases:, replica_class:, **_); end
end

class Trailblazer::Context::Container::WithAliases
end

class Trailblazer::Context::Container
  extend ::Trailblazer::Context::Container::Delegations
end

class Trailblazer::Context::Store::IndifferentAccess
  include ::Hashie::Extensions::IndifferentAccess
  def []=(key, value); end

  def default(key=T.unsafe(nil)); end

  def delete(key); end

  def fetch(key, *args, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(hashes); end

  def key?(key); end

  def member?(key); end

  def regular_default(*_); end

  def regular_delete(_); end

  def regular_fetch(*_); end

  def regular_key?(_); end

  def regular_replace(_); end

  def regular_update(*_); end

  def regular_values_at(*_); end

  def regular_writer(_, _1); end

  def replace(other_hash); end

  def store(key, value); end

  def update(other_hash); end

  def values_at(*indices); end
end

class Trailblazer::Context::Store::IndifferentAccess
  def self.try_convert(*_); end
end

module Trailblazer::Developer::Render::Linear
  Operator = ::T.let(nil, ::T.untyped)
end

Trailblazer::Developer::Trace::Activity = Trailblazer::Activity

module Trailblazer::Developer::Wtf::Renderer
  DEFAULT_COLOR_MAP = ::T.let(nil, ::T.untyped)
  SIGNALS_MAP = ::T.let(nil, ::T.untyped)
end

module Trailblazer::Macro
  NoopHandler = ::T.let(nil, ::T.untyped)
end

Trailblazer::Macro::Linear = Trailblazer::Activity::DSL::Linear

class Trailblazer::Macro::Nested::Dynamic
  STATIC_OUTPUTS = ::T.let(nil, ::T.untyped)
end

Trailblazer::Operation::Railway::End::Failure = Trailblazer::Activity::Railway::End::Failure

Trailblazer::Operation::Railway::End::Success = Trailblazer::Activity::Railway::End::Success

Trailblazer::Operation::Railway::KwSignature = Trailblazer::Operation::Railway::Macaroni

class Trailblazer::Operation::Trace::Result
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Trailblazer::Version
  VERSION = ::T.let(nil, ::T.untyped)
end

module Trailblazer::Version::Activity
  VERSION = ::T.let(nil, ::T.untyped)
end

module Trailblazer::Version::Activity::DSL::Linear
  VERSION = ::T.let(nil, ::T.untyped)
end

module Trailblazer::Version::Developer
  VERSION = ::T.let(nil, ::T.untyped)
end

module Trailblazer::Version::Macro
  VERSION = ::T.let(nil, ::T.untyped)
end

module Trailblazer::Version::Macro::Contract
  VERSION = ::T.let(nil, ::T.untyped)
end

module Trailblazer::Version::Operation
  VERSION = ::T.let(nil, ::T.untyped)
end

module Transproc
  Undefined = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Transproc::ArrayTransformations::Combine
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
end

module Transproc::Coercions
  BOOLEAN_MAP = ::T.let(nil, ::T.untyped)
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
end

module Transproc::HashTransformations
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

module Transproc::Recursion
  IF_ARRAY = ::T.let(nil, ::T.untyped)
  IF_ENUMERABLE = ::T.let(nil, ::T.untyped)
  IF_HASH = ::T.let(nil, ::T.untyped)
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module TypeCoerce::Configuration
  extend ::T::Private::Methods::SingletonMethodHooks
end

class TypeCoerce::Converter
  PRIMITIVE_TYPES = ::T.let(nil, ::T.untyped)
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def buffer_open(buf, proxy, options); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::HTTP
  def buffer_open(buf, proxy, options); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

  def self.open(name, *rest, &block); end
end

Uber::InheritableAttribute = Uber::InheritableAttr

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class UrlMount
  DELIMETERS = ::T.let(nil, ::T.untyped)
end

class Vector
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def [](i); end

  def []=(i, v); end

  def collect!(&block); end

  def covector(); end

  def elements(); end

  def initialize(array); end

  def map!(&block); end
end

class Vector::ZeroVectorError
end

class Vector::ZeroVectorError
end

class Vector
  extend ::Matrix::ConversionHelper
end

module Warning
  extend ::Warning
end

module Web::Action
end

Web::Action::BaseParams = Hanami::Action::BaseParams

Web::Action::CSRFProtection = Hanami::Action::CSRFProtection

Web::Action::Callable = Hanami::Action::Callable

Web::Action::Callbacks = Hanami::Action::Callbacks

Web::Action::Configurable = Hanami::Action::Configurable

Web::Action::Exposable = Hanami::Action::Exposable

Web::Action::Flash = Hanami::Action::Flash

Web::Action::Glue = Hanami::Action::Glue

Web::Action::Head = Hanami::Action::Head

Web::Action::InvalidCSRFTokenError = Hanami::Action::InvalidCSRFTokenError

Web::Action::Mime = Hanami::Action::Mime

Web::Action::Params = Hanami::Action::Params

Web::Action::Rack = Hanami::Action::Rack

Web::Action::Redirect = Hanami::Action::Redirect

Web::Action::Request = Hanami::Action::Request

Web::Action::RoutingHelpers = Hanami::Action::RoutingHelpers

Web::Action::Session = Hanami::Action::Session

Web::Action::Throwable = Hanami::Action::Throwable

Web::Action::Validatable = Hanami::Action::Validatable

module Web::Action
  def self.included(base); end
end

class Web::Application
  extend ::Hanami::Application::ClassMethods
  def self.configuration(); end

  def self.configurations(); end

  def self.namespace(); end
end

module Web::Assets
  include ::Hanami::Utils::ClassAttribute
  VERSION = ::T.let(nil, ::T.untyped)
end

Web::Assets::Config = Hanami::Assets::Config

Web::Assets::Configuration = Hanami::Assets::Configuration

Web::Assets::Error = Hanami::Assets::Error

Web::Assets::Helpers = Hanami::Assets::Helpers

Web::Assets::MissingManifestAssetError = Hanami::Assets::MissingManifestAssetError

Web::Assets::MissingManifestFileError = Hanami::Assets::MissingManifestFileError

module Web::Assets
  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(&blk); end

  def self.deploy(); end

  def self.dupe(); end

  def self.duplicate(_mod, &blk); end

  def self.duplicates(); end

  def self.load!(); end

  def self.precompile(configurations); end

  def self.sources(); end
end

module Web::Controller
  include ::Hanami::Utils::ClassAttribute
  VERSION = ::T.let(nil, ::T.untyped)
end

Web::Controller::Configuration = Hanami::Controller::Configuration

Web::Controller::Error = Hanami::Controller::Error

Web::Controller::IllegalExposureError = Hanami::Controller::IllegalExposureError

Web::Controller::MissingSessionError = Hanami::Controller::MissingSessionError

Web::Controller::UnknownFormatError = Hanami::Controller::UnknownFormatError

module Web::Controller
  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(&blk); end

  def self.dupe(); end

  def self.duplicate(mod, controllers=T.unsafe(nil), &blk); end

  def self.load!(); end
end

module Web::Controllers
end

module Web::Controllers
end

module Web::Layout
  def initialize(scope, rendered); end

  def local(key); end

  def render(); end

  def template(); end
end

Web::Layout::ClassMethods = Hanami::Layout::ClassMethods

module Web::Layout
  def self.included(base); end
end

module Web::Presenter
end

module Web::Presenter
  def self.included(base); end
end

module Web::View
  include ::Hanami::Utils::ClassAttribute
  VERSION = ::T.let(nil, ::T.untyped)
end

Web::View::Configuration = Hanami::View::Configuration

Web::View::Dsl = Hanami::View::Dsl

Web::View::Error = Hanami::View::Error

Web::View::Escape = Hanami::View::Escape

Web::View::Inheritable = Hanami::View::Inheritable

Web::View::MissingFormatError = Hanami::View::MissingFormatError

Web::View::MissingTemplateError = Hanami::View::MissingTemplateError

Web::View::MissingTemplateLayoutError = Hanami::View::MissingTemplateLayoutError

Web::View::Rendering = Hanami::View::Rendering

Web::View::Template = Hanami::View::Template

Web::View::UnknownRenderTypeError = Hanami::View::UnknownRenderTypeError

module Web::View
  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(&blk); end

  def self.dupe(); end

  def self.duplicate(mod, views=T.unsafe(nil), &blk); end

  def self.included(base); end

  def self.load!(); end
end

class Web::Views::ApplicationLayout
  include ::Web::Layout
  include ::Hanami::Utils::ClassAttribute
  include ::Hanami::Helpers
  include ::Hanami::Helpers::EscapeHelper
  include ::Hanami::Helpers::RoutingHelper
  include ::Hanami::Helpers::LinkToHelper
  include ::Hanami::Helpers::FormHelper
  include ::Hanami::Helpers::NumberFormattingHelper
  include ::Hanami::Assets::Helpers
  include ::Hanami::Helpers::HtmlHelper
  def routes(); end
end

class Web::Views::ApplicationLayout
  extend ::Hanami::Layout::ClassMethods
  def self.assets_configuration(); end

  def self.assets_configuration=(assets_configuration); end

  def self.configuration(); end

  def self.configuration=(configuration); end
end

module Web
  def self.routes(); end

  def self.routes=(routes); end
end

module XPath::DSL
  def join(*expressions); end
  AXES = ::T.let(nil, ::T.untyped)
  LOWERCASE_LETTERS = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  UPPERCASE_LETTERS = ::T.let(nil, ::T.untyped)
end

class XPath::Renderer
  def join(*expressions); end
end

module YARD
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  TEMPLATE_ROOT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::CommandParser
  def run(*args); end
end

class YARD::CLI::CommandParser
  def self.commands(); end

  def self.commands=(commands); end

  def self.default_command(); end

  def self.default_command=(default_command); end

  def self.run(*args); end
end

class YARD::CLI::Config
  def append(); end

  def append=(append); end

  def as_list(); end

  def as_list=(as_list); end

  def gem_install_cmd(); end

  def gem_install_cmd=(gem_install_cmd); end

  def key(); end

  def key=(key); end

  def reset(); end

  def reset=(reset); end

  def run(*args); end

  def values(); end

  def values=(values); end
end

class YARD::CLI::Config
end

class YARD::CLI::Diff
  def run(*args); end
end

class YARD::CLI::Diff
end

class YARD::CLI::Display
  def format_objects(); end

  def initialize(*args); end

  def wrap_layout(contents); end
end

class YARD::CLI::Display
end

class YARD::CLI::Gems
  def run(*args); end
end

class YARD::CLI::Gems
end

class YARD::CLI::Graph
  def objects(); end

  def options(); end

  def run(*args); end
end

class YARD::CLI::Graph
end

class YARD::CLI::Help
  def run(*args); end
end

class YARD::CLI::Help
end

class YARD::CLI::I18n
end

class YARD::CLI::I18n
end

class YARD::CLI::List
  def run(*args); end
end

class YARD::CLI::List
end

class YARD::CLI::MarkupTypes
  def run(*args); end
end

class YARD::CLI::MarkupTypes
end

class YARD::CLI::Server
  def adapter(); end

  def adapter=(adapter); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def run(*args); end

  def scripts(); end

  def scripts=(scripts); end

  def server_options(); end

  def server_options=(server_options); end

  def template_paths(); end

  def template_paths=(template_paths); end
end

class YARD::CLI::Server
end

class YARD::CLI::Stats
  include ::YARD::Templates::Helpers::BaseHelper
  def initialize(parse=T.unsafe(nil)); end

  def output(name, data, undoc=T.unsafe(nil)); end

  def parse(); end

  def parse=(parse); end

  def print_statistics(); end

  def print_undocumented_objects(); end

  def stats_for_attributes(); end

  def stats_for_classes(); end

  def stats_for_constants(); end

  def stats_for_files(); end

  def stats_for_methods(); end

  def stats_for_modules(); end
  STATS_ORDER = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::Stats
end

class YARD::CLI::YRI
  def cache_object(name, path); end

  def find_object(name); end

  def print_object(object); end

  def print_usage(); end

  def run(*args); end
  CACHE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATHS = ::T.let(nil, ::T.untyped)
  SEARCH_PATHS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YRI
end

class YARD::CLI::YardoptsCommand
  DEFAULT_YARDOPTS_FILE = ::T.let(nil, ::T.untyped)
end

module YARD::CodeObjects
  BUILTIN_ALL = ::T.let(nil, ::T.untyped)
  BUILTIN_CLASSES = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS_HASH = ::T.let(nil, ::T.untyped)
  BUILTIN_MODULES = ::T.let(nil, ::T.untyped)
  CONSTANTMATCH = ::T.let(nil, ::T.untyped)
  CONSTANTSTART = ::T.let(nil, ::T.untyped)
  CSEP = ::T.let(nil, ::T.untyped)
  CSEPQ = ::T.let(nil, ::T.untyped)
  ISEP = ::T.let(nil, ::T.untyped)
  ISEPQ = ::T.let(nil, ::T.untyped)
  METHODMATCH = ::T.let(nil, ::T.untyped)
  METHODNAMEMATCH = ::T.let(nil, ::T.untyped)
  NAMESPACEMATCH = ::T.let(nil, ::T.untyped)
  NSEP = ::T.let(nil, ::T.untyped)
  NSEPQ = ::T.let(nil, ::T.untyped)
  PROXY_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::ClassObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end

  def inherited_constants(); end

  def inherited_meths(opts=T.unsafe(nil)); end

  def is_exception?(); end

  def superclass(); end

  def superclass=(object); end
end

class YARD::CodeObjects::ClassVariableObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ClassVariableObject
end

class YARD::CodeObjects::ConstantObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ExtendedMethodObject
  def initialize(obj); end

  def method_missing(sym, *args, &block); end

  def scope(); end
end

class YARD::CodeObjects::ExtendedMethodObject
end

class YARD::CodeObjects::ExtraFileObject
  def ==(other); end

  def attributes(); end

  def attributes=(attributes); end

  def contents(); end

  def contents=(contents); end

  def eql?(other); end

  def equal?(other); end

  def filename(); end

  def filename=(filename); end

  def initialize(filename, contents=T.unsafe(nil)); end

  def locale(); end

  def locale=(locale); end

  def name(); end

  def name=(name); end

  def path(); end

  def title(); end

  def type(); end
end

class YARD::CodeObjects::ExtraFileObject
end

class YARD::CodeObjects::MacroObject
  def attached?(); end

  def expand(call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def macro_data(); end

  def macro_data=(macro_data); end

  def method_object(); end

  def method_object=(method_object); end
  MACRO_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::MacroObject
  def self.apply(docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil), _method_object=T.unsafe(nil)); end

  def self.apply_macro(macro, docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.create(macro_name, data, method_object=T.unsafe(nil)); end

  def self.create_docstring(macro_name, data, method_object=T.unsafe(nil)); end

  def self.expand(macro_data, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.find(macro_name); end

  def self.find_or_create(macro_name, data, method_object=T.unsafe(nil)); end
end

class YARD::CodeObjects::ModuleObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end
end

class YARD::CodeObjects::ModuleObject
end

class YARD::CodeObjects::NamespaceObject
  def aliases(); end

  def attributes(); end

  def child(opts=T.unsafe(nil)); end

  def children(); end

  def class_attributes(); end

  def class_mixins(); end

  def constants(opts=T.unsafe(nil)); end

  def cvars(); end

  def groups(); end

  def groups=(groups); end

  def included_constants(); end

  def included_meths(opts=T.unsafe(nil)); end

  def initialize(namespace, name, *args, &block); end

  def instance_attributes(); end

  def instance_mixins(); end

  def meths(opts=T.unsafe(nil)); end

  def mixins(*scopes); end
end

class YARD::CodeObjects::Proxy
  def ==(other); end

  def ===(other); end

  def equal?(other); end

  def initialize(namespace, name, type=T.unsafe(nil)); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def parent(); end

  def path(); end

  def respond_to?(meth, include_private=T.unsafe(nil)); end

  def root?(); end

  def title(); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class YARD::CodeObjects::Proxy
  def self.===(other); end
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::RootObject
end

class YARD::CodeObjects::RootObject
end

class YARD::Config
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  CONFIG_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG_OPTIONS = ::T.let(nil, ::T.untyped)
  IGNORED_PLUGINS = ::T.let(nil, ::T.untyped)
  YARD_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class YARD::Docstring
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::DocstringParser
  META_MATCH = ::T.let(nil, ::T.untyped)
end

module YARD::GemIndex
end

module YARD::GemIndex
  def self.all(); end

  def self.each(&block); end

  def self.find_all_by_name(*args); end
end

class YARD::Handlers::C::AliasHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AliasHandler
end

class YARD::Handlers::C::AttributeHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AttributeHandler
end

class YARD::Handlers::C::Base
  include ::YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::Handlers::Common::MethodHandler
  def ensure_variable_defined!(var, max_retries=T.unsafe(nil)); end

  def namespace_for_variable(var); end

  def namespaces(); end

  def override_comments(); end

  def parse_block(opts=T.unsafe(nil)); end

  def process_file(file, object); end

  def processed_files(); end

  def symbols(); end
  ERROR_CLASS_NAMES = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::Base
  def self.handles?(statement, processor); end

  def self.statement_class(type=T.unsafe(nil)); end
end

class YARD::Handlers::C::ClassHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ClassHandler
end

class YARD::Handlers::C::ConstantHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ConstantHandler
end

module YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::CodeObjects
  include ::YARD::Handlers::Common::MethodHandler
  def handle_alias(var_name, new_name, old_name); end

  def handle_attribute(var_name, name, read, write); end

  def handle_class(var_name, class_name, parent, in_module=T.unsafe(nil)); end

  def handle_constants(type, var_name, const_name, value); end

  def handle_method(scope, var_name, name, func_name, _source_file=T.unsafe(nil)); end

  def handle_module(var_name, module_name, in_module=T.unsafe(nil)); end
end

module YARD::Handlers::C::HandlerMethods
end

class YARD::Handlers::C::InitHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::InitHandler
end

class YARD::Handlers::C::MethodHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
  MATCH3 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MethodHandler
end

class YARD::Handlers::C::MixinHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MixinHandler
end

class YARD::Handlers::C::ModuleHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ModuleHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::PathHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::PathHandler
end

class YARD::Handlers::C::StructHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::StructHandler
end

class YARD::Handlers::C::SymbolHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::SymbolHandler
end

module YARD::Handlers::Common::MethodHandler
  def add_predicate_return_tag(obj); end
end

module YARD::Handlers::Common::MethodHandler
end

class YARD::Handlers::Processor
  def extra_state(); end

  def extra_state=(extra_state); end

  def file(); end

  def file=(file); end

  def find_handlers(statement); end

  def globals(); end

  def globals=(globals); end

  def initialize(parser); end

  def namespace(); end

  def namespace=(namespace); end

  def owner(); end

  def owner=(owner); end

  def parse_remaining_files(); end

  def parser_type(); end

  def parser_type=(parser_type); end

  def process(statements); end

  def scope(); end

  def scope=(scope); end

  def visibility(); end

  def visibility=(visibility); end
end

class YARD::Handlers::Processor
  def self.namespace_for_handler(); end

  def self.register_handler_namespace(type, ns); end
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AttributeHandler
  def validated_attribute_names(params); end
end

class YARD::Handlers::Ruby::Base
  extend ::YARD::Parser::Ruby
end

class YARD::Handlers::Ruby::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ConstantHandler
end

class YARD::Handlers::Ruby::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::DSLHandler
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def handle_comments(); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end
  IGNORE_METHODS = ::T.let(nil, ::T.untyped)
end

module YARD::Handlers::Ruby::DSLHandlerMethods
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
  def process_decorator(*nodes, &block); end
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Parser::Ruby::Legacy::RubyToken
  def parse_block(opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Legacy::Base
  def self.handles?(stmt); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodHandler
  include ::YARD::Handlers::Common::MethodHandler
  def format_args(); end
end

class YARD::Handlers::Ruby::MixinHandler
  def process_mixin(mixin); end

  def recipient(mixin); end
end

class YARD::Handlers::Ruby::MixinHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
end

class YARD::Handlers::Ruby::VisibilityHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::VisibilityHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class YARD::I18n::Locale
  def self.default(); end

  def self.default=(locale); end
end

class YARD::I18n::Message
  def ==(other); end

  def add_comment(comment); end

  def add_location(path, line); end

  def comments(); end

  def id(); end

  def initialize(id); end

  def locations(); end
end

class YARD::I18n::Message
end

class YARD::I18n::Messages
  include ::Enumerable
  def ==(other); end

  def [](id); end

  def each(&block); end

  def messages(); end

  def register(id); end
end

class YARD::I18n::Messages
end

class YARD::I18n::PotGenerator
  def generate(); end

  def initialize(relative_base_path); end

  def messages(); end

  def parse_files(files); end

  def parse_objects(objects); end
end

class YARD::I18n::PotGenerator
end

class YARD::I18n::Text
  def extract_messages(); end

  def initialize(input, options=T.unsafe(nil)); end

  def translate(locale); end
end

class YARD::I18n::Text
end

class YARD::Logger
  PROGRESS_INDICATORS = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def Token(token, value=T.unsafe(nil)); end

  def set_token_position(line, char); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  NEWLINE_TOKEN = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class YARD::Parser::SourceParser
  DEFAULT_PATH_GLOB = ::T.let(nil, ::T.untyped)
  ENCODING_BYTE_ORDER_MARKS = ::T.let(nil, ::T.untyped)
  ENCODING_LINE = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LINE = ::T.let(nil, ::T.untyped)
  SHEBANG_LINE = ::T.let(nil, ::T.untyped)
end

class YARD::Rake::YardocTask
  def after(); end

  def after=(after); end

  def before(); end

  def before=(before); end

  def define(); end

  def files(); end

  def files=(files); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def stats_options(); end

  def stats_options=(stats_options); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Rake::YardocTask
end

module YARD::Registry
  DEFAULT_PO_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_YARDOC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_YARDOC_INDEX = ::T.let(nil, ::T.untyped)
end

class YARD::RegistryResolver
  include ::YARD::CodeObjects::NamespaceMapper
  def initialize(registry=T.unsafe(nil)); end

  def lookup_by_path(path, opts=T.unsafe(nil)); end
end

class YARD::RegistryResolver
end

class YARD::RegistryStore
  def [](key); end

  def []=(key, value); end

  def checksums(); end

  def checksums_path(); end

  def delete(key); end

  def destroy(force=T.unsafe(nil)); end

  def file(); end

  def get(key); end

  def keys(reload=T.unsafe(nil)); end

  def load(file=T.unsafe(nil)); end

  def load!(file=T.unsafe(nil)); end

  def load_all(); end

  def load_yardoc(); end

  def locale(name); end

  def lock_for_writing(file=T.unsafe(nil), &block); end

  def locked_for_writing?(file=T.unsafe(nil)); end

  def object_types_path(); end

  def objects_path(); end

  def paths_for_type(type, reload=T.unsafe(nil)); end

  def proxy_types(); end

  def proxy_types_path(); end

  def put(key, value); end

  def root(); end

  def save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def values(reload=T.unsafe(nil)); end

  def values_for_type(type, reload=T.unsafe(nil)); end
end

class YARD::RegistryStore
end

class YARD::Serializers::Base
  def after_serialize(data); end

  def before_serialize(); end

  def exists?(object); end

  def initialize(opts=T.unsafe(nil)); end

  def options(); end

  def serialize(object, data); end

  def serialized_path(object); end
end

class YARD::Serializers::Base
end

class YARD::Serializers::FileSystemSerializer
  def basepath(); end

  def basepath=(value); end

  def extension(); end

  def extension=(value); end
end

class YARD::Serializers::FileSystemSerializer
end

class YARD::Serializers::ProcessSerializer
  def initialize(cmd); end

  def serialize(_object, data); end
end

class YARD::Serializers::ProcessSerializer
end

class YARD::Serializers::StdoutSerializer
  def initialize(wrap=T.unsafe(nil)); end

  def serialize(_object, data); end
end

class YARD::Serializers::StdoutSerializer
end

class YARD::Serializers::YardocSerializer
  def checksums_path(); end

  def complete?(); end

  def complete_lock_path(); end

  def deserialize(path, is_path=T.unsafe(nil)); end

  def initialize(yfile); end

  def lock_for_writing(); end

  def locked_for_writing?(); end

  def object_types_path(); end

  def objects_path(); end

  def processing_path(); end

  def proxy_types_path(); end

  def serialize(object); end
end

class YARD::Serializers::YardocSerializer
end

class YARD::Server::Adapter
  def add_library(library); end

  def document_root(); end

  def document_root=(document_root); end

  def initialize(libs, opts=T.unsafe(nil), server_opts=T.unsafe(nil)); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def router(); end

  def router=(router); end

  def server_options(); end

  def server_options=(server_options); end

  def start(); end
end

class YARD::Server::Adapter
  def self.setup(); end

  def self.shutdown(); end
end

class YARD::Server::Commands::Base
  def adapter(); end

  def adapter=(adapter); end

  def body(); end

  def body=(body); end

  def cache(data); end

  def caching(); end

  def caching=(caching); end

  def call(request); end

  def command_options(); end

  def command_options=(command_options); end

  def headers(); end

  def headers=(headers); end

  def initialize(opts=T.unsafe(nil)); end

  def not_found(); end

  def path(); end

  def path=(path); end

  def redirect(url); end

  def render(object=T.unsafe(nil)); end

  def request(); end

  def request=(request); end

  def run(); end

  def status(); end

  def status=(status); end
end

class YARD::Server::Commands::Base
end

class YARD::Server::Commands::DisplayFileCommand
  def index(); end

  def index=(index); end
end

class YARD::Server::Commands::DisplayFileCommand
end

class YARD::Server::Commands::DisplayObjectCommand
  include ::YARD::Server::DocServerHelper
  def index(); end
end

class YARD::Server::Commands::DisplayObjectCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::LibraryCommand
  def incremental(); end

  def incremental=(incremental); end

  def library(); end

  def library=(library); end

  def options(); end

  def options=(options); end

  def serializer(); end

  def serializer=(serializer); end

  def single_library(); end

  def single_library=(single_library); end

  def use_fork(); end

  def use_fork=(use_fork); end
  CAN_FORK = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::LibraryCommand
end

class YARD::Server::Commands::LibraryIndexCommand
  def options(); end

  def options=(options); end
end

class YARD::Server::Commands::LibraryIndexCommand
end

class YARD::Server::Commands::ListCommand
  include ::YARD::Templates::Helpers::BaseHelper
end

class YARD::Server::Commands::ListCommand
end

class YARD::Server::Commands::RootRequestCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
end

class YARD::Server::Commands::RootRequestCommand
end

class YARD::Server::Commands::SearchCommand
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Server::DocServerHelper
  def query(); end

  def query=(query); end

  def results(); end

  def results=(results); end

  def visible_results(); end
end

class YARD::Server::Commands::SearchCommand
end

class YARD::Server::Commands::StaticFileCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  STATIC_PATHS = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::StaticFileCommand
end

module YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  def favicon?(); end

  def static_template_file?(); end
end

module YARD::Server::Commands::StaticFileHelpers
  def self.find_file(adapter, url); end
end

module YARD::Server::DocServerHelper
  def abs_url(*path_components); end

  def base_path(path); end

  def mtime(file); end

  def mtime_url(file); end

  def router(); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
end

module YARD::Server::DocServerHelper
end

class YARD::Server::DocServerSerializer
  def initialize(_command=T.unsafe(nil)); end
end

class YARD::Server::DocServerSerializer
end

class YARD::Server::FinishRequest
end

class YARD::Server::FinishRequest
end

class YARD::Server::LibraryVersion
  def ==(other); end

  def eql?(other); end

  def equal?(other); end

  def gemspec(); end

  def initialize(name, version=T.unsafe(nil), yardoc=T.unsafe(nil), source=T.unsafe(nil)); end

  def load_yardoc_from_disk(); end

  def load_yardoc_from_gem(); end

  def name(); end

  def name=(name); end

  def prepare!(); end

  def ready?(); end

  def source(); end

  def source=(source); end

  def source_path(); end

  def source_path=(source_path); end

  def source_path_for_disk(); end

  def source_path_for_gem(); end

  def to_s(url_format=T.unsafe(nil)); end

  def version(); end

  def version=(version); end

  def yardoc_file(); end

  def yardoc_file=(yardoc_file); end

  def yardoc_file_for_gem(); end
end

class YARD::Server::LibraryVersion
end

class YARD::Server::NotFoundError
end

class YARD::Server::NotFoundError
end

class YARD::Server::RackAdapter
  include ::WEBrick::HTTPUtils
  def call(env); end
end

class YARD::Server::RackAdapter
end

class YARD::Server::RackMiddleware
  def call(env); end

  def initialize(app, opts=T.unsafe(nil)); end
end

class YARD::Server::RackMiddleware
end

class YARD::Server::Router
  include ::YARD::Server::StaticCaching
  include ::YARD::Server::Commands
  def adapter(); end

  def adapter=(adapter); end

  def call(request); end

  def docs_prefix(); end

  def final_options(library, paths); end

  def initialize(adapter); end

  def list_prefix(); end

  def parse_library_from_path(paths); end

  def request(); end

  def request=(request); end

  def route(path=T.unsafe(nil)); end

  def route_docs(library, paths); end

  def route_index(); end

  def route_list(library, paths); end

  def route_search(library, paths); end

  def route_static(library, paths); end

  def search_prefix(); end

  def static_prefix(); end
end

class YARD::Server::Router
end

module YARD::Server::StaticCaching
  def check_static_cache(); end
end

module YARD::Server::StaticCaching
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickServlet
  def adapter(); end

  def adapter=(adapter); end

  def do_GET(request, response); end

  def initialize(server, adapter); end
end

class YARD::Server::WebrickServlet
end

class YARD::StubProxy
  def _dump(_depth); end

  def initialize(path, transient=T.unsafe(nil)); end

  def method_missing(meth, *args, &block); end
  FILELEN = ::T.let(nil, ::T.untyped)
end

class YARD::StubProxy
  def self._load(str); end
end

class YARD::Tags::DefaultFactory
  def parse_tag(tag_name, text); end

  def parse_tag_with_name(tag_name, text); end

  def parse_tag_with_options(tag_name, text); end

  def parse_tag_with_title_and_text(tag_name, text); end

  def parse_tag_with_types(tag_name, text); end

  def parse_tag_with_types_and_name(tag_name, text); end

  def parse_tag_with_types_and_title(tag_name, text); end

  def parse_tag_with_types_name_and_default(tag_name, text); end
  TYPELIST_CLOSING_CHARS = ::T.let(nil, ::T.untyped)
  TYPELIST_OPENING_CHARS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::DefaultFactory
end

class YARD::Tags::DefaultTag
  def defaults(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

class YARD::Tags::DefaultTag
end

class YARD::Tags::Library
  def domain_directive(tag, parser); end

  def override_directive(tag, parser); end

  def param_tuple_tag(text); end

  def return_single_parameter_tag(text); end

  def return_value_parameter_tag(text); end

  def type_tag(text); end

  def yieldparam_single_parameter_tag(text); end

  def yieldpublic_tag(text); end

  def yieldself_tag(text); end
end

class YARD::Tags::MethodDirective
  SCOPE_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::OptionTag
  def initialize(tag_name, name, pair); end

  def pair(); end

  def pair=(pair); end
end

class YARD::Tags::OptionTag
end

module YARD::Tags::RefTag
  def owner(); end

  def owner=(owner); end
end

module YARD::Tags::RefTag
end

class YARD::Tags::RefTagList
  def initialize(tag_name, owner, name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def owner(); end

  def owner=(owner); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def tags(); end
end

class YARD::Tags::RefTagList
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TypesExplainer
end

class YARD::Tags::TypesExplainer::CollectionType
  def initialize(name, types); end

  def to_s(_singular=T.unsafe(nil)); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::TypesExplainer::CollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::HashCollectionType
  def initialize(name, key_types, value_types); end

  def key_types(); end

  def key_types=(key_types); end

  def to_s(_singular=T.unsafe(nil)); end

  def value_types(); end

  def value_types=(value_types); end
end

class YARD::Tags::TypesExplainer::HashCollectionType
end

class YARD::Tags::TypesExplainer::Parser
  include ::YARD::CodeObjects
  def initialize(string); end

  def parse(); end
  TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::TypesExplainer::Parser
  def self.parse(string); end
end

class YARD::Tags::TypesExplainer::Type
  def initialize(name); end

  def name(); end

  def name=(name); end

  def to_s(singular=T.unsafe(nil)); end
end

class YARD::Tags::TypesExplainer::Type
end

class YARD::Tags::TypesExplainer
  def self.explain(*types); end

  def self.explain!(*types); end
end

module YARD::Templates::Engine
end

module YARD::Templates::Engine
  def self.generate(objects, options=T.unsafe(nil)); end

  def self.register_template_path(path); end

  def self.render(options=T.unsafe(nil)); end

  def self.template(*path); end

  def self.template!(path, full_paths=T.unsafe(nil)); end

  def self.template_paths(); end

  def self.template_paths=(template_paths); end

  def self.with_serializer(object, serializer); end
end

module YARD::Templates::ErbCache
end

module YARD::Templates::ErbCache
  def self.clear!(); end

  def self.method_for(filename); end
end

module YARD::Templates::Helpers::BaseHelper
  def format_object_title(object); end

  def format_object_type(object); end

  def format_source(value); end

  def format_types(list, brackets=T.unsafe(nil)); end

  def globals(); end

  def h(text); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def linkify(*args); end

  def object(); end

  def object=(object); end

  def owner(); end

  def run_verifier(list); end

  def serializer(); end

  def serializer=(serializer); end
end

module YARD::Templates::Helpers::BaseHelper
end

module YARD::Templates::Helpers::FilterHelper
  def is_class?(object); end

  def is_method?(object); end

  def is_module?(object); end

  def is_namespace?(object); end
end

module YARD::Templates::Helpers::FilterHelper
end

module YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::MarkupHelper
  include ::YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def anchor_for(object); end

  def charset(); end

  def format_object_name_list(objects); end

  def format_types(typelist, brackets=T.unsafe(nil)); end

  def h(text); end

  def html_markup_asciidoc(text); end

  def html_markup_html(text); end

  def html_markup_markdown(text); end

  def html_markup_none(text); end

  def html_markup_org(text); end

  def html_markup_pre(text); end

  def html_markup_rdoc(text); end

  def html_markup_ruby(source); end

  def html_markup_text(text); end

  def html_markup_textile(text); end

  def html_markup_textile_strict(text); end

  def html_syntax_highlight(source, type=T.unsafe(nil)); end

  def html_syntax_highlight_plain(source); end

  def htmlify(text, markup=T.unsafe(nil)); end

  def htmlify_line(*args); end

  def insert_include(text, markup=T.unsafe(nil)); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil), anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def mtime(_file); end

  def mtime_url(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def resolve_links(text); end

  def signature(meth, link=T.unsafe(nil), show_extras=T.unsafe(nil), full_attr_name=T.unsafe(nil)); end

  def signature_types(meth, link=T.unsafe(nil)); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
  ASCIIDOC_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  URLMATCH = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::HtmlHelper
  def self.urlencode(text); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def html_syntax_highlight_ruby(source); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
  def fix_typewriter(html); end
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup
  def from_path(); end

  def from_path=(from_path); end

  def initialize(text); end

  def to_html(); end
end

YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP = RDoc::Markup

class YARD::Templates::Helpers::Markup::RDocMarkup
end

module YARD::Templates::Helpers::MarkupHelper
  def load_markup_provider(type=T.unsafe(nil)); end

  def markup_class(type=T.unsafe(nil)); end

  def markup_file_contents(contents); end

  def markup_for_file(contents, filename); end

  def markup_provider(type=T.unsafe(nil)); end
  MARKUP_EXTENSIONS = ::T.let(nil, ::T.untyped)
  MARKUP_FILE_SHEBANG = ::T.let(nil, ::T.untyped)
  MARKUP_PROVIDERS = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::MarkupHelper
  def self.clear_markup_cache(); end

  def self.markup_cache(); end

  def self.markup_cache=(markup_cache); end
end

module YARD::Templates::Helpers::MethodHelper
  def format_args(object); end

  def format_block(object); end

  def format_code(object, _show_lines=T.unsafe(nil)); end

  def format_constant(value); end

  def format_lines(object); end

  def format_return_types(object); end
end

module YARD::Templates::Helpers::MethodHelper
end

module YARD::Templates::Helpers::ModuleHelper
  def prune_method_listing(list, hide_attributes=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::ModuleHelper
end

module YARD::Templates::Helpers::TextHelper
  def align_right(text, spacer=T.unsafe(nil), col=T.unsafe(nil)); end

  def h(text); end

  def hr(col=T.unsafe(nil), sep=T.unsafe(nil)); end

  def indent(text, len=T.unsafe(nil)); end

  def signature(meth); end

  def title_align_right(text, col=T.unsafe(nil)); end

  def wrap(text, col=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::TextHelper
end

module YARD::Templates::Helpers::UMLHelper
  def format_path(object); end

  def h(text); end

  def tidy(data); end

  def uml_visibility(object); end
end

module YARD::Templates::Helpers::UMLHelper
end

class YARD::Templates::Section
  def <<(*args); end

  def ==(other); end

  def [](*args); end

  def any(item); end

  def eql?(other); end

  def initialize(name, *args); end

  def name(); end

  def name=(name); end

  def place(*args); end

  def push(*args); end

  def unshift(*args); end
end

class YARD::Templates::Section
end

module YARD::Templates::Template
  include ::YARD::Templates::ErbCache
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::MethodHelper
  def T(*path); end

  def class(); end

  def class=(_); end

  def erb(section, &block); end

  def erb_file_for(section); end

  def erb_with(content, filename=T.unsafe(nil)); end

  def file(basename, allow_inherited=T.unsafe(nil)); end

  def init(); end

  def initialize(opts=T.unsafe(nil)); end

  def inspect(); end

  def options(); end

  def options=(value); end

  def run(opts=T.unsafe(nil), sects=T.unsafe(nil), start_at=T.unsafe(nil), break_first=T.unsafe(nil), &block); end

  def section(); end

  def section=(section); end

  def sections(*args); end

  def superb(sect=T.unsafe(nil), &block); end

  def yieldall(opts=T.unsafe(nil), &block); end
end

module YARD::Templates::Template::ClassMethods
  def S(*args); end

  def T(*path); end

  def find_file(basename); end

  def find_nth_file(basename, index=T.unsafe(nil)); end

  def full_path(); end

  def full_path=(full_path); end

  def full_paths(); end

  def initialize(path, full_paths); end

  def is_a?(klass); end

  def new(*args); end

  def path(); end

  def path=(path); end

  def reset_full_paths(); end

  def run(*args); end
end

module YARD::Templates::Template::ClassMethods
end

module YARD::Templates::Template
  def self.extra_includes(); end

  def self.extra_includes=(extra_includes); end

  def self.include_extra(template, options); end

  def self.included(klass); end
end

class YARD::Verifier
  def add_expressions(*expressions); end

  def call(object); end

  def expressions(); end

  def expressions=(value); end

  def initialize(*expressions); end

  def method_missing(sym, *args, &block); end

  def o(); end

  def object(); end

  def run(list); end
  NILCLASS_METHODS = ::T.let(nil, ::T.untyped)
end

class YARD::Verifier
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end
